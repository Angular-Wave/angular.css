var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/@angular-wave/angular.ts/dist/angular-ts.umd.js
var require_angular_ts_umd = __commonJS({
  "node_modules/@angular-wave/angular.ts/dist/angular-ts.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.angular = {}));
    })(exports, (function(exports2) {
      "use strict";
      const VALID_CLASS = "ng-valid";
      const INVALID_CLASS = "ng-invalid";
      const PRISTINE_CLASS = "ng-pristine";
      const DIRTY_CLASS = "ng-dirty";
      const UNTOUCHED_CLASS = "ng-untouched";
      const TOUCHED_CLASS = "ng-touched";
      const EMPTY_CLASS = "ng-empty";
      const NOT_EMPTY_CLASS = "ng-not-empty";
      const PREFIX_REGEXP = /^((?:x|data)[-])/i;
      const SPECIAL_CHARS_REGEXP = /[-]+(.)/g;
      const ALIASED_ATTR = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern",
        ngStep: "step"
      };
      const isProxySymbol = Symbol("isProxy");
      function isProxy(value) {
        return !!(value && value[isProxySymbol]);
      }
      const ngMinErr$2 = minErr("ng");
      let uid$1 = 0;
      function nextUid() {
        uid$1 += 1;
        return uid$1;
      }
      function lowercase(string) {
        return isString(string) ? string.toLowerCase() : string;
      }
      function uppercase(string) {
        return isString(string) ? string.toUpperCase() : string;
      }
      function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) return false;
        if (Array.isArray(obj) || obj instanceof Array || isString(obj)) return true;
        const length = "length" in Object(obj) && obj.length;
        return isNumber(length) && (length >= 0 && length - 1 in obj || typeof obj.item === "function");
      }
      function isUndefined(value) {
        return typeof value === "undefined";
      }
      function isDefined(value) {
        return typeof value !== "undefined";
      }
      function isObject(value) {
        return value !== null && typeof value === "object";
      }
      function isString(value) {
        return typeof value === "string";
      }
      function isNull(value) {
        return value === null;
      }
      function isNullOrUndefined(obj) {
        return obj === null || typeof obj === "undefined";
      }
      function isNumber(value) {
        return typeof value === "number";
      }
      function isDate(value) {
        return toString.call(value) === "[object Date]";
      }
      function isError(value) {
        const tag = toString.call(value);
        switch (tag) {
          case "[object Error]":
            return true;
          case "[object Exception]":
            return true;
          case "[object DOMException]":
            return true;
          default:
            return value instanceof Error;
        }
      }
      function isFunction(value) {
        return typeof value === "function";
      }
      function isRegExp(value) {
        return toString.call(value) === "[object RegExp]";
      }
      function isWindow(obj) {
        return obj && obj.window === obj;
      }
      function isScope(obj) {
        return obj && obj.$watch;
      }
      function isFile(obj) {
        return toString.call(obj) === "[object File]";
      }
      function isFormData(obj) {
        return toString.call(obj) === "[object FormData]";
      }
      function isBlob(obj) {
        return toString.call(obj) === "[object Blob]";
      }
      function isBoolean(value) {
        return typeof value === "boolean";
      }
      function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
      }
      function trim(value) {
        return isString(value) ? value.trim() : value;
      }
      function snakeCase(name2, separator) {
        const modseparator = separator;
        return name2.replace(
          /[A-Z]/g,
          (letter, pos) => (pos ? modseparator : "") + letter.toLowerCase()
        );
      }
      function setHashKey(obj, h) {
        if (h) {
          obj.$$hashKey = h;
        } else {
          delete obj.$$hashKey;
        }
      }
      function baseExtend(dst, objs, deep) {
        const h = dst.$$hashKey;
        for (let i = 0, ii = objs.length; i < ii; ++i) {
          const obj = objs[i];
          if (!isObject(obj) && !isFunction(obj)) continue;
          const keys = Object.keys(obj);
          for (let j = 0, jj = keys.length; j < jj; j++) {
            const key = keys[j];
            const src = obj[key];
            {
              dst[key] = src;
            }
          }
        }
        setHashKey(dst, h);
        return dst;
      }
      function extend(dst, ...src) {
        return baseExtend(dst, src);
      }
      function isNumberNaN(num) {
        return Number.isNaN(num);
      }
      function inherit$1(parent, extra) {
        return extend(Object.create(parent), extra);
      }
      function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== toString;
      }
      function isElement(node) {
        return !!(node && (node.nodeName || // We are a direct element.
        node.attr && node.find));
      }
      function getNodeName(element) {
        return lowercase(element.nodeName);
      }
      function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) !== -1;
      }
      function arrayRemove(array, value) {
        const index = array.indexOf(value);
        if (index >= 0) {
          array.splice(index, 1);
        }
        return index;
      }
      function simpleCompare(a, b) {
        return a === b || a !== a && b !== b;
      }
      function equals$1(o1, o2) {
        if (o1 === o2) return true;
        if (o1 === null || o2 === null) return false;
        if (o1 !== o1 && o2 !== o2) return true;
        const t1 = typeof o1;
        const t2 = typeof o2;
        let length;
        let key;
        let keySet;
        if (t1 === t2 && t1 === "object") {
          if (Array.isArray(o1)) {
            if (!Array.isArray(o2)) return false;
            if ((length = o1.length) === o2.length) {
              for (key = 0; key < length; key++) {
                if (!equals$1(o1[key], o2[key])) return false;
              }
              return true;
            }
          } else if (isDate(o1)) {
            if (!isDate(o2)) return false;
            return simpleCompare(o1.getTime(), o2.getTime());
          } else if (isRegExp(o1)) {
            if (!isRegExp(o2)) return false;
            return o1.toString() === o2.toString();
          } else {
            if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || Array.isArray(o2) || isDate(o2) || isRegExp(o2))
              return false;
            keySet = /* @__PURE__ */ Object.create(null);
            for (key in o1) {
              if (key.charAt(0) === "$" || isFunction(o1[key])) continue;
              if (!equals$1(o1[key], o2[key])) return false;
              keySet[key] = true;
            }
            for (key in o2) {
              if (!(key in keySet) && key.charAt(0) !== "$" && isDefined(o2[key]) && !isFunction(o2[key]))
                return false;
            }
            return true;
          }
        }
        return false;
      }
      function assertNotHasOwnProperty(name2, context) {
        if (name2 === "hasOwnProperty") {
          throw ngMinErr$2(
            "badname",
            "hasOwnProperty is not a valid {0} name",
            context
          );
        }
      }
      function stringify$1(value) {
        if (value == null) {
          return "";
        }
        switch (typeof value) {
          case "string":
            break;
          case "number":
            value = `${value}`;
            break;
          default:
            if (hasCustomToString(value) && !Array.isArray(value) && !isDate(value)) {
              value = value.toString();
            } else {
              value = toJson(value);
            }
        }
        return value;
      }
      function isValidObjectMaxDepth(maxDepth) {
        return isNumber(maxDepth) && maxDepth > 0;
      }
      function concat(array1, array2, index) {
        return array1.concat(Array.prototype.slice.call(array2, index));
      }
      function sliceArgs(args, startIndex) {
        return Array.prototype.slice.call(args, startIndex);
      }
      function bind(context, fn) {
        const curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
          return curryArgs.length ? function() {
            return arguments.length ? fn.apply(context, concat(curryArgs, arguments, 0)) : fn.apply(context, curryArgs);
          } : function() {
            return arguments.length ? fn.apply(context, arguments) : fn.call(context);
          };
        }
        return fn;
      }
      function toJsonReplacer(key, value) {
        let val2 = value;
        if (typeof key === "string" && key.charAt(0) === "$" && key.charAt(1) === "$") {
          val2 = void 0;
        } else if (isWindow(value)) {
          val2 = "$WINDOW";
        } else if (value && window.document === value) {
          val2 = "$DOCUMENT";
        } else if (isScope(value)) {
          val2 = "$SCOPE";
        }
        return val2;
      }
      function toJson(obj, pretty) {
        if (isUndefined(obj)) return void 0;
        if (!isNumber(pretty)) {
          pretty = pretty ? 2 : null;
        }
        return JSON.stringify(
          obj,
          toJsonReplacer,
          /** @type {Number} */
          pretty
        );
      }
      function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      }
      function timezoneToOffset(timezone, fallback) {
        const requestedTimezoneOffset = Date.parse(`Jan 01, 1970 00:00:00 ${timezone}`) / 6e4;
        return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        const newDate = new Date(date.getTime());
        newDate.setMinutes(newDate.getMinutes() + minutes);
        return newDate;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        const doReverse = 1;
        const dateTimezoneOffset = date.getTimezoneOffset();
        const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        return addDateMinutes(
          date,
          doReverse * (timezoneOffset - dateTimezoneOffset)
        );
      }
      function parseKeyValue(keyValue) {
        const obj = {};
        (keyValue || "").split("&").forEach((keyValue2) => {
          let splitPoint;
          let key;
          let val2;
          if (keyValue2) {
            key = keyValue2 = keyValue2.replace(/\+/g, "%20");
            splitPoint = keyValue2.indexOf("=");
            if (splitPoint !== -1) {
              key = keyValue2.substring(0, splitPoint);
              val2 = keyValue2.substring(splitPoint + 1);
            }
            key = tryDecodeURIComponent(key);
            if (isDefined(key)) {
              val2 = isDefined(val2) ? tryDecodeURIComponent(val2) : true;
              if (!hasOwn(
                obj,
                /** @type {string} */
                key
              )) {
                obj[key] = val2;
              } else if (Array.isArray(obj[key])) {
                obj[key].push(val2);
              } else {
                obj[key] = [obj[key], val2];
              }
            }
          }
        });
        return (
          /** @type {Object.<string,boolean|Array>} */
          obj
        );
      }
      function toKeyValue(obj) {
        const parts = [];
        obj && Object.entries(obj).forEach(([key, value]) => {
          if (Array.isArray(value)) {
            value.forEach((arrayValue) => {
              parts.push(
                encodeUriQuery(key, true) + (arrayValue === true ? "" : `=${encodeUriQuery(arrayValue, true)}`)
              );
            });
          } else {
            parts.push(
              encodeUriQuery(key, true) + (value === true ? "" : `=${encodeUriQuery(value, true)}`)
            );
          }
        });
        return parts.length ? parts.join("&") : "";
      }
      function tryDecodeURIComponent(value) {
        try {
          return decodeURIComponent(value);
        } catch {
        }
      }
      function encodeUriSegment(val2) {
        return encodeUriQuery(val2, true).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
      }
      function encodeUriQuery(val2, pctEncodeSpaces) {
        return encodeURIComponent(val2).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
      }
      const ngAttrPrefixes = ["ng-", "data-ng-"];
      function getNgAttribute(element, ngAttr) {
        let attr;
        let i;
        const ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
          attr = ngAttrPrefixes[i] + ngAttr;
          if (isString(attr = element.getAttribute(attr))) {
            return attr;
          }
        }
        return null;
      }
      function shallowCopy(src, dst) {
        if (Array.isArray(src)) {
          dst = dst || [];
          for (let i = 0, ii = src.length; i < ii; i++) {
            dst[i] = src[i];
          }
        } else if (isObject(src)) {
          dst = dst || {};
          for (const key in src) {
            if (!(key.startsWith("$") && key.charAt(1) === "$")) {
              dst[key] = src[key];
            }
          }
        }
        return dst || src;
      }
      function assert(argument, errorMsg = "Assertion failed") {
        if (!argument) throw new Error(errorMsg);
      }
      function assertArg$1(arg, name2, reason) {
        if (!arg) {
          throw ngMinErr$2(
            "areq",
            "Argument '{0}' is {1}",
            name2 || "?",
            reason || "required"
          );
        }
        return arg;
      }
      function assertArgFn(arg, name2, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && Array.isArray(arg)) {
          arg = arg[arg.length - 1];
        }
        assertArg$1(
          isFunction(arg),
          name2,
          `not a function, got ${arg && typeof arg === "object" ? arg.constructor.name || "Object" : typeof arg}`
        );
        return arg;
      }
      const minErrConfig = {
        objectMaxDepth: 5,
        urlErrorParamsEnabled: true
      };
      function errorHandlingConfig(config) {
        if (isObject(config)) {
          if (isDefined(config.objectMaxDepth)) {
            minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth) ? config.objectMaxDepth : NaN;
          }
          if (isDefined(config.urlErrorParamsEnabled) && isBoolean(config.urlErrorParamsEnabled)) {
            minErrConfig.urlErrorParamsEnabled = config.urlErrorParamsEnabled;
          }
        }
        return minErrConfig;
      }
      function minErr(module2) {
        return function(...args) {
          const code = args[0];
          const template = args[1];
          let message = `[${module2 ? `${module2}:` : ""}${code}] `;
          const templateArgs = sliceArgs(args, 2).map((arg) => toDebugString(arg));
          message += template.replace(/\{\d+\}/g, (match) => {
            const index = +match.slice(1, -1);
            if (index < templateArgs.length) {
              return templateArgs[index];
            }
            return match;
          });
          return new Error(message);
        };
      }
      function toDebugString(obj) {
        if (typeof obj === "function") {
          return obj.toString().replace(/ \{[\s\S]*$/, "");
        }
        if (isUndefined(obj)) {
          return "undefined";
        }
        if (typeof obj !== "string") {
          const seen = [];
          let copyObj = structuredClone(isProxy(obj) ? obj.$target : obj);
          return JSON.stringify(copyObj, (key, val2) => {
            const replace = toJsonReplacer(key, val2);
            if (isObject(replace)) {
              if (seen.indexOf(replace) >= 0) return "...";
              seen.push(replace);
            }
            return replace;
          });
        }
        return obj;
      }
      function hashKey(obj) {
        const key = obj && obj.$$hashKey;
        if (key) {
          if (typeof key === "function") {
            return obj.$$hashKey();
          }
          return key;
        }
        const objType = typeof obj;
        if (objType === "function" || objType === "object" && obj !== null) {
          obj.$$hashKey = `${objType}:${nextUid()}`;
          return obj.$$hashKey;
        }
        if (objType === "undefined") {
          return `${objType}:${nextUid()}`;
        }
        return `${objType}:${obj}`;
      }
      function mergeClasses$1(a, b) {
        if (!a && !b) return "";
        if (!a) return b;
        if (!b) return a;
        if (Array.isArray(a)) a = a.join(" ");
        if (Array.isArray(b)) b = b.join(" ");
        return a + " " + b;
      }
      function directiveNormalize(name2) {
        return name2.replace(PREFIX_REGEXP, "").replace(
          SPECIAL_CHARS_REGEXP,
          (_, letter, offset) => offset ? letter.toUpperCase() : letter
        );
      }
      function hasAnimate(node) {
        return hasCustomOrDataAttribute(node, "animate");
      }
      function hasCustomOrDataAttribute(node, attr) {
        if (node.nodeType !== Node.ELEMENT_NODE) return false;
        const element = (
          /** @type {HTMLElement} */
          node
        );
        return element.dataset[attr] === "true" || element.getAttribute(attr) === "true";
      }
      function isObjectEmpty(obj) {
        if (!obj) return true;
        return !Object.keys(obj).length;
      }
      function hasOwn(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }
      function callBackOnce(fn) {
        let called = false;
        return function(...args) {
          if (!called) {
            called = true;
            return fn.apply(this, args);
          }
        };
      }
      function callBackAfterFirst(fn) {
        let calledOnce = false;
        return function(...args) {
          if (calledOnce) {
            return fn.apply(this, args);
          }
          calledOnce = true;
        };
      }
      function wait(t = 0) {
        return new Promise((resolve) => setTimeout(resolve, t));
      }
      function startsWith(str, search) {
        return str.slice(0, search.length) === search;
      }
      const Cache = /* @__PURE__ */ new Map();
      let jqId = 1;
      const ISOLATE_SCOPE_KEY = "$isolateScope";
      const EXPANDO = "ng";
      const SCOPE_KEY = "$scope";
      const DASH_LOWERCASE_REGEXP = /-([a-z])/g;
      const UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g;
      const BOOLEAN_ATTR = [
        "multiple",
        "selected",
        "checked",
        "disabled",
        "readonly",
        "required",
        "open"
      ];
      const BOOLEAN_ELEMENTS = [
        "INPUT",
        "SELECT",
        "OPTION",
        "TEXTAREA",
        "BUTTON",
        "FORM",
        "DETAILS"
      ];
      function jqNextId() {
        return ++jqId;
      }
      function fnCamelCaseReplace(_all, letter) {
        return letter.toUpperCase();
      }
      function kebabToCamel(name2) {
        return name2.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);
      }
      function snakeToCamel(name2) {
        return name2.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);
      }
      function removeElementData(element, name2) {
        const expandoId = element[EXPANDO];
        const expandoStore = expandoId && Cache.get(expandoId);
        if (expandoStore) {
          if (name2) {
            delete expandoStore.data[name2];
          } else {
            expandoStore.data = {};
          }
          removeIfEmptyData(element);
        }
      }
      function getExpando(element, createIfNecessary = false) {
        let expandoId = element[EXPANDO];
        let expandoStore = expandoId && Cache.get(expandoId);
        if (createIfNecessary && !expandoStore) {
          element[EXPANDO] = expandoId = jqNextId();
          expandoStore = {
            data: {}
          };
          Cache.set(expandoId, expandoStore);
        }
        return expandoStore;
      }
      function isTextNode(html) {
        return !/<|&#?\w+;/.test(html);
      }
      function elementAcceptsData(node) {
        switch (node.nodeType) {
          case Node.ELEMENT_NODE:
          case Node.DOCUMENT_NODE:
          case Node.COMMENT_NODE:
          case void 0:
            return true;
          default:
            return false;
        }
      }
      function dealoc(element, onlyDescendants) {
        if (!element) return;
        if (Array.isArray(element)) {
          element.forEach((x) => dealoc(x, onlyDescendants));
        } else {
          if (!onlyDescendants && elementAcceptsData(element)) {
            cleanElementData([element]);
          }
          if (elementAcceptsData(element)) {
            cleanElementData(element.querySelectorAll("*"));
          }
        }
        delete element[EXPANDO];
        element.innerHTML = "";
      }
      function removeIfEmptyData(element) {
        const expandoId = element[EXPANDO];
        const { data } = Cache.get(expandoId);
        if (!data || !Object.keys(data).length) {
          Cache.delete(expandoId);
          element[EXPANDO] = void 0;
        }
      }
      function getOrSetCacheData(element, key, value) {
        if (elementAcceptsData(element)) {
          let prop;
          const isSimpleSetter = isDefined(value);
          const isSimpleGetter = !isSimpleSetter && key && !isObject(key);
          const massGetter = !key;
          const expandoStore = getExpando(element, !isSimpleGetter);
          const data = expandoStore && expandoStore.data;
          if (isSimpleSetter) {
            data[kebabToCamel(key)] = value;
          } else {
            if (massGetter) {
              return data;
            }
            if (isSimpleGetter) {
              return data && data[kebabToCamel(key)];
            }
            for (prop in key) {
              data[kebabToCamel(prop)] = key[prop];
            }
          }
        }
      }
      function setCacheData(element, key, value) {
        if (elementAcceptsData(element)) {
          const expandoStore = getExpando(
            /** @type {Element} */
            element,
            true
          );
          const data = expandoStore && expandoStore.data;
          data[kebabToCamel(key)] = value;
        } else {
          if (element.parentElement) {
            setCacheData(element.parentElement, key, value);
          }
        }
      }
      function getCacheData(element, key) {
        if (elementAcceptsData(element)) {
          const expandoStore = getExpando(element, false);
          const data = expandoStore && expandoStore.data;
          if (!key) {
            return void 0;
          }
          return data && data[kebabToCamel(key)];
        }
        return void 0;
      }
      function deleteCacheData(element, key) {
        if (elementAcceptsData(element)) {
          const expandoStore = getExpando(element, false);
          const data = expandoStore?.data;
          if (data && hasOwn(data, kebabToCamel(key))) {
            delete data[kebabToCamel(key)];
          }
        }
      }
      function getScope(element) {
        return getCacheData(element, SCOPE_KEY);
      }
      function setScope(element, scope) {
        return setCacheData(element, SCOPE_KEY, scope);
      }
      function setIsolateScope(element, scope) {
        return setCacheData(element, ISOLATE_SCOPE_KEY, scope);
      }
      function getController(element, name2) {
        return getInheritedData(element, `$${name2 || "ngController"}Controller`);
      }
      function getInheritedData(element, name2) {
        if (element.nodeType === Node.DOCUMENT_NODE) {
          element = /** @type {Document} */
          element.documentElement;
        }
        let value;
        while (element) {
          if (isDefined(value = getCacheData(
            /** @type {Element} */
            element,
            name2
          )))
            return value;
          element = element.parentNode || element.nodeType === Node.DOCUMENT_FRAGMENT_NODE && /** @type {ShadowRoot} */
          element.host;
        }
      }
      function removeElement(element, keepData = false) {
        if (!keepData) {
          dealoc(element);
        }
        const parent = element.parentNode;
        if (parent) parent.removeChild(element);
      }
      function startingTag(elementOrStr) {
        let clone;
        if (typeof elementOrStr === "string") {
          const parser = new DOMParser();
          const doc = parser.parseFromString(elementOrStr, "text/html");
          clone = doc.body.firstChild.cloneNode(true);
        } else if (elementOrStr instanceof Element || elementOrStr instanceof Node) {
          clone = elementOrStr.cloneNode(true);
        } else {
          throw new Error("Input must be an HTML string or a DOM element.");
        }
        while (clone.firstChild) {
          clone.removeChild(clone.firstChild);
        }
        const divWrapper = document.createElement("div");
        divWrapper.appendChild(clone);
        const elemHtml = divWrapper.innerHTML;
        try {
          if (clone.nodeType === Node.TEXT_NODE) {
            return elemHtml.toLowerCase();
          } else if (clone.nodeType === Node.COMMENT_NODE) {
            return `<!--${/** @type {Comment} **/
            clone.data.trim()}-->`;
          } else {
            const match = elemHtml.match(/^(<[^>]+>)/);
            if (match) {
              return match[1].replace(/^<([\w-]+)/, (_match, nodeName) => {
                return "<" + nodeName.toLowerCase();
              });
            }
          }
        } catch {
          return elemHtml.toLowerCase();
        }
        return elemHtml.toLowerCase();
      }
      function getBlockNodes(nodes) {
        let node = nodes[0];
        const endNode = nodes[nodes.length - 1];
        let blockNodes;
        for (let i = 1; node !== endNode && (node = node.nextSibling); i++) {
          if (blockNodes || nodes[i] !== node) {
            if (!blockNodes) {
              blockNodes = Array.prototype.slice.call(nodes, 0, i);
            }
            blockNodes.push(node);
          }
        }
        return blockNodes || nodes;
      }
      function getBooleanAttrName(element, name2) {
        const normalizedName = name2.toLowerCase();
        const isBooleanAttr = BOOLEAN_ATTR.includes(normalizedName);
        return isBooleanAttr && BOOLEAN_ELEMENTS.includes(element.nodeName) ? normalizedName : false;
      }
      function cleanElementData(nodes) {
        for (let i = 0, ii = nodes.length; i < ii; i++) {
          removeElementData(nodes[i]);
        }
      }
      function getInjector(element) {
        return getInheritedData(element, "$injector");
      }
      function createElementFromHTML(htmlString) {
        const template = document.createElement("template");
        template.innerHTML = htmlString.trim();
        return (
          /** @type {Element} */
          template.content.firstChild
        );
      }
      function createNodelistFromHTML(htmlString) {
        const template = document.createElement("template");
        template.innerHTML = htmlString.trim();
        return template.content.childNodes;
      }
      function emptyElement(element) {
        dealoc(element, true);
        switch (element.nodeType) {
          case Node.ELEMENT_NODE:
          case Node.DOCUMENT_NODE:
          case Node.DOCUMENT_FRAGMENT_NODE:
            element.replaceChildren();
            break;
        }
      }
      function domInsert(element, parentElement, afterElement) {
        if (afterElement) {
          const afterNode = extractElementNode$1(afterElement);
          if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
            afterElement = null;
          }
        }
        if (afterElement) {
          afterElement.after(element);
        } else {
          parentElement.prepend(element);
        }
      }
      function extractElementNode$1(element) {
        const { length } = element;
        for (let i = 0; i < length; i++) {
          const elm = element[i];
          if (elm.nodeType === Node.ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function getBaseHref() {
        const href = document.querySelector("base")?.getAttribute("href");
        return href ? href.replace(/^(https?:)?\/\/[^/]*/, "") : "";
      }
      const $injectTokens = Object.freeze({
        $attrs: "$attrs",
        $scope: "$scope",
        $element: "$element",
        $$AnimateRunner: "$$AnimateRunner",
        $$animateAsyncRun: "$$animateAsyncRun",
        $$animateCache: "$$animateCache",
        $$animateCssDriver: "$$animateCssDriver",
        $$animateJs: "$$animateJs",
        $$animateJsDriver: "$$animateJsDriver",
        $$animateQueue: "$$animateQueue",
        $$animation: "$$animation",
        $$rAFScheduler: "$$rAFScheduler",
        $$taskTrackerFactory: "$$taskTrackerFactory",
        $anchorScroll: "$anchorScroll",
        $animate: "$animate",
        $animateCss: "$animateCss",
        $aria: "$aria",
        $compile: "$compile",
        $controller: "$controller",
        $eventBus: "$eventBus",
        $exceptionHandler: "$exceptionHandler",
        $filter: "$filter",
        $http: "$http",
        $httpBackend: "$httpBackend",
        $httpParamSerializer: "$httpParamSerializer",
        $interpolate: "$interpolate",
        $location: "$location",
        $log: "$log",
        $viewScroll: "$viewScroll",
        $parse: "$parse",
        $rootScope: "$rootScope",
        $rootElement: "$rootElement",
        $router: "$router",
        $sce: "$sce",
        $sceDelegate: "$sceDelegate",
        $state: "$state",
        $stateRegistry: "$stateRegistry",
        $templateCache: "$templateCache",
        $templateFactory: "$templateFactory",
        $templateRequest: "$templateRequest",
        $transitions: "$transitions",
        $urlConfig: "$urlConfig",
        $url: "$url",
        $view: "$view",
        // provide literals
        $provide: "$provide",
        $injector: "$injector",
        $compileProvider: "$compileProvider",
        $animateProvider: "$animateProvider",
        $filterProvider: "$filterProvider",
        $controllerProvider: "$controllerProvider"
      });
      function provider(services) {
        return services.map((x) => x + "Provider");
      }
      const INJECTOR_LITERAL = "$injector";
      const COMPILE_LITERAL = "$compileProvider";
      const ANIMATION_LITERAL = "$animateProvider";
      const FILTER_LITERAL = "$filterProvider";
      const CONTROLLER_LITERAL = "$controllerProvider";
      class NgModule {
        /**
         * @param {string} name - Name of the module
         * @param {Array<string>} requires - List of modules which the injector will load before the current module
         * @param {import("../../interface.js").Injectable} [configFn]
         */
        constructor(name2, requires, configFn) {
          assert(isString(name2), "name required");
          assert(Array.isArray(requires), "requires array required");
          this.name = name2;
          this.requires = requires;
          this.invokeQueue = [];
          this.configBlocks = [];
          this.runBlocks = [];
          if (configFn) {
            this.config(configFn);
          }
        }
        /**
         * @param {string} name
         * @param {any} object
         * @returns {NgModule}
         */
        value(name2, object) {
          this.invokeQueue.push([$injectTokens.$provide, "value", [name2, object]]);
          return this;
        }
        /**
         * @param {string} name
         * @param {any} object
         * @returns {NgModule}
         */
        constant(name2, object) {
          this.invokeQueue.unshift([$injectTokens.$provide, "constant", [name2, object]]);
          return this;
        }
        /**
         *
         * @param {import("../../interface.js").Injectable} configFn
         * @returns {NgModule}
         */
        config(configFn) {
          this.configBlocks.push([INJECTOR_LITERAL, "invoke", [configFn]]);
          return this;
        }
        /**
         * @param {import("../../interface.js").Injectable} block
         * @returns {NgModule}
         */
        run(block) {
          this.runBlocks.push(block);
          return this;
        }
        /**
         * @param {string} name
         * @param {import("../../interface.js").ComponentOptions} options
         * @returns {NgModule}
         */
        component(name2, options) {
          if (options && isFunction(options)) {
            options["$$moduleName"] = name2;
          }
          this.invokeQueue.push([COMPILE_LITERAL, "component", [name2, options]]);
          return this;
        }
        /**
         * @param {string} name
         * @param {import("../../interface.js").Injectable} providerFunction
         * @returns {NgModule}
         */
        factory(name2, providerFunction) {
          if (providerFunction && isFunction(providerFunction)) {
            providerFunction["$$moduleName"] = name2;
          }
          this.invokeQueue.push([$injectTokens.$provide, "factory", [name2, providerFunction]]);
          return this;
        }
        /**
         * @param {string} name
         * @param {import("../../interface.js").Injectable} serviceFunction
         * @returns {NgModule}
         */
        service(name2, serviceFunction) {
          if (serviceFunction && isFunction(serviceFunction)) {
            serviceFunction["$$moduleName"] = name2;
          }
          this.invokeQueue.push([$injectTokens.$provide, "service", [name2, serviceFunction]]);
          return this;
        }
        /**
         * @param {string} name
         * @param {import("../../interface.js").Injectable} providerType
         * @returns {NgModule}
         */
        provider(name2, providerType) {
          if (providerType && isFunction(providerType)) {
            providerType["$$moduleName"] = name2;
          }
          this.invokeQueue.push([$injectTokens.$provide, "provider", [name2, providerType]]);
          return this;
        }
        /**
         * @param {string} name
         * @param {import("../../interface.js").Injectable} decorFn
         * @returns {NgModule}
         */
        decorator(name2, decorFn) {
          if (decorFn && isFunction(decorFn)) {
            decorFn["$$moduleName"] = name2;
          }
          this.configBlocks.push([$injectTokens.$provide, "decorator", [name2, decorFn]]);
          return this;
        }
        /**
         * @param {string} name
         * @param {import("../../interface.js").Injectable} directiveFactory
         * @returns {NgModule}
         */
        directive(name2, directiveFactory) {
          if (directiveFactory && isFunction(directiveFactory)) {
            directiveFactory["$$moduleName"] = name2;
          }
          this.invokeQueue.push([
            COMPILE_LITERAL,
            "directive",
            [name2, directiveFactory]
          ]);
          return this;
        }
        /**
         * @param {string} name
         * @param {import("../../interface.js").Injectable} animationFactory
         * @returns {NgModule}
         */
        animation(name2, animationFactory) {
          if (animationFactory && isFunction(animationFactory)) {
            animationFactory["$$moduleName"] = name2;
          }
          this.invokeQueue.push([
            ANIMATION_LITERAL,
            "register",
            [name2, animationFactory]
          ]);
          return this;
        }
        /**
         * @param {string} name
         * @param {import("../../interface.js").Injectable} filterFn
         * @return {NgModule}
         */
        filter(name2, filterFn) {
          if (filterFn && isFunction(filterFn)) {
            filterFn["$$moduleName"] = name2;
          }
          this.invokeQueue.push([FILTER_LITERAL, "register", [name2, filterFn]]);
          return this;
        }
        /**
         * @param {string} name
         * @param {import("../../interface.js").Injectable} ctlFn
         * @returns {NgModule}
         */
        controller(name2, ctlFn) {
          if (ctlFn && isFunction(ctlFn)) {
            ctlFn["$$moduleName"] = name2;
          }
          this.invokeQueue.push([CONTROLLER_LITERAL, "register", [name2, ctlFn]]);
          return this;
        }
      }
      const ARROW_ARG$1 = /^([^(]+?)=>/;
      const FN_ARGS$1 = /^[^(]*\(\s*([^)]*)\)/m;
      const FN_ARG$1 = /^\s*(_?)(\S+?)\1\s*$/;
      const STRIP_COMMENTS$1 = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
      const $injectorMinErr$2 = minErr(INJECTOR_LITERAL);
      const providerSuffix$1 = "Provider";
      const INSTANTIATING = true;
      class AbstractInjector {
        /**
         * @param {boolean} strictDi - Indicates if strict dependency injection is enforced.
         */
        constructor(strictDi) {
          this.cache = {};
          this.strictDi = strictDi;
          this.path = [];
          this.modules = {};
        }
        /**
         * Get a service by name.
         *
         * @param {string} serviceName
         * @returns {any}
         */
        get(serviceName) {
          if (hasOwn(this.cache, serviceName)) {
            if (this.cache[serviceName] === INSTANTIATING) {
              throw $injectorMinErr$2(
                "cdep",
                "Circular dependency found: {0}",
                `${serviceName} <- ${this.path.join(" <- ")}`
              );
            }
            return this.cache[serviceName];
          }
          this.path.unshift(serviceName);
          this.cache[serviceName] = INSTANTIATING;
          try {
            this.cache[serviceName] = this.factory(serviceName);
          } catch (err2) {
            delete this.cache[serviceName];
            throw err2;
          }
          return this.cache[serviceName];
        }
        /**
         * Get the injection arguments for a function.
         *
         * @param {Function|Array} fn
         * @param {Object} locals
         * @param {string} serviceName
         * @returns
         */
        injectionArgs(fn, locals, serviceName) {
          const args = [];
          const $inject = annotate$1(fn, this.strictDi, serviceName);
          for (let i = 0, { length } = $inject; i < length; i++) {
            const key = $inject[i];
            if (typeof key !== "string") {
              throw $injectorMinErr$2(
                "itkn",
                "Incorrect injection token! Expected service name as string, got {0}",
                key
              );
            }
            args.push(locals && hasOwn(locals, key) ? locals[key] : this.get(key));
          }
          return args;
        }
        /**
         * Invoke a function with optional context and locals.
         *
         * @param {Function|String|Array<any>} fn
         * @param {*} [self]
         * @param {Object} [locals]
         * @param {string} [serviceName]
         * @returns {*}
         */
        invoke(fn, self2, locals, serviceName) {
          if (typeof locals === "string") {
            serviceName = locals;
            locals = null;
          }
          const args = this.injectionArgs(
            /** @type {Function} */
            fn,
            locals,
            serviceName
          );
          if (Array.isArray(fn)) {
            fn = fn[fn.length - 1];
          }
          if (isClass(
            /** @type {Function} */
            fn
          )) {
            args.unshift(null);
            return new (Function.prototype.bind.apply(fn, args))();
          } else {
            return (
              /** @type {Function} */
              fn.apply(self2, args)
            );
          }
        }
        /**
         * Instantiate a type constructor with optional locals.
         * @param {Function|Array} type
         * @param {*} [locals]
         * @param {string} [serviceName]
         */
        instantiate(type, locals, serviceName) {
          const ctor = Array.isArray(type) ? type[type.length - 1] : type;
          const args = this.injectionArgs(type, locals, serviceName);
          args.unshift(null);
          return new (Function.prototype.bind.apply(ctor, args))();
        }
        /**
         * @abstract
         */
        loadNewModules() {
        }
        /**
         * @abstract
         * @param {string} _serviceName
         * @returns {any}
         */
        factory(_serviceName) {
          console.error(`Unhandled ${_serviceName}`);
        }
      }
      class ProviderInjector extends AbstractInjector {
        /**
         * @param {Object} cache
         * @param {boolean} strictDi - Indicates if strict dependency injection is enforced.
         */
        constructor(cache2, strictDi) {
          super(strictDi);
          this.cache = cache2;
        }
        /**
         * Factory method for creating services.
         * @param {string} caller - The name of the caller requesting the service.
         * @throws {Error} If the provider is unknown.
         */
        factory(caller) {
          this.path.push(caller);
          throw $injectorMinErr$2(
            "unpr",
            "Unknown provider: {0}",
            this.path.join(" <- ")
          );
        }
      }
      class InjectorService extends AbstractInjector {
        /**
         * @param {ProviderInjector} providerInjector
         * @param {boolean} strictDi - Indicates if strict dependency injection is enforced.
         */
        constructor(providerInjector, strictDi) {
          super(strictDi);
          this.providerInjector = providerInjector;
          this.modules = providerInjector.modules;
        }
        /**
         * @param {string} serviceName
         * @returns {*}
         */
        factory(serviceName) {
          const provider2 = this.providerInjector.get(serviceName + providerSuffix$1);
          return this.invoke(provider2.$get, provider2, void 0, serviceName);
        }
        /**
         *
         * @param {string} name
         * @returns {boolean}
         */
        has(name2) {
          const hasProvider = hasOwn(
            this.providerInjector.cache,
            name2 + providerSuffix$1
          );
          const hasCache = hasOwn(this.cache, name2);
          return hasProvider || hasCache;
        }
      }
      function stringifyFn$1(fn) {
        return Function.prototype.toString.call(fn);
      }
      function extractArgs$1(fn) {
        const fnText = stringifyFn$1(fn).replace(STRIP_COMMENTS$1, "");
        return fnText.match(ARROW_ARG$1) || fnText.match(FN_ARGS$1);
      }
      function isClass(func) {
        return /^class\b/.test(stringifyFn$1(func));
      }
      function annotate$1(fn, strictDi, name2) {
        let $inject, argDecl, last;
        if (typeof fn === "function") {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                throw $injectorMinErr$2(
                  "strictdi",
                  "{0} is not using explicit annotation and cannot be invoked in strict mode",
                  name2
                );
              }
              argDecl = extractArgs$1(fn);
              argDecl[1].split(/,/).forEach(function(arg) {
                arg.replace(FN_ARG$1, function(_all, _underscore, name3) {
                  $inject.push(name3);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (Array.isArray(fn)) {
          last = /** @type {Array} */
          fn.length - 1;
          assertArgFn(fn[last], "fn");
          $inject = /** @type {Array} */
          fn.slice(0, last);
        } else {
          assertArgFn(fn, "fn", true);
        }
        return $inject;
      }
      const ARROW_ARG = /^([^(]+?)=>/;
      const FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m;
      const FN_ARG_SPLIT = /,/;
      const FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
      const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
      const $injectorMinErr$1 = minErr(INJECTOR_LITERAL);
      const providerSuffix = "Provider";
      function createInjector(modulesToLoad, strictDi = false) {
        assert(Array.isArray(modulesToLoad), "modules required");
        const loadedModules = /* @__PURE__ */ new Map();
        const providerCache = {
          $provide: {
            provider: supportObject(provider2),
            factory: supportObject(factory),
            service: supportObject(service),
            value: supportObject(value),
            constant: supportObject(constant),
            decorator
          }
        };
        const providerInjector = providerCache.$injector = new ProviderInjector(
          providerCache,
          strictDi
        );
        const protoInstanceInjector = new InjectorService(providerInjector, strictDi);
        providerCache.$injectorProvider = {
          // $injectionProvider return instance injector
          $get: () => protoInstanceInjector
        };
        let instanceInjector = protoInstanceInjector;
        const runBlocks = loadModules(modulesToLoad);
        instanceInjector = protoInstanceInjector.get(INJECTOR_LITERAL);
        runBlocks.forEach((fn) => fn && instanceInjector.invoke(fn));
        instanceInjector.loadNewModules = (mods) => loadModules(mods).forEach((fn) => fn && instanceInjector.invoke(fn));
        return instanceInjector;
        function provider2(name2, provider3) {
          assertNotHasOwnProperty(name2, "service");
          let newProvider;
          if (isFunction(provider3) || Array.isArray(provider3)) {
            newProvider = providerInjector.instantiate(
              /** @type {Function} */
              provider3
            );
          } else {
            newProvider = provider3;
          }
          if (!newProvider.$get) {
            throw $injectorMinErr$1(
              "pget",
              "Provider '{0}' must define $get factory method.",
              name2
            );
          }
          providerCache[name2 + providerSuffix] = newProvider;
          return newProvider;
        }
        function factory(name2, factoryFn) {
          return provider2(name2, {
            $get: () => {
              const result = instanceInjector.invoke(factoryFn, this);
              if (isUndefined(result)) {
                throw $injectorMinErr$1(
                  "undef",
                  "Provider '{0}' must return a value from $get factory method.",
                  name2
                );
              }
              return result;
            }
          });
        }
        function service(name2, constructor) {
          return factory(name2, [
            INJECTOR_LITERAL,
            ($injector) => $injector.instantiate(constructor)
          ]);
        }
        function value(name2, val2) {
          return providerCache[name2 + providerSuffix] = { $get: () => val2 };
        }
        function constant(name2, value2) {
          assertNotHasOwnProperty(name2, "constant");
          providerInjector.cache[name2] = value2;
          protoInstanceInjector.cache[name2] = value2;
        }
        function decorator(serviceName, decorFn) {
          const origProvider = providerInjector.get(serviceName + providerSuffix);
          const origGet = origProvider.$get;
          origProvider.$get = function() {
            const origInstance = instanceInjector.invoke(origGet, origProvider);
            return instanceInjector.invoke(decorFn, null, {
              $delegate: origInstance
            });
          };
        }
        function loadModules(modulesToLoad2) {
          assertArg$1(
            isUndefined(modulesToLoad2) || Array.isArray(modulesToLoad2),
            "modulesToLoad",
            "not an array"
          );
          let runBlocks2 = [];
          modulesToLoad2.forEach((module2) => {
            if (loadedModules.get(module2)) return;
            loadedModules.set(module2, true);
            try {
              if (isString(module2)) {
                const moduleFn = window["angular"].module(module2);
                instanceInjector.modules[
                  /** @type {string } */
                  module2
                ] = moduleFn;
                runBlocks2 = runBlocks2.concat(loadModules(moduleFn.requires)).concat(moduleFn.runBlocks);
                const invokeQueue = moduleFn.invokeQueue.concat(
                  moduleFn.configBlocks
                );
                invokeQueue.forEach((invokeArgs) => {
                  const provider3 = providerInjector.get(invokeArgs[0]);
                  provider3[invokeArgs[1]].apply(provider3, invokeArgs[2]);
                });
              } else if (isFunction(module2)) {
                runBlocks2.push(providerInjector.invoke(module2));
              } else if (Array.isArray(module2)) {
                runBlocks2.push(providerInjector.invoke(module2));
              } else {
                assertArgFn(module2, "module");
              }
            } catch (e) {
              if (Array.isArray(module2)) {
                module2 = module2[module2.length - 1];
              }
              if (e.message && e.stack && e.stack.indexOf(e.message) === -1) {
                e.message = `${e.message}
${e.stack}`;
              }
              throw $injectorMinErr$1(
                "modulerr",
                "Failed to instantiate module {0} due to:\n{1}",
                module2,
                e.stack || e.message || e
              );
            }
          });
          return runBlocks2;
        }
      }
      function stringifyFn(fn) {
        return Function.prototype.toString.call(fn);
      }
      function extractArgs(fn) {
        const fnText = stringifyFn(fn).replace(STRIP_COMMENTS, "");
        return fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
      }
      function annotate(fn, strictDi, name2) {
        let $inject, argDecl, last;
        if (typeof fn === "function") {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                throw $injectorMinErr$1(
                  "strictdi",
                  "{0} is not using explicit annotation and cannot be invoked in strict mode",
                  name2
                );
              }
              argDecl = extractArgs(
                /** @type {String} */
                fn
              );
              argDecl[1].split(FN_ARG_SPLIT).forEach(function(arg) {
                arg.replace(FN_ARG, function(all, underscore, name3) {
                  $inject.push(name3);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (Array.isArray(fn)) {
          last = /** @type {Array} */
          fn.length - 1;
          assertArgFn(fn[last], "fn");
          $inject = /** @type {Array} */
          fn.slice(0, last);
        } else {
          assertArgFn(fn, "fn", true);
        }
        return $inject;
      }
      function supportObject(delegate) {
        return function(key, value) {
          if (isObject(key)) {
            Object.entries(key).forEach(([k, v]) => {
              delegate(k, v);
            });
          } else {
            return delegate(key, value);
          }
        };
      }
      class NodeRef {
        /**
         * @param {Node | Element | string | NodeList | Node[]} element - The DOM node(s) or HTML string to wrap.
         * @throws {Error} If the argument is invalid or cannot be wrapped properly.
         */
        constructor(element) {
          assertArg$1(element, "element");
          this.initial = null;
          this._node = null;
          this._element = void 0;
          this._nodes = void 0;
          this.linked = false;
          this.isList = false;
          if (isString(element)) {
            this.initial = element;
            let res = createElementFromHTML(
              /** @type {string} */
              element
            );
            switch (true) {
              case res instanceof Element:
                this.element = res;
                break;
              case res instanceof Node:
                this.node = res;
                break;
            }
          } else if (element instanceof NodeList) {
            this.initial = Array.from(element).map((e) => e.cloneNode(true));
            if (element.length == 1) {
              this.node = element[0];
            } else {
              this._nodes = Array.from(element);
              this.isList = true;
            }
          } else if (element instanceof Element) {
            this.initial = element.cloneNode(true);
            this.element = /** @type {Element} */
            element;
          } else if (element instanceof Node) {
            this.initial = element.cloneNode(true);
            this._node = element;
          } else if (element instanceof Array) {
            if (element.length == 1) {
              this.initial = element[0].cloneNode(true);
              this.node = element[0];
            } else {
              this.initial = Array.from(element).map((e) => e.cloneNode(true));
              this.nodes = element;
            }
          } else {
            throw new Error("Invalid element passed to NodeRef");
          }
        }
        /** @returns {Element} */
        get element() {
          assertArg$1(this._element, "element");
          return this._element;
        }
        /** @param {Element} el */
        set element(el) {
          assertArg$1(el instanceof Element, "element");
          this._element = el;
          this._nodes = void 0;
          this.isList = false;
        }
        /** @returns {Node | ChildNode} */
        get node() {
          assertArg$1(this._node || this._element, "node");
          return this._node || this._element;
        }
        /** @param {Node | ChildNode} node */
        set node(node) {
          assertArg$1(node instanceof Node, "node");
          this._node = node;
          if (node.nodeType === Node.ELEMENT_NODE) {
            this._element = /** @type {Element} */
            node;
          } else {
            this._element = void 0;
          }
        }
        /** @param {Array<Node>} nodes */
        set nodes(nodes) {
          assertArg$1(
            Array.isArray(nodes) && nodes.every((n) => n instanceof Node),
            "nodes"
          );
          this._nodes = nodes;
          this.isList = true;
        }
        /** @returns {Array<Node>} */
        get nodes() {
          assertArg$1(this._nodes, "nodes");
          return this._nodes;
        }
        /** @returns {NodeList|Node[]} */
        get nodelist() {
          assertArg$1(this.isList, "nodes");
          if (this._nodes.length === 0) {
            return this._nodes;
          }
          if (this._nodes[0].parentElement) {
            return this._nodes[0].parentElement.childNodes;
          } else {
            const fragment = document.createDocumentFragment();
            this._nodes.forEach((el) => {
              fragment.appendChild(el);
            });
            return fragment.childNodes;
          }
        }
        /** @returns {Element | Node | ChildNode | NodeList | Node[]} */
        get dom() {
          if (this.isList) return this.nodelist;
          else return this.node;
        }
        /** @returns {number} */
        get size() {
          return this.isList ? this._nodes.length : 1;
        }
        /** @returns {Element | Node | ChildNode} */
        getAny() {
          if (this.isList) {
            return this._nodes[0];
          } else {
            return this._element || this._node;
          }
        }
        /** @returns {Element | Array<Node> | Node | ChildNode} */
        getAll() {
          if (this.isList) {
            return this._nodes;
          } else {
            return this._element || this._node;
          }
        }
        /** @returns {Array<Element> | Array<Node>} */
        collection() {
          if (this.isList) {
            return Array.from(this._nodes);
          } else {
            return [this._element || this._node];
          }
        }
        /**
         * @param {number} index
         * @returns {Element | Node | ChildNode}
         */
        getIndex(index) {
          if (this.isList) {
            return this._nodes[index];
          } else {
            return this.node;
          }
        }
        /**
         * @param {number} index
         * @param {Element | Node | ChildNode} node
         */
        setIndex(index, node) {
          assertArg$1(index !== null, "index");
          assertArg$1(node, "node");
          if (this.isList) {
            this._nodes[index] = node;
          } else {
            this.node = node;
          }
        }
        /**
         * @returns {NodeRef}
         */
        clone() {
          const cloned = this.isList ? this.nodes.map((el) => el.cloneNode(true)) : this.node.cloneNode(true);
          return new NodeRef(cloned);
        }
        isElement() {
          return this._element !== void 0;
        }
      }
      const $controllerMinErr = minErr("$controller");
      const CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
      function identifierForController(controller, ident) {
        if (isString(controller)) {
          const match = CNTRL_REG.exec(controller);
          if (match) return match[3];
        }
      }
      class ControllerProvider {
        constructor() {
          this.controllers = /* @__PURE__ */ new Map();
        }
        /**
         * Check if a controller with a given name exists.
         *
         * @param {string} name Controller name to check.
         * @returns {boolean} True if the controller exists, false otherwise.
         */
        has(name2) {
          return this.controllers.has(name2);
        }
        /**
         * Register a controller.
         *
         * @param {string|Object} name Controller name, or an object map of controllers where the keys are
         *    the names and the values are the constructors.
         * @param {Function|Array} constructor Controller constructor function (optionally decorated with DI
         *    annotations in the array notation).
         */
        register(name2, constructor) {
          assertNotHasOwnProperty(name2, "controller");
          if (isObject(name2)) {
            Object.entries(name2).forEach(([key, value]) => {
              this.controllers.set(key, value);
            });
          } else {
            this.controllers.set(name2, constructor);
          }
        }
        /**
         * $get method for dependency injection.
         */
        $get = [
          "$injector",
          /**
           * @param {import("../../core/di/internal-injector.js").InjectorService} $injector
           * @returns {Function} A service function that creates controllers.
           */
          ($injector) => {
            return (expression, locals, later, ident) => {
              let instance;
              let match;
              let constructor;
              let identifier = ident && isString(ident) ? ident : null;
              later = later === true;
              if (isString(expression)) {
                match = expression.match(CNTRL_REG);
                if (!match) {
                  throw $controllerMinErr(
                    "ctrlfmt",
                    "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.",
                    expression
                  );
                }
                constructor = match[1];
                identifier = identifier || match[3];
                expression = this.controllers.get(constructor);
                if (!expression) {
                  throw $controllerMinErr(
                    "ctrlreg",
                    "The controller with the name '{0}' is not registered.",
                    constructor
                  );
                }
                assertArgFn(expression, constructor, true);
              }
              if (later) {
                const controllerPrototype = (Array.isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                instance = Object.create(controllerPrototype || null);
                if (identifier) {
                  instance["$controllerIdentifier"] = identifier;
                  this.addIdentifier(
                    locals,
                    identifier,
                    instance,
                    constructor || expression.name
                  );
                }
                return (function() {
                  const result = $injector.invoke(
                    expression,
                    instance,
                    locals,
                    constructor
                  );
                  if (result !== instance && (isObject(result) || isFunction(result))) {
                    instance = result;
                    if (identifier) {
                      instance["$controllerIdentifier"] = identifier;
                      this.addIdentifier(
                        locals,
                        identifier,
                        instance,
                        constructor || expression.name
                      );
                    }
                  }
                  return instance;
                }).bind(this, { instance, identifier });
              }
              instance = $injector.instantiate(expression, locals, constructor);
              if (identifier) {
                this.addIdentifier(
                  locals,
                  identifier,
                  instance,
                  constructor || expression.name
                );
              }
              return instance;
            };
          }
        ];
        /**
         * Adds an identifier to the controller instance in the given locals' scope.
         *
         * @param {Object} locals The locals object containing the scope.
         * @param {string} identifier The identifier to assign.
         * @param {Object} instance The controller instance.
         * @param {string} name The name of the controller.
         */
        addIdentifier(locals, identifier, instance, name2) {
          if (!(locals && isObject(locals.$scope))) {
            throw minErr("$controller")(
              "noscp",
              "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.",
              name2,
              identifier
            );
          }
          locals.$scope[identifier] = instance;
        }
      }
      const originUrl = urlResolve(window.location.href);
      function urlResolve(url) {
        if (!isString(url))
          return (
            /** @type {import("./interface.js").ParsedUrl} */
            url
          );
        const urlParsingNode = new URL(
          /** @type {string} */
          url,
          window.location.href
        );
        const hostname = urlParsingNode.hostname.includes(":") ? `[${urlParsingNode.hostname}]` : urlParsingNode.hostname;
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol,
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : `/${urlParsingNode.pathname}`
        };
      }
      function urlIsSameOrigin(requestUrl) {
        return urlsAreSameOrigin(requestUrl, originUrl);
      }
      function urlIsSameOriginAsBaseUrl(requestUrl) {
        return urlsAreSameOrigin(requestUrl, document.baseURI);
      }
      function urlIsAllowedOriginFactory(trustedOriginUrls) {
        const parsedAllowedOriginUrls = [originUrl].concat(
          trustedOriginUrls.map(urlResolve)
        );
        return function urlIsAllowedOrigin(requestUrl) {
          const parsedUrl = urlResolve(requestUrl);
          return parsedAllowedOriginUrls.some(
            urlsAreSameOrigin.bind(null, parsedUrl)
          );
        };
      }
      function urlsAreSameOrigin(url1, url2) {
        url1 = urlResolve(url1);
        url2 = urlResolve(url2);
        return url1.protocol === url2.protocol && url1.host === url2.host;
      }
      function trimEmptyHash(url) {
        return url.replace(/#$/, "");
      }
      const $sceMinErr = minErr("$sce");
      const SCE_CONTEXTS = {
        // HTML is used when there's HTML rendered (e.g. ng-bind-html, iframe srcdoc binding).
        HTML: "html",
        // Style statements or stylesheets. Currently unused in AngularTS.
        CSS: "css",
        // An URL used in a context where it refers to the source of media, which are not expected to be run
        // as scripts, such as an image, audio, video, etc.
        MEDIA_URL: "mediaUrl",
        // An URL used in a context where it does not refer to a resource that loads code.
        // A value that can be trusted as a URL can also trusted as a MEDIA_URL.
        URL: "url",
        // RESOURCE_URL is a subtype of URL used where the referred-to resource could be interpreted as
        // code. (e.g. ng-include, script src binding, templateUrl)
        // A value that can be trusted as a RESOURCE_URL, can also trusted as a URL and a MEDIA_URL.
        RESOURCE_URL: "resourceUrl",
        // Script. Currently unused in AngularTS.
        JS: "js"
      };
      function escapeForRegexp(s) {
        return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1");
      }
      function adjustMatcher(matcher) {
        if (matcher === "self") {
          return matcher;
        }
        if (isString(matcher)) {
          if (matcher.indexOf("***") > -1) {
            throw $sceMinErr(
              "iwcard",
              "Illegal sequence *** in string matcher.  String: {0}",
              matcher
            );
          }
          matcher = escapeForRegexp(matcher).replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^:/.?&;]*");
          return new RegExp(`^${matcher}$`);
        }
        if (isRegExp(matcher)) {
          return new RegExp(`^${matcher.source}$`);
        }
        throw $sceMinErr(
          "imatcher",
          'Matchers may only be "self", string patterns or RegExp objects'
        );
      }
      class SceDelegateProvider {
        constructor() {
          let trustedResourceUrlList = ["self"];
          let bannedResourceUrlList = [];
          this.trustedResourceUrlList = function(value) {
            if (arguments.length) {
              trustedResourceUrlList = value.map((v) => adjustMatcher(v));
            }
            return trustedResourceUrlList;
          };
          this.bannedResourceUrlList = function(value) {
            if (arguments.length) {
              bannedResourceUrlList = value.map((v) => adjustMatcher(v));
            }
            return bannedResourceUrlList;
          };
          this.$get = [
            "$injector",
            "$$sanitizeUri",
            "$exceptionHandler",
            /**
             *
             * @param {import("../../core/di/internal-injector.js").InjectorService} $injector
             * @param {*} $$sanitizeUri
             * @param {ErrorHandler} $exceptionHandler
             * @returns
             */
            function($injector, $$sanitizeUri, $exceptionHandler2) {
              let htmlSanitizer = function() {
                $exceptionHandler2(
                  $sceMinErr(
                    "unsafe",
                    "Attempting to use an unsafe value in a safe context."
                  )
                );
              };
              if ($injector.has("$sanitize")) {
                htmlSanitizer = $injector.get("$sanitize");
              }
              function matchUrl(matcher, parsedUrl) {
                if (matcher === "self") {
                  return urlIsSameOrigin(parsedUrl) || urlIsSameOriginAsBaseUrl(parsedUrl);
                }
                return !!/** @type {RegExp} */
                matcher.exec(parsedUrl.href);
              }
              function isResourceUrlAllowedByPolicy(url) {
                const parsedUrl = urlResolve(url.toString());
                let i;
                let n;
                let allowed = false;
                for (i = 0, n = trustedResourceUrlList.length; i < n; i++) {
                  if (matchUrl(trustedResourceUrlList[i], parsedUrl)) {
                    allowed = true;
                    break;
                  }
                }
                if (allowed) {
                  for (i = 0, n = bannedResourceUrlList.length; i < n; i++) {
                    if (matchUrl(bannedResourceUrlList[i], parsedUrl)) {
                      allowed = false;
                      break;
                    }
                  }
                }
                return allowed;
              }
              function generateHolderType(Base) {
                const holderType = function TrustedValueHolderType(trustedValue) {
                  this.$$unwrapTrustedValue = function() {
                    return trustedValue;
                  };
                };
                if (Base) {
                  holderType.prototype = new Base();
                }
                holderType.prototype.valueOf = function sceValueOf() {
                  return this.$$unwrapTrustedValue();
                };
                holderType.prototype.toString = function sceToString() {
                  return this.$$unwrapTrustedValue().toString();
                };
                return holderType;
              }
              const trustedValueHolderBase = generateHolderType();
              const byType = {};
              byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
              byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
              byType[SCE_CONTEXTS.MEDIA_URL] = generateHolderType(
                trustedValueHolderBase
              );
              byType[SCE_CONTEXTS.URL] = generateHolderType(
                byType[SCE_CONTEXTS.MEDIA_URL]
              );
              byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
              byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(
                byType[SCE_CONTEXTS.URL]
              );
              function trustAs(type, trustedValue) {
                const Constructor = hasOwn(byType, type) ? byType[type] : null;
                if (!Constructor) {
                  $exceptionHandler2(
                    $sceMinErr(
                      "icontext",
                      "Attempted to trust a value in invalid context. Context: {0}; Value: {1}",
                      type,
                      trustedValue
                    )
                  );
                  return;
                }
                if (trustedValue === null || isUndefined(trustedValue) || trustedValue === "") {
                  return trustedValue;
                }
                if (typeof trustedValue !== "string") {
                  $exceptionHandler2(
                    $sceMinErr(
                      "itype",
                      "Attempted to trust a non-string value in a content requiring a string: Context: {0}",
                      type
                    )
                  );
                  return;
                }
                return new Constructor(trustedValue);
              }
              function valueOf(maybeTrusted) {
                if (maybeTrusted instanceof trustedValueHolderBase) {
                  return maybeTrusted.$$unwrapTrustedValue();
                }
                return maybeTrusted;
              }
              function getTrusted(type, maybeTrusted) {
                if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === "") {
                  return maybeTrusted;
                }
                const constructor = hasOwn(byType, type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) {
                  return maybeTrusted.$$unwrapTrustedValue();
                }
                if (isFunction(maybeTrusted.$$unwrapTrustedValue)) {
                  maybeTrusted = maybeTrusted.$$unwrapTrustedValue();
                }
                if (type === SCE_CONTEXTS.MEDIA_URL || type === SCE_CONTEXTS.URL) {
                  return $$sanitizeUri(
                    maybeTrusted.toString(),
                    type === SCE_CONTEXTS.MEDIA_URL
                  );
                }
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                  if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                    return maybeTrusted;
                  }
                  $exceptionHandler2(
                    $sceMinErr(
                      "insecurl",
                      "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}",
                      maybeTrusted.toString()
                    )
                  );
                  return;
                } else if (type === SCE_CONTEXTS.HTML) {
                  return htmlSanitizer();
                }
                $exceptionHandler2(
                  $sceMinErr(
                    "unsafe",
                    "Attempting to use an unsafe value in a safe context."
                  )
                );
              }
              return { trustAs, getTrusted, valueOf };
            }
          ];
        }
      }
      function SceProvider() {
        let enabled = true;
        this.enabled = function(value) {
          if (arguments.length) {
            enabled = !!value;
          }
          return enabled;
        };
        this.$get = [
          "$parse",
          "$sceDelegate",
          function($parse2, $sceDelegate) {
            const sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
              return enabled;
            };
            sce.trustAs = $sceDelegate.trustAs;
            sce.getTrusted = $sceDelegate.getTrusted;
            sce.valueOf = $sceDelegate.valueOf;
            if (!enabled) {
              sce.trustAs = sce.getTrusted = function(type, value) {
                return value;
              };
              sce.valueOf = function($) {
                return $;
              };
            }
            sce.parseAs = function sceParseAs(type, expr) {
              const parsed = $parse2(expr);
              if (parsed.literal && parsed.constant) {
                return parsed;
              }
              return $parse2(expr, (value) => sce.getTrusted(type, value));
            };
            const parse2 = sce.parseAs;
            const { getTrusted } = sce;
            const { trustAs } = sce;
            Object.entries(SCE_CONTEXTS).forEach(([name2, enumValue]) => {
              const lName = lowercase(name2);
              sce[snakeToCamel(`parse_as_${lName}`)] = function(expr) {
                return parse2(enumValue, expr);
              };
              sce[snakeToCamel(`get_trusted_${lName}`)] = function(value) {
                return getTrusted(enumValue, value);
              };
              sce[snakeToCamel(`trust_as_${lName}`)] = function(value) {
                return trustAs(enumValue, value);
              };
            });
            return sce;
          }
        ];
      }
      const ngEventDirectives = {};
      "click copy cut dblclick focus blur keydown keyup load mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup paste submit touchstart touchend touchmove".split(" ").forEach((eventName) => {
        const directiveName = directiveNormalize(`ng-${eventName}`);
        ngEventDirectives[directiveName] = [
          "$parse",
          "$exceptionHandler",
          /**
           * @param {import("../../core/parse/interface.ts").ParseService} $parse
           * @param {import('../../services/exception/exception-handler.js').ErrorHandler} $exceptionHandler
           * @returns
           */
          ($parse2, $exceptionHandler2) => {
            return createEventDirective(
              $parse2,
              $exceptionHandler2,
              directiveName,
              eventName
            );
          }
        ];
      });
      function createEventDirective($parse2, $exceptionHandler2, directiveName, eventName) {
        return {
          restrict: "A",
          compile(_element, attr) {
            const fn = $parse2(attr[directiveName]);
            return function ngEventHandler(scope, element) {
              element.addEventListener(eventName, (event) => {
                try {
                  fn(scope, { $event: event });
                } catch (error) {
                  $exceptionHandler2(error);
                }
              });
            };
          }
        };
      }
      const $compileMinErr$1 = minErr("$compile");
      const SIMPLE_ATTR_NAME = /^\w/;
      const specialAttrHolder = document.createElement("div");
      class Attributes {
        static $nonscope = true;
        /**
         * @param {import('../scope/scope.js').Scope} $rootScope
         * @param {*} $animate
         * @param {import("../../services/exception/exception-handler.js").ErrorHandler} $exceptionHandler
         * @param {*} $sce
         * @param {import("../../shared/noderef.js").NodeRef} [nodeRef]
         * @param {Object} [attributesToCopy]
         */
        constructor($rootScope, $animate, $exceptionHandler2, $sce, nodeRef, attributesToCopy) {
          this.$rootScope = $rootScope;
          this.$animate = $animate;
          this.$exceptionHandler = $exceptionHandler2;
          this.$sce = $sce;
          if (attributesToCopy) {
            const keys = Object.keys(attributesToCopy);
            for (let i = 0, l = keys.length; i < l; i++) {
              const key = keys[i];
              this[key] = attributesToCopy[key];
            }
          } else {
            this.$attr = {};
          }
          this.$nodeRef = nodeRef;
        }
        /** @type {Node|Element} */
        get $$element() {
          return this.$nodeRef.node;
        }
        /**
         * Converts an attribute name (e.g. dash/colon/underscore-delimited string, optionally prefixed with `x-` or
         * `data-`) to its normalized, camelCase form.
         *
         * Also there is special case for Moz prefix starting with upper case letter.
         *
         * For further information check out the guide on {@link guide/directive#matching-directives Matching Directives}
         *
         * @param {string} name Name to normalize
         */
        $normalize = directiveNormalize;
        /**
         * Adds the CSS class value specified by the classVal parameter to the element. If animations
         * are enabled then an animation will be triggered for the class addition.
         *
         * @param {string} classVal The className value that will be added to the element
         */
        $addClass(classVal) {
          if (classVal && classVal.length > 0) {
            if (hasAnimate(this.$$element)) {
              this.$animate.addClass(this.$$element, classVal);
            } else {
              this.$nodeRef.element.classList.add(classVal);
            }
          }
        }
        /**
         * Removes the CSS class value specified by the classVal parameter from the element. If
         * animations are enabled then an animation will be triggered for the class removal.
         *
         * @param {string} classVal The className value that will be removed from the element
         */
        $removeClass(classVal) {
          if (classVal && classVal.length > 0) {
            if (hasAnimate(this.$$element)) {
              this.$animate.removeClass(this.$$element, classVal);
            } else {
              this.$nodeRef.element.classList.remove(classVal);
            }
          }
        }
        /**
         * Adds and removes the appropriate CSS class values to the element based on the difference
         * between the new and old CSS class values (specified as newClasses and oldClasses).
         *
         * @param {string} newClasses The current CSS className value
         * @param {string} oldClasses The former CSS className value
         */
        $updateClass(newClasses, oldClasses) {
          const toAdd = tokenDifference(newClasses, oldClasses);
          if (toAdd && toAdd.length) {
            if (hasAnimate(this.$$element)) {
              this.$animate.addClass(this.$$element, toAdd);
            } else {
              this.$nodeRef.element.classList.add(...toAdd.trim().split(/\s+/));
            }
          }
          const toRemove = tokenDifference(oldClasses, newClasses);
          if (toRemove && toRemove.length) {
            if (hasAnimate(this.$$element)) {
              this.$animate.removeClass(this.$$element, toRemove);
            } else {
              this.$nodeRef.element.classList.remove(...toRemove.trim().split(/\s+/));
            }
          }
        }
        /**
         * Set a normalized attribute on the element in a way such that all directives
         * can share the attribute. This function properly handles boolean attributes.
         * @param {string} key Normalized key. (ie ngAttribute)
         * @param {string|boolean} value The value to set. If `null` attribute will be deleted.
         * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.
         *     Defaults to true.
         * @param {string=} attrName Optional none normalized name. Defaults to key.
         */
        $set(key, value, writeAttr, attrName) {
          const node = this.$$element;
          const booleanKey = getBooleanAttrName(
            /** @type {Element}   */
            node,
            key
          );
          const aliasedKey = ALIASED_ATTR[key];
          let observer = key;
          if (booleanKey) {
            this.$$element[key] = value;
            attrName = booleanKey;
          } else if (aliasedKey) {
            this[aliasedKey] = value;
            observer = aliasedKey;
          }
          this[key] = value;
          if (attrName) {
            this.$attr[key] = attrName;
          } else {
            attrName = this.$attr[key];
            if (!attrName) {
              this.$attr[key] = attrName = snakeCase(key, "-");
            }
          }
          let nodeName = this.$nodeRef.node.nodeName.toLowerCase();
          if (nodeName === "img" && key === "srcset") {
            this[key] = value = this.sanitizeSrcset(value, "$set('srcset', value)");
          }
          if (writeAttr !== false) {
            let elem = isProxy(this.$$element) ? this.$$element["$target"] : this.$$element;
            if (value === null || isUndefined(value)) {
              elem.removeAttribute(attrName);
            } else if (SIMPLE_ATTR_NAME.test(attrName)) {
              if (booleanKey && value === false) {
                elem.removeAttribute(attrName);
              } else {
                if (booleanKey) {
                  elem.toggleAttribute(attrName, value);
                } else {
                  elem.setAttribute(attrName, value);
                }
              }
            } else {
              this.setSpecialAttr(this.$$element, attrName, value);
            }
          }
          const { $$observers } = this;
          if ($$observers && $$observers[observer]) {
            $$observers[observer].forEach((fn) => {
              try {
                fn(value);
              } catch (e) {
                this.$exceptionHandler(e);
              }
            });
          }
        }
        /**
         * Observes an interpolated attribute.
         * 
         * The observer function will be invoked once during the next `$digest` following
         * compilation. The observer is then invoked whenever the interpolated value
         * changes.
         *
         * @param {string} key Normalized key. (ie ngAttribute) .
         * @param {any} fn Function that will be called whenever
                  the interpolated value of the attribute changes.
        *        See the {@link guide/interpolation#how-text-and-attribute-bindings-work Interpolation
        *        guide} for more info.
        * @returns {function()} Returns a deregistration function for this observer.
        */
        $observe(key, fn) {
          const $$observers = this.$$observers || (this.$$observers = /* @__PURE__ */ Object.create(null));
          const listeners = $$observers[key] || ($$observers[key] = []);
          listeners.push(fn);
          if (!listeners.$$inter && hasOwn(this, key) && !isUndefined(this[key])) {
            fn(this[key]);
          }
          return function() {
            arrayRemove(listeners, fn);
          };
        }
        setSpecialAttr(element, attrName, value) {
          specialAttrHolder.innerHTML = `<span ${attrName}>`;
          const { attributes } = (
            /** @type {Element} */
            specialAttrHolder.firstChild
          );
          const attribute = attributes[0];
          attributes.removeNamedItem(attribute.name);
          attribute.value = value;
          element.attributes.setNamedItem(attribute);
        }
        sanitizeSrcset(value, invokeType) {
          let i;
          if (!value) {
            return value;
          }
          if (!isString(value)) {
            throw $compileMinErr$1(
              "srcset",
              'Can\'t pass trusted values to `{0}`: "{1}"',
              invokeType,
              value.toString()
            );
          }
          let result = "";
          const trimmedSrcset = trim(value);
          const srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
          const pattern2 = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
          const rawUris = trimmedSrcset.split(pattern2);
          const nbrUrisWith2parts = Math.floor(rawUris.length / 2);
          for (i = 0; i < nbrUrisWith2parts; i++) {
            const innerIdx = i * 2;
            result += this.$sce.getTrustedMediaUrl(trim(rawUris[innerIdx]));
            result += " " + trim(rawUris[innerIdx + 1]);
          }
          const lastTuple = trim(rawUris[i * 2]).split(/\s/);
          result += this.$sce.getTrustedMediaUrl(trim(lastTuple[0]));
          if (lastTuple.length === 2) {
            result += " " + trim(lastTuple[1]);
          }
          return result;
        }
      }
      function tokenDifference(str1, str2) {
        const tokens1 = new Set(str1.split(/\s+/));
        const tokens2 = new Set(str2.split(/\s+/));
        const difference = Array.from(tokens1).filter((token) => !tokens2.has(token));
        return difference.join(" ");
      }
      function ngObserveDirective(source, prop) {
        return {
          restrict: "A",
          compile: () => (scope, element) => {
            const targetElement = element;
            if (prop === "") {
              prop = source;
            }
            const normalized = kebabToCamel(prop);
            if (!scope[normalized]) {
              scope[normalized] = targetElement.getAttribute(source);
            }
            const observer = new MutationObserver((mutations) => {
              const mutation = mutations[0];
              const newValue = (
                /** @type {HTMLElement} */
                mutation.target.getAttribute(source)
              );
              if (scope[normalized] !== newValue) {
                scope[normalized] = newValue;
              }
            });
            observer.observe(targetElement, {
              attributes: true,
              attributeFilter: [source]
            });
            scope.$on("$destroy", () => {
              observer.disconnect();
            });
          }
        };
      }
      const $compileMinErr = minErr("$compile");
      const EXCLUDED_DIRECTIVES = ["ngIf", "ngRepeat"];
      const ALL_OR_NOTHING_ATTRS = ["ngSrc", "ngSrcset", "src", "srcset"];
      const REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
      const EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
      const DirectiveSuffix = "Directive";
      class CompileProvider {
        /* @ignore */
        static $inject = ["$provide", "$$sanitizeUriProvider"];
        /**
         * @param {import('../../interface.js').Provider} $provide
         * @param {import('../sanitize/sanitize-uri.js').SanitizeUriProvider} $$sanitizeUriProvider
         */
        constructor($provide, $$sanitizeUriProvider) {
          const hasDirectives = {};
          const bindingCache = /* @__PURE__ */ Object.create(null);
          function parseIsolateBindings(scope, directiveName, isController) {
            const LOCAL_REGEXP = /^([@&]|[=<]())(\??)\s*([\w$]*)$/;
            const bindings = /* @__PURE__ */ Object.create(null);
            Object.entries(scope).forEach(([scopeName, definition]) => {
              definition = definition.trim();
              if (definition in bindingCache) {
                bindings[scopeName] = bindingCache[definition];
                return;
              }
              const match = definition.match(LOCAL_REGEXP);
              if (!match) {
                throw $compileMinErr(
                  "iscp",
                  "Invalid {3} for directive '{0}'. Definition: {... {1}: '{2}' ...}",
                  directiveName,
                  scopeName,
                  definition,
                  isController ? "controller bindings definition" : "isolate scope definition"
                );
              }
              bindings[scopeName] = {
                mode: match[1][0],
                collection: match[2] === "*",
                optional: match[3] === "?",
                attrName: match[4] || scopeName
              };
              if (match[4]) {
                bindingCache[definition] = bindings[scopeName];
              }
            });
            return bindings;
          }
          function parseDirectiveBindings(directive, directiveName) {
            const bindings = {
              isolateScope: null,
              bindToController: null
            };
            if (isObject(directive.scope)) {
              if (directive.bindToController === true) {
                bindings.bindToController = parseIsolateBindings(
                  directive.scope,
                  directiveName,
                  true
                );
                bindings.isolateScope = {};
              } else {
                bindings.isolateScope = parseIsolateBindings(
                  directive.scope,
                  directiveName,
                  false
                );
              }
            }
            if (isObject(directive.bindToController)) {
              bindings.bindToController = parseIsolateBindings(
                directive.bindToController,
                directiveName,
                true
              );
            }
            if (bindings.bindToController && !directive.controller) {
              throw $compileMinErr(
                "noctrl",
                "Cannot bind to controller without directive '{0}'s controller.",
                directiveName
              );
            }
            return bindings;
          }
          function getDirectiveRequire(directive) {
            const require2 = directive.require || directive.controller && directive.name;
            if (!Array.isArray(require2) && isObject(require2)) {
              Object.entries(require2).forEach(([key, value]) => {
                const match = value.match(REQUIRE_PREFIX_REGEXP);
                const name2 = value.substring(match[0].length);
                if (!name2) {
                  require2[key] = match[0] + key;
                }
              });
            }
            return require2;
          }
          function getDirectiveRestrict(restrict, name2) {
            if (restrict && !(isString(restrict) && /[EA]/.test(restrict))) {
              throw $compileMinErr(
                "badrestrict",
                "Restrict property '{0}' of directive '{1}' is invalid",
                restrict,
                name2
              );
            }
            return restrict || "EA";
          }
          this.directive = function registerDirective(name2, directiveFactory) {
            assertArg$1(name2, "name");
            assertNotHasOwnProperty(name2, "directive");
            if (isString(name2)) {
              assertValidDirectiveName(name2);
              assertArg$1(directiveFactory, "directiveFactory");
              if (!hasOwn(hasDirectives, name2)) {
                hasDirectives[name2] = [];
                $provide.factory(name2 + DirectiveSuffix, [
                  "$injector",
                  "$exceptionHandler",
                  /**
                   * @param {import("../../core/di/internal-injector.js").InjectorService} $injector
                   * @param {import('../../services/exception/exception-handler.js').ErrorHandler} $exceptionHandler
                   */
                  function($injector, $exceptionHandler2) {
                    const directives = [];
                    hasDirectives[name2].forEach((directiveFactory2, index) => {
                      try {
                        let directive = $injector.invoke(directiveFactory2);
                        const valueFn = (value) => () => value;
                        if (isFunction(directive)) {
                          directive = { compile: valueFn(directive) };
                        } else if (!directive.compile && directive.link) {
                          directive.compile = valueFn(directive.link);
                        }
                        directive.priority = directive.priority || 0;
                        directive.index = index;
                        directive.name = directive.name || name2;
                        directive.require = getDirectiveRequire(directive);
                        directive.restrict = getDirectiveRestrict(
                          directive.restrict,
                          name2
                        );
                        directive.$$moduleName = directiveFactory2.$$moduleName;
                        directives.push(directive);
                      } catch (e) {
                        $exceptionHandler2(e);
                      }
                    });
                    return directives;
                  }
                ]);
              }
              hasDirectives[name2].push(directiveFactory);
            } else {
              Object.entries(name2).forEach(([k, v]) => registerDirective(k, v));
            }
            return this;
          };
          this.component = function(name2, options) {
            if (!isString(name2)) {
              Object.entries(name2).forEach(([key, val2]) => this.component(key, val2));
              return this;
            }
            const controller = options.controller || function() {
            };
            function factory($injector) {
              function makeInjectable(fn) {
                if (isFunction(fn) || Array.isArray(fn)) {
                  return function(tElement, tAttrs) {
                    return $injector.invoke(fn, this, {
                      $element: tElement,
                      $attrs: tAttrs
                    });
                  };
                }
                return fn;
              }
              const template = !options.template && !options.templateUrl ? "" : options.template;
              const ddo = {
                controller,
                controllerAs: identifierForController(options.controller) || options.controllerAs || "$ctrl",
                template: makeInjectable(template),
                templateUrl: makeInjectable(options.templateUrl),
                transclude: options.transclude,
                scope: {},
                bindToController: options.bindings || {},
                restrict: "E",
                require: options.require
              };
              Object.entries(options).forEach(([key, val2]) => {
                if (key.charAt(0) === "$") {
                  ddo[key] = val2;
                }
              });
              return ddo;
            }
            Object.entries(options).forEach(([key, val2]) => {
              if (key.charAt(0) === "$") {
                factory[key] = val2;
                if (isFunction(controller)) {
                  controller[key] = val2;
                }
              }
            });
            factory.$inject = ["$injector"];
            return this.directive(name2, factory);
          };
          this.aHrefSanitizationTrustedUrlList = function(regexp) {
            if (isDefined(regexp)) {
              $$sanitizeUriProvider.aHrefSanitizationTrustedUrlList(regexp);
              return;
            }
            return $$sanitizeUriProvider.aHrefSanitizationTrustedUrlList();
          };
          this.imgSrcSanitizationTrustedUrlList = function(regexp) {
            if (isDefined(regexp)) {
              $$sanitizeUriProvider.imgSrcSanitizationTrustedUrlList(regexp);
              return;
            }
            return $$sanitizeUriProvider.imgSrcSanitizationTrustedUrlList();
          };
          let strictComponentBindingsEnabled = false;
          this.strictComponentBindingsEnabled = function(enabled) {
            if (isDefined(enabled)) {
              strictComponentBindingsEnabled = enabled;
              return this;
            }
            return strictComponentBindingsEnabled;
          };
          const PROP_CONTEXTS = /* @__PURE__ */ Object.create(null);
          this.addPropertySecurityContext = function(elementName, propertyName, ctx) {
            const key = `${elementName.toLowerCase()}|${propertyName.toLowerCase()}`;
            if (key in PROP_CONTEXTS && PROP_CONTEXTS[key] !== ctx) {
              throw $compileMinErr(
                "ctxoverride",
                "Property context '{0}.{1}' already set to '{2}', cannot override to '{3}'.",
                elementName,
                propertyName,
                PROP_CONTEXTS[key],
                ctx
              );
            }
            PROP_CONTEXTS[key] = ctx;
            return this;
          };
          (function registerNativePropertyContexts() {
            function registerContext(ctx, values) {
              values.forEach((v) => {
                PROP_CONTEXTS[v.toLowerCase()] = ctx;
              });
            }
            registerContext(SCE_CONTEXTS.HTML, [
              "iframe|srcdoc",
              "*|innerHTML",
              "*|outerHTML"
            ]);
            registerContext(SCE_CONTEXTS.CSS, ["*|style"]);
            registerContext(SCE_CONTEXTS.URL, [
              "area|href",
              "area|ping",
              "a|href",
              "a|ping",
              "blockquote|cite",
              "body|background",
              "del|cite",
              "input|src",
              "ins|cite",
              "q|cite"
            ]);
            registerContext(SCE_CONTEXTS.MEDIA_URL, [
              "audio|src",
              "img|src",
              "img|srcset",
              "source|src",
              "source|srcset",
              "track|src",
              "video|src",
              "video|poster"
            ]);
            registerContext(SCE_CONTEXTS.RESOURCE_URL, [
              "*|formAction",
              "applet|code",
              "applet|codebase",
              "base|href",
              "embed|src",
              "frame|src",
              "form|action",
              "head|profile",
              "html|manifest",
              "iframe|src",
              "link|href",
              "media|src",
              "object|codebase",
              "object|data",
              "script|src"
            ]);
          })();
          this.$get = [
            "$injector",
            "$interpolate",
            "$exceptionHandler",
            "$templateRequest",
            "$parse",
            "$controller",
            "$rootScope",
            "$sce",
            "$animate",
            /**
             * @param {import("../../core/di/internal-injector.js").InjectorService} $injector
             * @param {*} $interpolate
             * @param {import("../../services/exception/exception-handler.js").ErrorHandler} $exceptionHandler
             * @param {*} $templateRequest
             * @param {import("../parse/interface.ts").ParseService} $parse
             * @param {*} $controller
             * @param {import('../scope/scope.js').Scope} $rootScope
             * @param {*} $sce
             * @param {*} $animate
             * @returns
             */
            function($injector, $interpolate, $exceptionHandler2, $templateRequest, $parse2, $controller, $rootScope, $sce, $animate) {
              let onChangesQueue;
              function flushOnChangesQueue() {
                for (let i = 0, ii = onChangesQueue.length; i < ii; ++i) {
                  try {
                    onChangesQueue[i]();
                  } catch (e) {
                    $exceptionHandler2(e);
                  }
                }
                onChangesQueue = void 0;
              }
              const startSymbol = $interpolate.startSymbol();
              const endSymbol = $interpolate.endSymbol();
              const denormalizeTemplate = startSymbol === "{{" && endSymbol === "}}" ? (x) => x : (x) => x.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              const NG_PREFIX_BINDING = /^ng(Attr|Prop|On|Observe)([A-Z].*)$/;
              return compile;
              function compile(element, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                let nodeRef = new NodeRef(element);
                let compositeLinkFn = compileNodes(
                  nodeRef,
                  transcludeFn,
                  maxPriority,
                  ignoreDirective,
                  previousCompileContext
                );
                let namespace = null;
                return publicLinkFn;
                function publicLinkFn(scope, cloneConnectFn, options) {
                  if (!nodeRef) {
                    throw $compileMinErr(
                      "multilink",
                      "This element has already been linked."
                    );
                  }
                  assertArg$1(scope, "scope");
                  if (nodeRef.getAny()) {
                    setScope(nodeRef.getAny(), scope);
                  }
                  if (previousCompileContext && previousCompileContext.needsNewScope) {
                    scope = scope.$parent.$new();
                  }
                  options = options || {};
                  let {
                    transcludeControllers,
                    parentBoundTranscludeFn,
                    futureParentElement
                  } = options;
                  if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                    parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
                  }
                  if (!namespace) {
                    namespace = detectNamespaceForChildElements(futureParentElement);
                  }
                  let $linkNode;
                  if (namespace !== "html") {
                    const fragment = createElementFromHTML("<div></div>");
                    fragment.append(nodeRef.node);
                    const wrappedTemplate = wrapTemplate(
                      namespace,
                      fragment.innerHTML
                    );
                    $linkNode = new NodeRef(wrappedTemplate[0]);
                  } else if (cloneConnectFn) {
                    $linkNode = nodeRef.clone();
                  } else {
                    $linkNode = nodeRef;
                  }
                  if (transcludeControllers) {
                    for (const controllerName in transcludeControllers) {
                      assertArg$1($linkNode.element, "element");
                      setCacheData(
                        $linkNode.element,
                        `$${controllerName}Controller`,
                        transcludeControllers[controllerName].instance
                      );
                    }
                  }
                  if (cloneConnectFn) {
                    cloneConnectFn($linkNode.dom, scope);
                  }
                  if (compositeLinkFn) {
                    compositeLinkFn(scope, $linkNode, parentBoundTranscludeFn);
                  }
                  if (!cloneConnectFn) {
                    nodeRef = compositeLinkFn = null;
                  }
                  $linkNode.linked = true;
                  return $linkNode.getAll();
                }
              }
              function detectNamespaceForChildElements(parentElement) {
                const node = parentElement;
                if (!node) {
                  return "html";
                }
                return getNodeName(node) !== "foreignobject" && toString.call(node).match(/SVG/) ? "svg" : "html";
              }
              function compileNodes(nodeRefList, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                const linkFnsList = [];
                let nodeLinkFnFound;
                let linkFnFound = false;
                for (let i = 0; i < nodeRefList.size; i++) {
                  const attrs = new Attributes(
                    $rootScope,
                    $animate,
                    $exceptionHandler2,
                    $sce
                  );
                  const directives = collectDirectives(
                    /** @type Element */
                    nodeRefList.getIndex(i),
                    attrs,
                    i === 0 ? maxPriority : void 0,
                    ignoreDirective
                  );
                  let nodeLinkFnCtx;
                  if (directives.length) {
                    nodeLinkFnCtx = applyDirectivesToNode(
                      directives,
                      nodeRefList.getIndex(i),
                      attrs,
                      transcludeFn,
                      null,
                      [],
                      [],
                      Object.assign({}, previousCompileContext, {
                        index: i,
                        parentNodeRef: nodeRefList,
                        ctxNodeRef: nodeRefList
                      })
                    );
                  }
                  let childLinkFn;
                  let childNodes;
                  let nodeLinkFn = nodeLinkFnCtx?.nodeLinkFn;
                  if (nodeLinkFn && nodeLinkFnCtx.terminal || !(childNodes = nodeRefList.getIndex(i).childNodes) || !childNodes.length) {
                    childLinkFn = null;
                  } else {
                    let transcluded = nodeLinkFn ? (nodeLinkFnCtx.transcludeOnThisElement || !nodeLinkFnCtx.templateOnThisElement) && nodeLinkFnCtx.transclude : transcludeFn;
                    const childNodeRef = new NodeRef(childNodes);
                    childLinkFn = compileNodes(childNodeRef, transcluded);
                  }
                  if (nodeLinkFn || childLinkFn) {
                    linkFnsList.push({
                      index: i,
                      nodeLinkFnCtx,
                      childLinkFn
                    });
                    linkFnFound = true;
                    nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
                  }
                  previousCompileContext = null;
                }
                return linkFnFound ? compositeLinkFn : null;
                function compositeLinkFn(scope, nodeRef, parentBoundTranscludeFn) {
                  assertArg$1(nodeRef, "nodeRef");
                  let stableNodeList = [];
                  if (nodeLinkFnFound) {
                    const stableLength = nodeRef.isList ? nodeRef.nodes.length : 1;
                    stableNodeList = new Array(stableLength);
                    linkFnsList.forEach((val2) => {
                      let idx = val2.index;
                      if (idx === 0) {
                        stableNodeList[idx] = nodeRef.isList ? nodeRef.nodes[idx] : nodeRef.node;
                      } else {
                        if (nodeRefList.getIndex(idx)) {
                          stableNodeList[idx] = nodeRef.nodes[idx];
                        }
                      }
                    });
                  } else {
                    if (nodeRef.isList) {
                      nodeRef.nodes.forEach((elem) => stableNodeList.push(elem));
                    } else {
                      stableNodeList.push(nodeRef.node);
                    }
                  }
                  linkFnsList.forEach(({ index, nodeLinkFnCtx, childLinkFn }) => {
                    const node = stableNodeList[index];
                    node.stable = true;
                    let childScope;
                    let childBoundTranscludeFn;
                    if (nodeLinkFnCtx?.nodeLinkFn) {
                      childScope = nodeLinkFnCtx.newScope ? scope.$new() : scope;
                      if (nodeLinkFnCtx.transcludeOnThisElement) {
                        childBoundTranscludeFn = createBoundTranscludeFn(
                          scope,
                          nodeLinkFnCtx.transclude,
                          parentBoundTranscludeFn
                        );
                      } else if (!nodeLinkFnCtx.templateOnThisElement && parentBoundTranscludeFn) {
                        childBoundTranscludeFn = parentBoundTranscludeFn;
                      } else if (!parentBoundTranscludeFn && transcludeFn) {
                        childBoundTranscludeFn = createBoundTranscludeFn(
                          scope,
                          transcludeFn
                        );
                      } else {
                        childBoundTranscludeFn = null;
                      }
                      if (nodeLinkFnCtx?.newScope) {
                        setScope(node, childScope);
                      }
                      nodeLinkFnCtx.nodeLinkFn(
                        // @ts-ignore
                        childLinkFn,
                        childScope,
                        node,
                        childBoundTranscludeFn
                      );
                    } else if (childLinkFn) {
                      childLinkFn(
                        scope,
                        new NodeRef(node.childNodes),
                        parentBoundTranscludeFn
                      );
                    }
                  });
                }
              }
              function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                  if (!transcludedScope) {
                    transcludedScope = scope.$transcluded(containingScope);
                    transcludedScope.$$transcluded = true;
                  }
                  const transcludeRes = transcludeFn(transcludedScope, cloneFn, {
                    parentBoundTranscludeFn: previousBoundTranscludeFn,
                    transcludeControllers: controllers,
                    futureParentElement
                  });
                  return transcludeRes;
                }
                const boundSlots = boundTranscludeFn.$$slots = /* @__PURE__ */ Object.create(null);
                for (const slotName in transcludeFn.$$slots) {
                  if (transcludeFn.$$slots[slotName]) {
                    boundSlots[slotName] = createBoundTranscludeFn(
                      scope,
                      transcludeFn.$$slots[slotName],
                      previousBoundTranscludeFn
                    );
                  } else {
                    boundSlots[slotName] = null;
                  }
                }
                return boundTranscludeFn;
              }
              function collectDirectives(node, attrs, maxPriority, ignoreDirective) {
                const directives = [];
                const { nodeType } = node;
                const attrsMap = attrs.$attr;
                let nodeName;
                switch (nodeType) {
                  case Node.ELEMENT_NODE:
                    nodeName = node.nodeName.toLowerCase();
                    if (ignoreDirective !== directiveNormalize(nodeName)) {
                      addDirective(
                        directives,
                        directiveNormalize(nodeName),
                        "E",
                        maxPriority
                      );
                    }
                    for (let j = 0; j < node.attributes?.length; j++) {
                      let isNgAttr = false;
                      let isNgProp = false;
                      let isNgEvent = false;
                      let isNgObserve = false;
                      let attr = node.attributes[j];
                      let name2 = attr.name;
                      let value = attr.value;
                      let nName = directiveNormalize(name2.toLowerCase());
                      const ngPrefixMatch = nName.match(NG_PREFIX_BINDING);
                      if (ngPrefixMatch) {
                        isNgAttr = ngPrefixMatch[1] === "Attr";
                        isNgProp = ngPrefixMatch[1] === "Prop";
                        isNgEvent = ngPrefixMatch[1] === "On";
                        isNgObserve = ngPrefixMatch[1] === "Observe";
                        name2 = name2.replace(PREFIX_REGEXP, "").toLowerCase().substring(4 + ngPrefixMatch[1].length).replace(/_(.)/g, (match, letter) => letter.toUpperCase());
                      }
                      if (isNgProp || isNgEvent) {
                        attrs[nName] = value;
                        attrsMap[nName] = attr.name;
                        if (isNgProp) {
                          addPropertyDirective(node, directives, nName, name2);
                        } else {
                          directives.push(
                            createEventDirective(
                              $parse2,
                              $exceptionHandler2,
                              nName,
                              name2
                            )
                          );
                        }
                      } else if (isNgObserve) {
                        directives.push(ngObserveDirective(name2, value));
                      } else {
                        nName = directiveNormalize(name2.toLowerCase());
                        attrsMap[nName] = name2;
                        if (isNgAttr || !hasOwn(attrs, nName)) {
                          attrs[nName] = value;
                          if (getBooleanAttrName(node, nName)) {
                            attrs[nName] = true;
                          }
                        }
                        addAttrInterpolateDirective(
                          node,
                          directives,
                          value,
                          nName,
                          isNgAttr
                        );
                        if (nName !== ignoreDirective) {
                          addDirective(directives, nName, "A", maxPriority);
                        }
                      }
                    }
                    if (nodeName === "input" && node.getAttribute("type") === "hidden") {
                      node.setAttribute("autocomplete", "off");
                    }
                    break;
                  case Node.TEXT_NODE:
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;
                }
                directives.sort(byPriority);
                return directives;
              }
              function compilationGenerator(eager, compileNodes2, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                let compiled;
                if (eager) {
                  return compile(
                    compileNodes2,
                    transcludeFn,
                    maxPriority,
                    ignoreDirective,
                    previousCompileContext
                  );
                }
                return function lazyCompilation() {
                  if (!compiled) {
                    compiled = compile(
                      compileNodes2,
                      transcludeFn,
                      maxPriority,
                      ignoreDirective,
                      previousCompileContext
                    );
                    compileNodes2 = transcludeFn = previousCompileContext = null;
                  }
                  return compiled.apply(this, arguments);
                };
              }
              function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                previousCompileContext = previousCompileContext || {};
                let terminalPriority = -Number.MAX_VALUE;
                let terminal = false;
                let {
                  newScopeDirective,
                  controllerDirectives,
                  newIsolateScopeDirective,
                  templateDirective,
                  nonTlbTranscludeDirective,
                  hasElementTranscludeDirective,
                  ctxNodeRef,
                  parentNodeRef
                } = previousCompileContext;
                let hasTranscludeDirective = false;
                let hasTemplate = false;
                let compileNodeRef = new NodeRef(compileNode);
                const index = previousCompileContext.index;
                templateAttrs.$nodeRef = compileNodeRef;
                let directive;
                let directiveName;
                let $template;
                let replaceDirective = originalReplaceDirective;
                let childTranscludeFn = transcludeFn;
                let didScanForMultipleTransclusion = false;
                let mightHaveMultipleTransclusionError = false;
                let directiveValue;
                let nodeLinkFn = function(childLinkFn, scope, linkNode, boundTranscludeFn) {
                  let i;
                  let ii;
                  let isolateScope;
                  let controllerScope;
                  let elementControllers;
                  let transcludeFn2;
                  let scopeToChild = scope;
                  let $element;
                  let attrs;
                  let scopeBindingInfo;
                  if (compileNode === linkNode) {
                    attrs = templateAttrs;
                    $element = templateAttrs.$nodeRef;
                  } else {
                    $element = new NodeRef(linkNode);
                    attrs = new Attributes(
                      $rootScope,
                      $animate,
                      $exceptionHandler2,
                      $sce,
                      $element,
                      templateAttrs
                    );
                  }
                  controllerScope = scope;
                  if (newIsolateScopeDirective) {
                    isolateScope = scope.$newIsolate();
                  } else if (newScopeDirective) {
                    controllerScope = scope.$parent;
                  }
                  if (boundTranscludeFn) {
                    transcludeFn2 = controllersBoundTransclude;
                    transcludeFn2["$$boundTransclude"] = boundTranscludeFn;
                    transcludeFn2["isSlotFilled"] = function(slotName) {
                      return !!boundTranscludeFn.$$slots[slotName];
                    };
                  }
                  if (controllerDirectives) {
                    elementControllers = setupControllers(
                      $element,
                      attrs,
                      transcludeFn2,
                      controllerDirectives,
                      isolateScope,
                      scope,
                      newIsolateScopeDirective
                    );
                  }
                  if (newIsolateScopeDirective) {
                    isolateScope.$target.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                    scopeBindingInfo = initializeDirectiveBindings(
                      scope,
                      attrs,
                      isolateScope,
                      isolateScope.$$isolateBindings,
                      newIsolateScopeDirective
                    );
                    if (scopeBindingInfo.removeWatches) {
                      isolateScope.$on("$destroy", scopeBindingInfo.removeWatches);
                    }
                  }
                  for (const name2 in elementControllers) {
                    const controllerDirective = controllerDirectives[name2];
                    const controller = elementControllers[name2];
                    const bindings = controllerDirective.$$bindings.bindToController;
                    const controllerInstance = controller();
                    controller.instance = controllerScope.$new(controllerInstance);
                    setCacheData(
                      $element.node,
                      `$${controllerDirective.name}Controller`,
                      controller.instance
                    );
                    controller.bindingInfo = initializeDirectiveBindings(
                      controllerScope,
                      attrs,
                      controller.instance,
                      bindings,
                      controllerDirective
                    );
                  }
                  if (controllerDirectives) {
                    Object.entries(controllerDirectives).forEach(
                      ([name2, controllerDirective]) => {
                        const { require: require2 } = controllerDirective;
                        if (controllerDirective.bindToController && !Array.isArray(require2) && isObject(require2)) {
                          extend(
                            elementControllers[name2].instance,
                            getControllers(
                              name2,
                              require2,
                              $element.element,
                              elementControllers
                            )
                          );
                        }
                      }
                    );
                  }
                  if (elementControllers) {
                    Object.values(elementControllers).forEach((controller) => {
                      const controllerInstance = controller.instance;
                      if (isFunction(controllerInstance.$onChanges)) {
                        try {
                          controllerInstance.$onChanges(
                            controller.bindingInfo.initialChanges
                          );
                        } catch (e) {
                          $exceptionHandler2(e);
                        }
                      }
                      if (isFunction(controllerInstance.$onInit)) {
                        try {
                          controllerInstance.$target.$onInit();
                        } catch (e) {
                          $exceptionHandler2(e);
                        }
                      }
                      if (isFunction(controllerInstance.$onDestroy)) {
                        controllerScope.$on("$destroy", () => {
                          controllerInstance.$onDestroy();
                        });
                      }
                    });
                  }
                  for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                    let preLinkFn = preLinkFns[i];
                    const controllers = preLinkFn["require"] && getControllers(
                      preLinkFn["directiveName"],
                      preLinkFn["require"],
                      $element.element,
                      elementControllers
                    );
                    try {
                      preLinkFn(
                        preLinkFn["isolateScope"] ? isolateScope : scope,
                        $element.node,
                        // Prelink functions accept a Node
                        attrs,
                        controllers,
                        transcludeFn2
                      );
                    } catch (e) {
                      $exceptionHandler2(e, startingTag($element.getAny()));
                    }
                  }
                  if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                    scopeToChild = isolateScope;
                  }
                  if (childLinkFn && linkNode && linkNode.childNodes && linkNode.childNodes.length) {
                    childLinkFn(
                      scopeToChild,
                      new NodeRef(linkNode.childNodes),
                      boundTranscludeFn
                    );
                  }
                  for (i = postLinkFns.length - 1; i >= 0; i--) {
                    let postLinkFn = postLinkFns[i];
                    const controllers = postLinkFn["require"] && getControllers(
                      postLinkFn["directiveName"],
                      postLinkFn["require"],
                      /** @type {Element} */
                      $element.node,
                      elementControllers
                    );
                    try {
                      if (postLinkFn["isolateScope"]) {
                        setIsolateScope($element.element, isolateScope);
                      }
                      postLinkFn(
                        postLinkFn["isolateScope"] ? isolateScope : scope,
                        $element.node,
                        attrs,
                        controllers,
                        transcludeFn2
                      );
                    } catch (e) {
                      $exceptionHandler2(e, startingTag($element.getAny()));
                    }
                  }
                  if (elementControllers) {
                    Object.values(elementControllers).forEach((controller) => {
                      const controllerInstance = controller.instance;
                      if (isFunction(controllerInstance.$postLink)) {
                        controllerInstance.$postLink();
                      }
                    });
                  }
                  function controllersBoundTransclude(scope2, cloneAttachFn, futureParentElement, slotName) {
                    let transcludeControllers;
                    if (!isScope(scope2)) {
                      slotName = futureParentElement;
                      futureParentElement = cloneAttachFn;
                      cloneAttachFn = scope2;
                      scope2 = void 0;
                    }
                    if (hasElementTranscludeDirective) {
                      transcludeControllers = elementControllers;
                    }
                    if (!futureParentElement) {
                      futureParentElement = hasElementTranscludeDirective ? $element.node.parentElement : $element.node;
                    }
                    if (slotName) {
                      const slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                      if (slotTranscludeFn) {
                        return slotTranscludeFn(
                          scope2,
                          cloneAttachFn,
                          transcludeControllers,
                          futureParentElement,
                          scopeToChild
                        );
                      }
                      if (isUndefined(slotTranscludeFn)) {
                        throw $compileMinErr(
                          "noslot",
                          'No parent directive that requires a transclusion with slot name "{0}". Element: {1}',
                          slotName,
                          startingTag($element.element)
                        );
                      }
                    } else {
                      return boundTranscludeFn(
                        scope2,
                        cloneAttachFn,
                        transcludeControllers,
                        futureParentElement,
                        scopeToChild
                      );
                    }
                  }
                };
                for (let i = 0, ii = directives.length; i < ii; i++) {
                  directive = directives[i];
                  $template = void 0;
                  if (terminalPriority > directive.priority) {
                    break;
                  }
                  directiveValue = directive.scope;
                  if (directiveValue) {
                    if (!directive.templateUrl) {
                      if (isObject(directiveValue)) {
                        assertNoDuplicate(
                          "new/isolated scope",
                          newIsolateScopeDirective || newScopeDirective,
                          directive,
                          compileNodeRef
                        );
                        newIsolateScopeDirective = directive;
                      } else {
                        assertNoDuplicate(
                          "new/isolated scope",
                          newIsolateScopeDirective,
                          directive,
                          compileNodeRef
                        );
                      }
                    }
                    newScopeDirective = newScopeDirective || directive;
                  }
                  directiveName = directive.name;
                  const hasReplacedTemplate = directive.replace && (directive.templateUrl || directive.template);
                  const shouldTransclude = directive.transclude && !EXCLUDED_DIRECTIVES.includes(directive.name);
                  if (!didScanForMultipleTransclusion && (hasReplacedTemplate || shouldTransclude)) {
                    let candidateDirective;
                    for (let scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) {
                      if (candidateDirective.transclude && !EXCLUDED_DIRECTIVES.includes(candidateDirective.name) || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                        mightHaveMultipleTransclusionError = true;
                        break;
                      }
                    }
                    didScanForMultipleTransclusion = true;
                  }
                  if (!directive.templateUrl && directive.controller) {
                    controllerDirectives = controllerDirectives || /* @__PURE__ */ Object.create(null);
                    assertNoDuplicate(
                      `'${directiveName}' controller`,
                      controllerDirectives[directiveName],
                      directive,
                      compileNodeRef
                    );
                    controllerDirectives[directiveName] = directive;
                  }
                  directiveValue = directive.transclude;
                  if (directiveValue) {
                    hasTranscludeDirective = true;
                    if (!EXCLUDED_DIRECTIVES.includes(directive.name)) {
                      assertNoDuplicate(
                        "transclusion",
                        nonTlbTranscludeDirective,
                        directive,
                        compileNodeRef
                      );
                      nonTlbTranscludeDirective = directive;
                    }
                    if (directiveValue === "element") {
                      hasElementTranscludeDirective = true;
                      terminalPriority = directive.priority;
                      $template = compileNodeRef;
                      compileNodeRef = new NodeRef(document.createComment(""));
                      templateAttrs.$nodeRef = compileNodeRef;
                      compileNode = compileNodeRef.node;
                      ctxNodeRef.node = compileNode;
                      replaceWith(
                        new NodeRef($template.getAny()),
                        compileNode,
                        index
                      );
                      childTranscludeFn = compilationGenerator(
                        mightHaveMultipleTransclusionError,
                        $template.getAny(),
                        transcludeFn,
                        terminalPriority,
                        replaceDirective && replaceDirective.name,
                        {
                          // Don't pass in:
                          // - controllerDirectives - otherwise we'll create duplicates controllers
                          // - newIsolateScopeDirective or templateDirective - combining templates with
                          //   element transclusion doesn't make sense.
                          //
                          // We need only nonTlbTranscludeDirective so that we prevent putting transclusion
                          // on the same element more than once.
                          nonTlbTranscludeDirective
                        }
                      );
                    } else {
                      const slots = /* @__PURE__ */ Object.create(null);
                      if (!isObject(directiveValue)) {
                        $template = compileNode.cloneNode(true).childNodes;
                      } else {
                        $template = document.createDocumentFragment();
                        const slotMap = /* @__PURE__ */ Object.create(null);
                        const filledSlots = /* @__PURE__ */ Object.create(null);
                        Object.entries(directiveValue).forEach(
                          ([slotName, elementSelector]) => {
                            const optional = elementSelector.charAt(0) === "?";
                            elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                            slotMap[elementSelector] = slotName;
                            slots[slotName] = null;
                            filledSlots[slotName] = optional;
                          }
                        );
                        compileNodeRef.element.childNodes.forEach((node) => {
                          const slotName = slotMap[directiveNormalize(
                            getNodeName(
                              /** @type {Element} */
                              node
                            )
                          )];
                          if (slotName) {
                            filledSlots[slotName] = true;
                            slots[slotName] = slots[slotName] || document.createDocumentFragment();
                            slots[slotName].appendChild(node);
                          } else {
                            $template.appendChild(node);
                          }
                        });
                        Object.entries(filledSlots).forEach(([slotName, filled]) => {
                          if (!filled) {
                            throw $compileMinErr(
                              "reqslot",
                              "Required transclusion slot `{0}` was not filled.",
                              slotName
                            );
                          }
                        });
                        for (const slotName in slots) {
                          if (slots[slotName]) {
                            const slotCompileNodes = slots[slotName].childNodes;
                            slots[slotName] = compilationGenerator(
                              mightHaveMultipleTransclusionError,
                              slotCompileNodes,
                              transcludeFn
                            );
                          }
                        }
                        $template = $template.childNodes;
                      }
                      emptyElement(
                        /** @type {Element} */
                        compileNode
                      );
                      childTranscludeFn = compilationGenerator(
                        mightHaveMultipleTransclusionError,
                        $template,
                        transcludeFn,
                        void 0,
                        void 0,
                        {
                          needsNewScope: directive.$$isolateScope || directive.$$newScope
                        }
                      );
                      childTranscludeFn["$$slots"] = slots;
                    }
                  }
                  if (directive.template) {
                    hasTemplate = true;
                    assertNoDuplicate(
                      "template",
                      templateDirective,
                      directive,
                      compileNodeRef
                    );
                    templateDirective = directive;
                    directiveValue = isFunction(directive.template) ? directive.template(compileNodeRef.node, templateAttrs) : directive.template;
                    directiveValue = denormalizeTemplate(directiveValue);
                    if (directive.replace) {
                      replaceDirective = directive;
                      if (isTextNode(directiveValue)) {
                        $template = [];
                      } else {
                        $template = removeComments(
                          wrapTemplate(
                            directive.templateNamespace,
                            trim(directiveValue)
                          )
                        );
                      }
                      if (isString($template)) {
                        $template = Array.from(
                          createNodelistFromHTML($template)
                        ).filter((x) => x.nodeType === Node.ELEMENT_NODE);
                      }
                      compileNode = $template[0];
                      if ($template.length !== 1 || compileNode.nodeType !== Node.ELEMENT_NODE) {
                        throw $compileMinErr(
                          "tplrt",
                          "Template for directive '{0}' must have exactly one root element. {1}",
                          directiveName,
                          ""
                        );
                      }
                      replaceWith(compileNodeRef, compileNode);
                      if (parentNodeRef) {
                        parentNodeRef.setIndex(index, compileNode);
                      }
                      const newTemplateAttrs = { $attr: {} };
                      const templateDirectives = collectDirectives(
                        /** @type {Element} */
                        compileNode,
                        newTemplateAttrs
                      );
                      const unprocessedDirectives = directives.splice(
                        i + 1,
                        directives.length - (i + 1)
                      );
                      if (newIsolateScopeDirective || newScopeDirective) {
                        markDirectiveScope(
                          templateDirectives,
                          newIsolateScopeDirective,
                          newScopeDirective
                        );
                      }
                      directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                      mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                      ii = directives.length;
                    } else {
                      if (compileNodeRef.isElement()) {
                        compileNodeRef.element.innerHTML = directiveValue;
                      }
                    }
                  }
                  if (directive.templateUrl) {
                    hasTemplate = true;
                    assertNoDuplicate(
                      "template",
                      templateDirective,
                      directive,
                      compileNodeRef
                    );
                    templateDirective = directive;
                    if (directive.replace) {
                      replaceDirective = directive;
                    }
                    nodeLinkFn = compileTemplateUrl(
                      directives.splice(i, directives.length - i),
                      compileNodeRef,
                      templateAttrs,
                      /** @type {Element} */
                      compileNode,
                      hasTranscludeDirective && childTranscludeFn,
                      preLinkFns,
                      postLinkFns,
                      {
                        index,
                        controllerDirectives,
                        newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                        newIsolateScopeDirective,
                        templateDirective,
                        nonTlbTranscludeDirective,
                        futureParentElement: previousCompileContext.futureParentElement
                      }
                    );
                    ii = directives.length;
                  } else if (directive.compile) {
                    try {
                      const linkFn = directive.compile(
                        compileNodeRef.getAny(),
                        templateAttrs,
                        childTranscludeFn
                      );
                      const context = directive.$$originalDirective || directive;
                      if (isFunction(linkFn)) {
                        addLinkFns(null, bind(context, linkFn));
                      } else if (linkFn) {
                        addLinkFns(
                          bind(context, linkFn["pre"]),
                          bind(context, linkFn["post"])
                        );
                      }
                    } catch (e) {
                      $exceptionHandler2(e, startingTag(compileNodeRef.getAny()));
                    }
                  }
                  if (directive.terminal) {
                    terminal = true;
                    terminalPriority = Math.max(terminalPriority, directive.priority);
                  }
                }
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
                return {
                  nodeLinkFn,
                  terminal,
                  transclude: childTranscludeFn,
                  transcludeOnThisElement: hasTranscludeDirective,
                  templateOnThisElement: hasTemplate,
                  newScope: newScopeDirective && newScopeDirective.scope === true
                };
                function addLinkFns(pre, post) {
                  if (pre) {
                    pre.require = directive.require;
                    pre.directiveName = directiveName;
                    if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                      pre = cloneAndAnnotateFn(pre, { isolateScope: true });
                    }
                    preLinkFns.push(pre);
                  }
                  if (post) {
                    post.require = directive.require;
                    post.directiveName = directiveName;
                    if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                      post = cloneAndAnnotateFn(post, { isolateScope: true });
                    }
                    postLinkFns.push(post);
                  }
                }
              }
              function getControllers(directiveName, require2, $element, elementControllers) {
                let value;
                if (isString(require2)) {
                  const match = require2.match(REQUIRE_PREFIX_REGEXP);
                  const name2 = require2.substring(match[0].length);
                  const inheritType = match[1] || match[3];
                  const optional = match[2] === "?";
                  if (inheritType === "^^") {
                    if ($element.parentElement) {
                      $element = $element.parentElement;
                    } else {
                      $element = void 0;
                    }
                  } else {
                    value = elementControllers && elementControllers[name2];
                    value = value && value.instance;
                  }
                  if (!value) {
                    const dataName = `$${name2}Controller`;
                    if (inheritType === "^^" && $element && $element.nodeType === Node.DOCUMENT_NODE) {
                      value = null;
                    } else {
                      value = $element ? inheritType ? getInheritedData($element, dataName) : getCacheData($element, dataName) : void 0;
                    }
                  }
                  if (!value && !optional) {
                    throw $compileMinErr(
                      "ctreq",
                      "Controller '{0}', required by directive '{1}', can't be found!",
                      name2,
                      directiveName
                    );
                  }
                } else if (Array.isArray(require2)) {
                  value = [];
                  for (let i = 0, ii = require2.length; i < ii; i++) {
                    value[i] = getControllers(
                      directiveName,
                      require2[i],
                      $element,
                      elementControllers
                    );
                  }
                } else if (isObject(require2)) {
                  value = {};
                  Object.entries(require2).forEach(([property, controller]) => {
                    value[property] = getControllers(
                      directiveName,
                      controller,
                      $element,
                      elementControllers
                    );
                  });
                }
                return value || null;
              }
              function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                const elementControllers = /* @__PURE__ */ Object.create(null);
                for (const controllerKey in controllerDirectives) {
                  const directive = controllerDirectives[controllerKey];
                  const locals = {
                    $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                    $element: $element.node,
                    $attrs: attrs,
                    $transclude: transcludeFn
                  };
                  let { controller } = directive;
                  if (controller === "@") {
                    controller = attrs[directive.name];
                  }
                  const controllerInstance = $controller(
                    controller,
                    locals,
                    true,
                    directive.controllerAs
                  );
                  elementControllers[directive.name] = controllerInstance;
                  if ($element.isElement()) {
                    setCacheData(
                      $element.element,
                      `$${directive.name}Controller`,
                      controllerInstance.instance
                    );
                  }
                }
                return elementControllers;
              }
              function markDirectiveScope(directives, isolateScope, newScope) {
                for (let j = 0, jj = directives.length; j < jj; j++) {
                  directives[j] = inherit$1(directives[j], {
                    $$isolateScope: isolateScope,
                    $$newScope: newScope
                  });
                }
              }
              function addDirective(tDirectives, name2, location, maxPriority) {
                let match = false;
                if (hasOwn(hasDirectives, name2)) {
                  for (let directive, directives = $injector.get(name2 + DirectiveSuffix), i = 0, ii = directives.length; i < ii; i++) {
                    directive = directives[i];
                    if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) !== -1) {
                      if (!directive.$$bindings) {
                        const bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                        if (isObject(bindings.isolateScope)) {
                          directive.$$isolateBindings = bindings.isolateScope;
                        }
                      }
                      tDirectives.push(directive);
                      match = directive;
                    }
                  }
                }
                return match;
              }
              function mergeTemplateAttributes(dst, src) {
                const srcAttr = src.$attr;
                const dstAttr = dst.$attr;
                Object.entries(dst).forEach(([key, value]) => {
                  if (key.charAt(0) !== "$") {
                    if (src[key] && src[key] !== value) {
                      if (value.length) {
                        value += (key === "style" ? ";" : " ") + src[key];
                      } else {
                        value = src[key];
                      }
                    }
                    dst.$set(key, value, true, srcAttr[key]);
                  }
                });
                Object.entries(src).forEach(([key, value]) => {
                  if (!hasOwn(dst, key) && key.charAt(0) !== "$") {
                    dst[key] = value;
                    if (key !== "class" && key !== "style") {
                      dstAttr[key] = srcAttr[key];
                    }
                  }
                });
              }
              function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                let linkQueue = [];
                let afterTemplateNodeLinkFn;
                let afterTemplateChildLinkFn;
                let afterTemplateNodeLinkFnCtx;
                const beforeTemplateCompileNode = $compileNode.getAny();
                const origAsyncDirective = directives.shift();
                const derivedSyncDirective = inherit$1(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                });
                const templateUrl = isFunction(origAsyncDirective.templateUrl) ? (
                  /** @type { ((element: Element, tAttrs: Attributes) => string) } */
                  origAsyncDirective.templateUrl($compileNode.element, tAttrs)
                ) : origAsyncDirective.templateUrl;
                const { templateNamespace } = origAsyncDirective;
                emptyElement($compileNode.element);
                $templateRequest(templateUrl).then((content) => {
                  let compileNode;
                  let tempTemplateAttrs;
                  let $template;
                  let childBoundTranscludeFn;
                  content = denormalizeTemplate(content);
                  if (origAsyncDirective.replace) {
                    if (isTextNode(content)) {
                      $template = [];
                    } else if (isString(content)) {
                      $template = Array.from(
                        createNodelistFromHTML(content)
                      ).filter(
                        (node) => node.nodeType !== Node.COMMENT_NODE && node.nodeType !== Node.TEXT_NODE
                      );
                    } else {
                      $template = removeComments(
                        wrapTemplate(templateNamespace, trim(content))
                      );
                    }
                    compileNode = $template[0];
                    if ($template.length !== 1 || compileNode.nodeType !== Node.ELEMENT_NODE) {
                      throw $compileMinErr(
                        "tplrt",
                        "Template for directive '{0}' must have exactly one root element. {1}",
                        origAsyncDirective.name,
                        templateUrl
                      );
                    }
                    tempTemplateAttrs = { $attr: {} };
                    replaceWith(
                      $compileNode,
                      compileNode,
                      previousCompileContext.index
                    );
                    const templateDirectives = collectDirectives(
                      compileNode,
                      tempTemplateAttrs
                    );
                    if (isObject(origAsyncDirective.scope)) {
                      markDirectiveScope(templateDirectives, true);
                    }
                    directives = templateDirectives.concat(directives);
                    mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                  } else {
                    compileNode = /** @type {Element} */
                    beforeTemplateCompileNode;
                    $compileNode.element.innerHTML = content;
                  }
                  directives.unshift(derivedSyncDirective);
                  afterTemplateNodeLinkFnCtx = applyDirectivesToNode(
                    directives,
                    compileNode,
                    tAttrs,
                    childTranscludeFn,
                    origAsyncDirective,
                    preLinkFns,
                    postLinkFns,
                    { ...previousCompileContext, ctxNodeRef: $compileNode }
                  );
                  afterTemplateNodeLinkFn = afterTemplateNodeLinkFnCtx?.nodeLinkFn;
                  if ($rootElement) {
                    Object.entries($rootElement).forEach(([i, node]) => {
                      if (node === compileNode) {
                        $rootElement[i] = $compileNode;
                      }
                    });
                  }
                  afterTemplateChildLinkFn = compileNodes(
                    new NodeRef($compileNode.getAny().childNodes),
                    childTranscludeFn
                  );
                  while (linkQueue.length) {
                    const scope = linkQueue.shift();
                    const beforeTemplateLinkNode = linkQueue.shift();
                    const boundTranscludeFn = linkQueue.shift();
                    let linkNode = $compileNode.getAny();
                    if (scope.$$destroyed) {
                      continue;
                    }
                    if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                      const oldClasses = beforeTemplateLinkNode.className;
                      if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                        linkNode = compileNode.cloneNode(true);
                        beforeTemplateLinkNode.appendChild(linkNode);
                      }
                      try {
                        if (oldClasses !== "") {
                          $compileNode.element.classList.forEach(
                            (cls) => beforeTemplateLinkNode.classList.add(cls)
                          );
                        }
                      } catch {
                      }
                    }
                    if (afterTemplateNodeLinkFnCtx.transcludeOnThisElement) {
                      childBoundTranscludeFn = createBoundTranscludeFn(
                        scope,
                        afterTemplateNodeLinkFnCtx.transclude,
                        boundTranscludeFn
                      );
                    } else {
                      childBoundTranscludeFn = boundTranscludeFn;
                    }
                    afterTemplateNodeLinkFn(
                      afterTemplateChildLinkFn,
                      scope,
                      linkNode,
                      childBoundTranscludeFn
                    );
                  }
                  linkQueue = null;
                }).catch((error) => {
                  if (isError(error)) {
                    $exceptionHandler2(error);
                  } else {
                    $exceptionHandler2(new Error(error));
                  }
                });
                return function delayedNodeLinkFn(_ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                  let childBoundTranscludeFn = boundTranscludeFn;
                  if (scope.$$destroyed) {
                    return;
                  }
                  if (linkQueue) {
                    linkQueue.push(scope, node, rootElement);
                  } else {
                    if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                      childBoundTranscludeFn = createBoundTranscludeFn(
                        scope,
                        afterTemplateNodeLinkFn.transclude,
                        boundTranscludeFn
                      );
                    }
                    afterTemplateNodeLinkFn(
                      afterTemplateChildLinkFn,
                      scope,
                      node,
                      rootElement,
                      childBoundTranscludeFn
                    );
                  }
                };
              }
              function byPriority(a, b) {
                const diff = b.priority - a.priority;
                if (diff !== 0) {
                  return diff;
                }
                if (a.name !== b.name) {
                  return a.name < b.name ? -1 : 1;
                }
                return a.index - b.index;
              }
              function assertNoDuplicate(what, previousDirective, directive, element) {
                function wrapModuleNameIfDefined(moduleName) {
                  return moduleName ? ` (module: ${moduleName})` : "";
                }
                if (previousDirective) {
                  throw $compileMinErr(
                    "multidir",
                    "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}",
                    previousDirective.name,
                    wrapModuleNameIfDefined(previousDirective.$$moduleName),
                    directive.name,
                    wrapModuleNameIfDefined(directive.$$moduleName),
                    what,
                    startingTag(element.getAny())
                  );
                }
              }
              function addTextInterpolateDirective(directives, text) {
                const interpolateFn = $interpolate(text, true);
                if (interpolateFn) {
                  directives.push({
                    priority: 0,
                    compile: () => (scope, node) => {
                      interpolateFn.expressions.forEach((x) => {
                        scope.$watch(x, () => {
                          const res = interpolateFn(
                            isProxy(scope) ? scope.$target : scope
                          );
                          switch (node.nodeType) {
                            case 1:
                              node.innerHTML = res;
                              break;
                            default:
                              node.nodeValue = res;
                          }
                        });
                      });
                    }
                  });
                }
              }
              function wrapTemplate(type, template) {
                type = (type || "html").toLowerCase();
                switch (type) {
                  case "svg":
                  case "math": {
                    const wrapper = (
                      /** @type {HTMLDivElement} */
                      document.createElement("div")
                    );
                    wrapper.innerHTML = `<${type}>${template}</${type}>`;
                    return wrapper.childNodes[0].childNodes;
                  }
                  default:
                    return template;
                }
              }
              function getTrustedAttrContext(nodeName, attrNormalizedName) {
                if (attrNormalizedName === "srcdoc") {
                  return $sce.HTML;
                }
                if (attrNormalizedName === "src" || attrNormalizedName === "ngSrc") {
                  if (["img", "video", "audio", "source", "track"].indexOf(nodeName) === -1) {
                    return $sce.RESOURCE_URL;
                  }
                  return $sce.MEDIA_URL;
                }
                if (attrNormalizedName === "xlinkHref") {
                  if (nodeName === "image") {
                    return $sce.MEDIA_URL;
                  }
                  if (nodeName === "a") {
                    return $sce.URL;
                  }
                  return $sce.RESOURCE_URL;
                }
                if (
                  // Formaction
                  nodeName === "form" && attrNormalizedName === "action" || // If relative URLs can go where they are not expected to, then
                  // all sorts of trust issues can arise.
                  nodeName === "base" && attrNormalizedName === "href" || // links can be stylesheets or imports, which can run script in the current origin
                  nodeName === "link" && attrNormalizedName === "href"
                ) {
                  return $sce.RESOURCE_URL;
                }
                if (nodeName === "a" && (attrNormalizedName === "href" || attrNormalizedName === "ngHref")) {
                  return $sce.URL;
                }
              }
              function getTrustedPropContext(nodeName, propNormalizedName) {
                const prop = propNormalizedName.toLowerCase();
                return PROP_CONTEXTS[`${nodeName}|${prop}`] || PROP_CONTEXTS[`*|${prop}`];
              }
              function sanitizeSrcset(value, invokeType) {
                if (!value) {
                  return value;
                }
                if (!isString(value)) {
                  throw $compileMinErr(
                    "srcset",
                    'Can\'t pass trusted values to `{0}`: "{1}"',
                    invokeType,
                    value.toString()
                  );
                }
                let result = "";
                const trimmedSrcset = trim(value);
                const srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                const pattern2 = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                const rawUris = trimmedSrcset.split(pattern2);
                const nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                let i;
                for (i = 0; i < nbrUrisWith2parts; i++) {
                  const innerIdx = i * 2;
                  result += $sce.getTrustedMediaUrl(trim(rawUris[innerIdx]));
                  result += " " + trim(rawUris[innerIdx + 1]);
                }
                const lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $sce.getTrustedMediaUrl(trim(lastTuple[0]));
                if (lastTuple.length === 2) {
                  result += " " + trim(lastTuple[1]);
                }
                return result;
              }
              function addPropertyDirective(node, directives, attrName, propName) {
                if (EVENT_HANDLER_ATTR_REGEXP.test(propName)) {
                  throw $compileMinErr(
                    "nodomevents",
                    "Property bindings for HTML DOM event properties are disallowed"
                  );
                }
                const nodeName = getNodeName(node);
                const trustedContext = getTrustedPropContext(nodeName, propName);
                let sanitizer = (x) => x;
                if (propName === "srcset" && (nodeName === "img" || nodeName === "source")) {
                  sanitizer = (value) => sanitizeSrcset($sce.valueOf(value), "ng-prop-srcset");
                } else if (trustedContext) {
                  sanitizer = $sce.getTrusted.bind($sce, trustedContext);
                }
                directives.push({
                  priority: 100,
                  compile: function ngPropCompileFn(_, attr) {
                    const ngPropGetter = $parse2(attr[attrName]);
                    return {
                      pre: function ngPropPreLinkFn(scope, $element) {
                        function applyPropValue() {
                          const propValue = ngPropGetter(scope);
                          $element[propName] = sanitizer(propValue);
                        }
                        applyPropValue();
                        scope.$watch(propName, applyPropValue);
                        scope.$watch(attr[attrName], (val2) => {
                          $sce.valueOf(val2);
                          applyPropValue();
                        });
                      }
                    };
                  }
                });
              }
              function addAttrInterpolateDirective(node, directives, value, name2, isNgAttr) {
                const nodeName = getNodeName(node);
                const trustedContext = getTrustedAttrContext(nodeName, name2);
                const mustHaveExpression = !isNgAttr;
                const allOrNothing = ALL_OR_NOTHING_ATTRS.includes(name2) || isNgAttr;
                let interpolateFn = $interpolate(
                  value,
                  mustHaveExpression,
                  trustedContext,
                  allOrNothing
                );
                if (!interpolateFn) {
                  return;
                }
                if (name2 === "multiple" && nodeName === "select") {
                  throw $compileMinErr(
                    "selmulti",
                    "Binding to the 'multiple' attribute is not supported. Element: {0}",
                    startingTag(node.outerHTML)
                  );
                }
                if (EVENT_HANDLER_ATTR_REGEXP.test(name2)) {
                  throw $compileMinErr(
                    "nodomevents",
                    "Interpolations for HTML DOM event attributes are disallowed"
                  );
                }
                directives.push({
                  priority: 100,
                  compile() {
                    return {
                      pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                        const $$observers = attr.$$observers || (attr.$$observers = /* @__PURE__ */ Object.create(null));
                        const newValue = attr[name2];
                        if (newValue !== value) {
                          interpolateFn = newValue && $interpolate(
                            newValue,
                            true,
                            trustedContext,
                            allOrNothing
                          );
                          value = newValue;
                        }
                        if (!interpolateFn) {
                          return;
                        }
                        attr[name2] = interpolateFn(scope);
                        ($$observers[name2] || ($$observers[name2] = [])).$$inter = true;
                        interpolateFn.expressions.forEach((x) => {
                          const targetScope = attr.$$observers && attr.$$observers[name2].$$scope || scope;
                          targetScope.$watch(x, () => {
                            let newValue2 = interpolateFn(scope);
                            if (name2 === "class") {
                              attr.$updateClass(
                                newValue2,
                                attr.$$element.classList.value
                              );
                            } else {
                              attr.$set(name2, newValue2);
                            }
                          });
                        });
                        if (interpolateFn.expressions.length == 0) {
                          attr.$set(name2, newValue);
                        }
                      }
                    };
                  }
                });
              }
              function replaceWith(elementsToRemove, newNode, index) {
                const firstElementToRemove = elementsToRemove.getAny();
                const parent = firstElementToRemove.parentNode;
                if (parent) {
                  if (isDefined(index)) {
                    const oldChild = parent.childNodes[index];
                    if (oldChild) {
                      parent.replaceChild(newNode, oldChild);
                    }
                  } else {
                    parent.insertBefore(newNode, parent.firstChild);
                  }
                }
                const fragment = document.createDocumentFragment();
                elementsToRemove.collection().forEach((element) => {
                  fragment.appendChild(element);
                });
                elementsToRemove.node = newNode;
              }
              function cloneAndAnnotateFn(fn, annotation) {
                return extend(
                  function() {
                    return fn.apply(null, arguments);
                  },
                  fn,
                  annotation
                );
              }
              function strictBindingsCheck(attrName, directiveName) {
                if (strictComponentBindingsEnabled) {
                  throw $compileMinErr(
                    "missingattr",
                    "Attribute '{0}' of '{1}' is non-optional and must be set!",
                    attrName,
                    directiveName
                  );
                }
              }
              function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                const removeWatchCollection = [];
                const initialChanges = {};
                let changes;
                if (bindings) {
                  Object.entries(bindings).forEach(([scopeName, definition]) => {
                    const {
                      attrName,
                      optional,
                      mode
                      // @, =, <, or &
                    } = definition;
                    let lastValue;
                    let parentGet;
                    let parentSet;
                    let compare;
                    let removeWatch;
                    let firstCall = true;
                    let firstChange = true;
                    switch (mode) {
                      case "@":
                        if (!optional && !hasOwn(attrs, attrName)) {
                          strictBindingsCheck(attrName, directive.name);
                          destination[scopeName] = attrs[attrName] = void 0;
                        }
                        removeWatch = attrs.$observe(attrName, (value) => {
                          if (isString(value) || isBoolean(value)) {
                            recordChanges(scopeName, value, firstChange);
                            destination[scopeName] = value;
                            if (firstCall) {
                              firstCall = false;
                            } else {
                              triggerOnChangesHook();
                              firstChange = false;
                            }
                          }
                        });
                        attrs.$$observers[attrName].$$scope = scope;
                        lastValue = attrs[attrName];
                        if (isString(lastValue)) {
                          destination[scopeName] = $interpolate(lastValue)(scope);
                        } else if (isBoolean(lastValue)) {
                          destination[scopeName] = lastValue;
                        }
                        initialChanges[scopeName] = {
                          currentValue: destination[scopeName],
                          firstChange: true
                        };
                        removeWatchCollection.push(removeWatch);
                        break;
                      case "=": {
                        if (!hasOwn(attrs, attrName)) {
                          if (optional) {
                            break;
                          }
                          strictBindingsCheck(attrName, directive.name);
                          attrs[attrName] = void 0;
                        }
                        if (optional && !attrs[attrName]) {
                          break;
                        }
                        parentGet = $parse2(attrs[attrName]);
                        if (parentGet.literal) {
                          compare = equals$1;
                        } else {
                          compare = simpleCompare;
                        }
                        parentSet = parentGet.assign || function() {
                          lastValue = destination.$target[scopeName] = parentGet(scope);
                          throw $compileMinErr(
                            "nonassign",
                            "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!",
                            attrs[attrName],
                            attrName,
                            directive.name
                          );
                        };
                        lastValue = destination.$target[scopeName] = parentGet(
                          scope.$target
                        );
                        const parentValueWatch = function parentValueWatch2(parentValue) {
                          if (!compare(parentValue, destination[scopeName])) {
                            if (!compare(parentValue, lastValue)) {
                              destination[scopeName] = parentValue;
                            } else {
                              parentSet(
                                scope,
                                parentValue = destination[scopeName]
                              );
                            }
                          }
                          lastValue = parentValue;
                          return lastValue;
                        };
                        parentValueWatch.$stateful = true;
                        if (definition.collection) {
                          removeWatch = scope.$watch(
                            attrs[attrName],
                            parentValueWatch
                          );
                        } else {
                          if (attrs[attrName]) {
                            let expr = attrs[attrName];
                            scope.$watch(
                              expr,
                              (val2) => {
                                const res = $parse2(attrs[attrName], parentValueWatch);
                                if (val2) {
                                  if (parentGet.literal) {
                                    scope.$target[attrName] = val2;
                                  } else {
                                    scope[attrName] = val2;
                                  }
                                  res(scope);
                                } else {
                                  scope[attrName] = scope[attrs[attrName]];
                                }
                              },
                              true
                            );
                          }
                          removeWatch = destination.$watch(
                            attrName,
                            (val2) => {
                              if (val2 === lastValue && !isUndefined(attrs[attrName])) {
                                return;
                              }
                              if (!!parentGet.inputs && !parentGet.literal || isUndefined(attrs[attrName]) && isDefined(val2)) {
                                destination.$target[attrName] = lastValue;
                                throw $compileMinErr(
                                  "nonassign",
                                  "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!",
                                  attrs[attrName],
                                  attrName,
                                  directive.name
                                );
                              } else {
                                if (isObject(val2)) {
                                  Object.entries(val2).forEach(([key, value]) => {
                                    scope.$target[key] = value;
                                  });
                                } else {
                                  parentSet(scope.$target, lastValue = val2);
                                  scope.$handler.watchers.get(attrs[attrName])?.forEach((watchFn) => {
                                    watchFn.listenerFn(val2);
                                  });
                                }
                              }
                            },
                            true
                          );
                        }
                        removeWatchCollection.push(removeWatch);
                        break;
                      }
                      case "<":
                        if (!hasOwn(attrs, attrName)) {
                          if (optional) {
                            break;
                          }
                          strictBindingsCheck(attrName, directive.name);
                          attrs[attrName] = void 0;
                        }
                        if (optional && !attrs[attrName]) {
                          break;
                        }
                        parentGet = $parse2(attrs[attrName]);
                        destination.$target[scopeName] = parentGet(scope.$target);
                        initialChanges[scopeName] = {
                          currentValue: destination.$target[scopeName],
                          firstChange
                        };
                        scope.$target.attrs = attrs;
                        if (attrs[attrName]) {
                          removeWatch = scope.$watch(
                            attrs[attrName],
                            (val2) => {
                              destination.$target[scopeName] = val2;
                              recordChanges(scopeName, val2, firstChange);
                              if (firstChange) {
                                firstChange = false;
                              }
                            },
                            true
                          );
                          removeWatchCollection.push(removeWatch);
                        }
                        break;
                      case "&":
                        if (!optional && !hasOwn(attrs, attrName)) {
                          strictBindingsCheck(attrName, directive.name);
                        }
                        parentGet = hasOwn(attrs, attrName) ? $parse2(attrs[attrName]) : () => {
                        };
                        if (parentGet.toString() === (() => {
                        }).toString() && optional) {
                          break;
                        }
                        destination.$target[scopeName] = function(locals) {
                          return parentGet(scope.$target, locals);
                        };
                        break;
                    }
                  });
                }
                function recordChanges(key, currentValue, initial) {
                  if (isFunction(destination["$onChanges"])) {
                    if (!onChangesQueue) {
                      scope.$postUpdate(flushOnChangesQueue);
                      onChangesQueue = [];
                    }
                    if (!changes) {
                      changes = {};
                      onChangesQueue.push(triggerOnChangesHook);
                    }
                    changes[key] = {
                      currentValue,
                      firstChange: initial
                    };
                  }
                }
                function triggerOnChangesHook() {
                  destination["$onChanges"] && changes && destination["$onChanges"](changes);
                  changes = void 0;
                }
                return {
                  initialChanges,
                  removeWatches: removeWatchCollection.length && function removeWatches() {
                    for (let i = 0, ii = removeWatchCollection.length; i < ii; ++i) {
                      removeWatchCollection[i]();
                    }
                  }
                };
              }
            }
          ];
        }
      }
      function removeComments(jqNodes) {
        let i = jqNodes.length;
        if (i <= 1) {
          return jqNodes;
        }
        while (i--) {
          const node = jqNodes[i];
          if (node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.TEXT_NODE && node.nodeValue.trim() === "") {
            [].splice.call(jqNodes, i, 1);
          }
        }
        return jqNodes;
      }
      function assertValidDirectiveName(name2) {
        const letter = name2.charAt(0);
        if (!letter || letter !== lowercase(letter)) {
          throw $compileMinErr(
            "baddir",
            "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter",
            name2
          );
        }
        if (name2 !== name2.trim()) {
          throw $compileMinErr(
            "baddir",
            "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces",
            name2
          );
        }
      }
      const nullFormCtrl = {
        $nonscope: true,
        $addControl: () => {
        },
        $getControls: () => [],
        $$renameControl: (control, name2) => {
          control.$name = name2;
        },
        $removeControl: () => {
        },
        $setValidity: () => {
        },
        $setDirty: () => {
        },
        $setPristine: () => {
        },
        $setSubmitted: () => {
        },
        $$setSubmitted: () => {
        }
      };
      const PENDING_CLASS = "ng-pending";
      const SUBMITTED_CLASS = "ng-submitted";
      class FormController {
        static $nonscope = true;
        /* @ignore */
        static $inject = [
          "$element",
          "$attrs",
          "$scope",
          "$animate",
          "$interpolate"
        ];
        /**
         * @param {Element} $element
         * @param {import("../../core/compile/attributes.js").Attributes} $attrs
         * @param {import("../../core/scope/scope.js").Scope} $scope
         * @param {*} $animate
         * @param {*} $interpolate
         */
        constructor($element, $attrs, $scope, $animate, $interpolate) {
          this.$$controls = [];
          this.$name = $interpolate($attrs["name"] || $attrs["ngForm"] || "")($scope);
          this.$dirty = false;
          this.$pristine = true;
          this.$valid = true;
          this.$invalid = false;
          this.$submitted = false;
          this.$$parentForm = nullFormCtrl;
          this.$$element = $element;
          this.$$animate = $animate;
          this.$error = {};
          this.$$success = {};
          this.$pending = void 0;
          this.$$classCache = {};
          const isValid = this.$$element.classList.contains(VALID_CLASS);
          this.$$classCache[VALID_CLASS] = isValid;
          this.$$classCache[INVALID_CLASS] = !isValid;
        }
        /**
         * Rollback all form controls pending updates to the `$modelValue`.
         *
         * Updates may be pending by a debounced event or because the input is waiting for a some future
         * event defined in `ng-model-options`. This method is typically needed by the reset button of
         * a form that uses `ng-model-options` to pend updates.
         */
        $rollbackViewValue() {
          this.$$controls.forEach((control) => {
            control.$rollbackViewValue();
          });
        }
        /**
         * Commit all form controls pending updates to the `$modelValue`.
         *
         * Updates may be pending by a debounced event or because the input is waiting for a some future
         * event defined in `ng-model-options`. This method is rarely needed as `NgModelController`
         * usually handles calling this in response to input events.
         */
        $commitViewValue() {
          this.$$controls.forEach((control) => {
            control.$commitViewValue();
          });
        }
        /**
         * Register a control with the form. Input elements using ngModelController do this automatically
         * when they are linked.
         *
         * Note that the current state of the control will not be reflected on the new parent form. This
         * is not an issue with normal use, as freshly compiled and linked controls are in a `$pristine`
         * state.
         *
         * However, if the method is used programmatically, for example by adding dynamically created controls,
         * or controls that have been previously removed without destroying their corresponding DOM element,
         * it's the developers responsibility to make sure the current state propagates to the parent form.
         *
         * For example, if an input control is added that is already `$dirty` and has `$error` properties,
         * calling `$setDirty()` and `$validate()` afterwards will propagate the state to the parent form.
         */
        $addControl(control) {
          assertNotHasOwnProperty(control.$name, "input");
          this.$$controls.push(control);
          if (control.$name) {
            this[control.$name] = control;
          }
          control.$target.$$parentForm = this;
        }
        /**
         * This method returns a **shallow copy** of the controls that are currently part of this form.
         * The controls can be instances of {@link form.FormController `FormController`}
         * ({@link ngForm "child-forms"}) and of {@link ngModel.NgModelController `NgModelController`}.
         * If you need access to the controls of child-forms, you have to call `$getControls()`
         * recursively on them.
         * This can be used for example to iterate over all controls to validate them.
         *
         * The controls can be accessed normally, but adding to, or removing controls from the array has
         * no effect on the form. Instead, use {@link form.FormController#$addControl `$addControl()`} and
         * {@link form.FormController#$removeControl `$removeControl()`} for this use-case.
         * Likewise, adding a control to, or removing a control from the form is not reflected
         * in the shallow copy. That means you should get a fresh copy from `$getControls()` every time
         * you need access to the controls.
         */
        $getControls() {
          return shallowCopy(this.$$controls);
        }
        // Private API: rename a form control
        $$renameControl(control, newName) {
          const oldName = control.$name;
          if (this[oldName] === control) {
            delete this[oldName];
          }
          this[newName] = control;
          control.$name = newName;
        }
        /**
         * Deregister a control from the form.
         *
         * Input elements using ngModelController do this automatically when they are destroyed.
         *
         * Note that only the removed control's validation state (`$errors`etc.) will be removed from the
         * form. `$dirty`, `$submitted` states will not be changed, because the expected behavior can be
         * different from case to case. For example, removing the only `$dirty` control from a form may or
         * may not mean that the form is still `$dirty`.
         */
        $removeControl(control) {
          if (control.$name && this[control.$name] === control) {
            delete this[control.$name];
          }
          this.$pending && Object.keys(this.$pending).forEach((name2) => {
            this.$setValidity(name2, null, control);
          });
          this.$error && Object.keys(this.$error).forEach((name2) => {
            this.$setValidity(name2, null, control);
          });
          this.$$success && Object.keys(this.$$success).forEach((name2) => {
            this.$setValidity(name2, null, control);
          });
          arrayRemove(this.$$controls, control);
          control.$target["$$parentForm"] = nullFormCtrl;
        }
        /**
         * Sets the form to a dirty state.
         *
         * This method can be called to add the 'ng-dirty' class and set the form to a dirty
         * state (ng-dirty class). This method will also propagate to parent forms.
         */
        $setDirty() {
          this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
          this.$$animate.addClass(this.$$element, DIRTY_CLASS);
          this.$dirty = true;
          this.$pristine = false;
          this.$$parentForm.$setDirty();
        }
        /**
         * Sets the form to its pristine state.
         *
         * This method sets the form's `$pristine` state to true, the `$dirty` state to false, removes
         * the `ng-dirty` class and adds the `ng-pristine` class. Additionally, it sets the `$submitted`
         * state to false.
         *
         * This method will also propagate to all the controls contained in this form.
         *
         * Setting a form back to a pristine state is often useful when we want to 'reuse' a form after
         * saving or resetting it.
         */
        $setPristine() {
          this.$$animate.setClass(
            this.$$element,
            PRISTINE_CLASS,
            `${DIRTY_CLASS} ${SUBMITTED_CLASS}`
          );
          this.$dirty = false;
          this.$pristine = true;
          this.$submitted = false;
          this.$$controls.forEach((control) => {
            control.$setPristine();
          });
        }
        /**
         * Sets the form to its untouched state.
         *
         * This method can be called to remove the 'ng-touched' class and set the form controls to their
         * untouched state (ng-untouched class).
         *
         * Setting a form controls back to their untouched state is often useful when setting the form
         * back to its pristine state.
         */
        $setUntouched() {
          this.$$controls.forEach((control) => {
            control.$setUntouched();
          });
        }
        /**
         * Sets the form to its `$submitted` state. This will also set `$submitted` on all child and
         * parent forms of the form.
         */
        $setSubmitted() {
          let rootForm = this;
          while (rootForm.$$parentForm && rootForm.$$parentForm !== nullFormCtrl) {
            rootForm = rootForm.$$parentForm;
          }
          rootForm.$$setSubmitted();
        }
        $$setSubmitted() {
          this.$$animate.addClass(this.$$element, SUBMITTED_CLASS);
          this.$submitted = true;
          this.$$controls.forEach((control) => {
            if (control.$$setSubmitted) {
              control.$$setSubmitted();
            }
          });
        }
        set(object, property, controller) {
          const list = object[property];
          if (!list) {
            if (isProxy(object)) {
              object = object.$target;
            }
            object[property] = [controller];
          } else {
            const index = list.indexOf(controller);
            if (index === -1) {
              list.push(controller);
            }
          }
        }
        unset(object, property, controller) {
          const list = object[property];
          if (!list) {
            return;
          }
          const index = arrayRemove(list, controller);
          if (index === -1) {
            arrayRemove(list, controller.$target);
          }
          if (list.length === 0) {
            delete object[property];
          }
        }
        /**
         * Change the validity state of the form, and notify the parent form (if any).
         *
         * Application developers will rarely need to call this method directly. It is used internally, by
         * {@link ngModel.NgModelController#$setValidity NgModelController.$setValidity()}, to propagate a
         * control's validity state to the parent `FormController`.
         *
         * @param {string} validationErrorKey Name of the validator. The `validationErrorKey` will be
         *        assigned to either `$error[validationErrorKey]` or `$pending[validationErrorKey]` (for
         *        unfulfilled `$asyncValidators`), so that it is available for data-binding. The
         *        `validationErrorKey` should be in camelCase and will get converted into dash-case for
         *        class name. Example: `myError` will result in `ng-valid-my-error` and
         *        `ng-invalid-my-error` classes and can be bound to as `{{ someForm.$error.myError }}`.
         * @param {boolean} state Whether the current state is valid (true), invalid (false), pending
         *        (undefined),  or skipped (null). Pending is used for unfulfilled `$asyncValidators`.
         *        Skipped is used by AngularTS when validators do not run because of parse errors and when
         *        `$asyncValidators` do not run because any of the `$validators` failed.
         * @param {import("../model/model.js").NgModelController | FormController} controller - The controller whose validity state is
         *        triggering the change.
         */
        $setValidity(validationErrorKey, state, controller) {
          let that = this;
          if (isUndefined(state)) {
            createAndSet(this, "$pending", validationErrorKey, controller);
          } else {
            unsetAndCleanup(this, "$pending", validationErrorKey, controller);
          }
          if (!isBoolean(state)) {
            this.unset(this.$error, validationErrorKey, controller);
            this.unset(this.$$success, validationErrorKey, controller);
          } else if (state) {
            this.unset(this.$error, validationErrorKey, controller);
            this.set(this.$$success, validationErrorKey, controller);
          } else {
            this.set(this.$error, validationErrorKey, controller);
            this.unset(this.$$success, validationErrorKey, controller);
          }
          if (this.$pending) {
            cachedToggleClass(this, PENDING_CLASS, true);
            this.$valid = this.$invalid = void 0;
            toggleValidationCss(this, "", null);
          } else {
            cachedToggleClass(this, PENDING_CLASS, false);
            this.$valid = isObjectEmpty(this.$error);
            this.$invalid = !this.$valid;
            toggleValidationCss(this, "", this.$valid);
          }
          let combinedState;
          if (this.$pending && this.$pending[validationErrorKey]) {
            combinedState = void 0;
          } else if (this.$error[validationErrorKey]) {
            combinedState = false;
          } else if (this.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(this, validationErrorKey, combinedState);
          this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
          function createAndSet(ctrl, name2, value, controller2) {
            if (!ctrl[name2]) {
              ctrl[name2] = {};
            }
            that.set(ctrl[name2], value, controller2);
          }
          function unsetAndCleanup(ctrl, name2, value, controller2) {
            if (ctrl[name2]) {
              that.unset(ctrl[name2], value, controller2);
            }
            if (isObjectEmpty(ctrl[name2])) {
              ctrl[name2] = void 0;
            }
          }
          function cachedToggleClass(ctrl, className, switchValue) {
            if (switchValue && !ctrl.$$classCache[className]) {
              ctrl.$$animate.addClass(ctrl.$$element, className);
              ctrl.$$classCache[className] = true;
            } else if (!switchValue && ctrl.$$classCache[className]) {
              ctrl.$$animate.removeClass(ctrl.$$element, className);
              ctrl.$$classCache[className] = false;
            }
          }
          function toggleValidationCss(ctrl, validationErrorKey2, isValid) {
            validationErrorKey2 = validationErrorKey2 ? `-${snakeCase(validationErrorKey2, "-")}` : "";
            cachedToggleClass(
              ctrl,
              VALID_CLASS + validationErrorKey2,
              isValid === true
            );
            cachedToggleClass(
              ctrl,
              INVALID_CLASS + validationErrorKey2,
              isValid === false
            );
          }
        }
      }
      const formDirectiveFactory = function(isNgForm) {
        return [
          "$parse",
          function($parse2) {
            return {
              name: "form",
              restrict: isNgForm ? "EA" : "E",
              require: ["form", "^^?form"],
              // first is the form's own ctrl, second is an optional parent form
              controller: FormController,
              compile: function ngFormCompile(formElement, attr) {
                formElement.classList.add(PRISTINE_CLASS, VALID_CLASS);
                const nameAttr = attr.name ? "name" : isNgForm && attr.ngForm ? "ngForm" : false;
                return {
                  pre: function ngFormPreLink(scope, formElement2, attr2, ctrls) {
                    const controller = ctrls[0];
                    if (!("action" in attr2)) {
                      const handleFormSubmission = function(event) {
                        controller.$commitViewValue();
                        controller.$setSubmitted();
                        event.preventDefault();
                      };
                      formElement2.addEventListener("submit", handleFormSubmission);
                      formElement2.addEventListener("$destroy", () => {
                        setTimeout(
                          () => {
                            formElement2.removeEventListener(
                              "submit",
                              handleFormSubmission
                            );
                          },
                          0,
                          false
                        );
                      });
                    }
                    const parentFormCtrl = ctrls[1] || controller.$$parentForm;
                    parentFormCtrl.$addControl(controller);
                    let setter = nameAttr ? getSetter(controller.$name) : () => {
                    };
                    if (nameAttr) {
                      setter(scope, controller);
                      attr2.$observe(nameAttr, (newValue) => {
                        if (controller.$name === newValue) return;
                        scope.$target[controller.$name] = void 0;
                        controller.$$parentForm.$$renameControl(controller, newValue);
                        if (scope.$target !== controller.$$parentForm && controller.$$parentForm !== nullFormCtrl) ;
                        else {
                          scope.$target[newValue] = controller;
                        }
                      });
                    }
                    formElement2.addEventListener("$destroy", () => {
                      controller.$target.$$parentForm.$removeControl(controller);
                      setter(scope, void 0);
                      extend(controller, nullFormCtrl);
                    });
                  }
                };
              }
            };
            function getSetter(expression) {
              if (expression === "") {
                return $parse2('this[""]').assign;
              }
              return $parse2(expression).assign || (() => {
              });
            }
          }
        ];
      };
      const formDirective = formDirectiveFactory();
      const ngFormDirective = formDirectiveFactory("ngForm");
      const DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
      class NgModelOptionsController {
        static $nonscope = true;
        /* @ignore */
        static $inject = ["$attrs", "$scope"];
        /**
         * @param {import('../../core/compile/attributes.js').Attributes} $attrs
         * @param {import('../../core/scope/scope.js').Scope} $scope
         */
        constructor($attrs, $scope) {
          this.$$attrs = $attrs;
          this.$$scope = $scope;
          this.parentCtrl;
        }
        $onInit() {
          const parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions;
          const modelOptionsDefinition = this.$$scope.$eval(
            this.$$attrs["ngModelOptions"]
          );
          this.$options = parentOptions.createChild(modelOptionsDefinition);
        }
      }
      class ModelOptions {
        static $nonscope = true;
        /**
         * @param {ModelOptionsConfig} options
         */
        constructor(options) {
          this.$$options = options;
        }
        /**
         * Returns the value of the given option
         * @param {string} name the name of the option to retrieve
         * @returns {string|boolean|number|Object.<string, number>} the value of the option   *
         */
        getOption(name2) {
          return this.$$options[name2];
        }
        /**
         * @param {ModelOptionsConfig} options a hash of options for the new child that will override the parent's options
         * @return {ModelOptions} a new `ModelOptions` object initialized with the given options.
         */
        createChild(options) {
          let inheritAll = false;
          options = Object.assign({}, options);
          Object.entries(options).forEach(([key, option]) => {
            if (option === "$inherit") {
              if (key === "*") {
                inheritAll = true;
              } else {
                options[key] = this.$$options[key];
                if (key === "updateOn") {
                  options.updateOnDefault = this.$$options.updateOnDefault;
                }
              }
            } else if (key === "updateOn") {
              options.updateOnDefault = false;
              options[key] = trim(
                /** @type {string} */
                option.replace(DEFAULT_REGEXP, () => {
                  options.updateOnDefault = true;
                  return " ";
                })
              );
            }
          }, this);
          if (inheritAll) {
            delete options["*"];
            defaults$1(options, this.$$options);
          }
          defaults$1(options, defaultModelOptions.$$options);
          return new ModelOptions(options);
        }
      }
      const defaultModelOptions = new ModelOptions({
        updateOn: "",
        updateOnDefault: true,
        debounce: 0,
        getterSetter: false,
        allowInvalid: false
      });
      const ngModelOptionsDirective = function() {
        return {
          restrict: "A",
          // ngModelOptions needs to run before ngModel and input directives
          priority: 10,
          require: { parentCtrl: "?^^ngModelOptions" },
          bindToController: true,
          controller: NgModelOptionsController
        };
      };
      function defaults$1(dst, src) {
        Object.keys(src).forEach((key) => {
          if (!isDefined(dst[key])) {
            dst[key] = src[key];
          }
        });
      }
      const ngModelMinErr = minErr("ngModel");
      class NgModelController {
        static $nonscope = true;
        /* @ignore */
        static $inject = [
          "$scope",
          $injectTokens.$exceptionHandler,
          "$attrs",
          "$element",
          $injectTokens.$parse,
          $injectTokens.$animate,
          $injectTokens.$interpolate
        ];
        /**
         * @param {import('../../core/scope/scope.js').Scope} $scope
         * @param {import('../../services/exception/exception-handler.js').ErrorHandler} $exceptionHandler
         * @param {import('../../core/compile/attributes.js').Attributes} $attr
         * @param {Element} $element
         * @param {import("../../core/parse/interface.ts").ParseService} $parse
         * @param {*} $animate
         * @param {*} $interpolate
         */
        constructor($scope, $exceptionHandler2, $attr, $element, $parse2, $animate, $interpolate) {
          this.$viewValue = Number.NaN;
          this.$modelValue = Number.NaN;
          this.$$rawModelValue = void 0;
          this.$validators = {};
          this.$asyncValidators = {};
          this.$parsers = [];
          this.$formatters = [];
          this.$viewChangeListeners = [];
          this.$untouched = true;
          this.$touched = false;
          this.$pristine = true;
          this.$dirty = false;
          this.$valid = true;
          this.$invalid = false;
          this.$error = {};
          this.$$success = {};
          this.$pending = void 0;
          this.$name = $interpolate($attr["name"] || "", false)($scope);
          this.$$parentForm = nullFormCtrl;
          this.$options = defaultModelOptions;
          this.$$updateEvents = "";
          this.$$updateEventHandler = this.$$updateEventHandler.bind(this);
          this.$$parsedNgModel = $parse2($attr["ngModel"]);
          this.$$parsedNgModelAssign = this.$$parsedNgModel.assign;
          this.$$ngModelGet = this.$$parsedNgModel;
          this.$$ngModelSet = this.$$parsedNgModelAssign;
          this.$$pendingDebounce = null;
          this.$$parserValid = void 0;
          this.$$parserName = "parse";
          this.$$currentValidationRunId = 0;
          this.$$scope = $scope;
          this.$$attr = $attr;
          this.$$element = $element;
          this.$$animate = $animate;
          this.$$parse = $parse2;
          this.$$exceptionHandler = $exceptionHandler2;
          this.$$hasNativeValidators = false;
          this.$$classCache = {};
          const isValid = this.$$element.classList.contains(VALID_CLASS);
          this.$$classCache[VALID_CLASS] = isValid;
          this.$$classCache[INVALID_CLASS] = !isValid;
          this.$$eventRemovers = /* @__PURE__ */ new Set();
          setupModelWatcher(this);
        }
        set(object, property) {
          object[property] = true;
        }
        unset(object, property) {
          delete object[property];
        }
        $setValidity(validationErrorKey, state) {
          let that = this;
          function createAndSet(ctrl, name2, value) {
            if (!ctrl[name2]) {
              ctrl[name2] = {};
            }
            that.set(ctrl[name2], value);
          }
          function unsetAndCleanup(ctrl, name2, value) {
            if (ctrl[name2]) {
              that.unset(ctrl[name2], value);
            }
            if (isObjectEmpty(ctrl[name2])) {
              ctrl[name2] = void 0;
            }
          }
          function cachedToggleClass(ctrl, className, switchValue) {
            if (switchValue && !ctrl.$$classCache[className]) {
              if (hasAnimate(ctrl.$$element)) {
                ctrl.$$animate.addClass(ctrl.$$element, className);
              } else {
                ctrl.$$element.classList.add(className);
              }
              ctrl.$$classCache[className] = true;
            } else if (!switchValue && ctrl.$$classCache[className]) {
              if (hasAnimate(ctrl.$$element)) {
                ctrl.$$animate.removeClass(ctrl.$$element, className);
              } else {
                ctrl.$$element.classList.remove(className);
              }
              ctrl.$$classCache[className] = false;
            }
          }
          function toggleValidationCss(ctrl, validationErrorKey2, isValid) {
            validationErrorKey2 = validationErrorKey2 ? `-${snakeCase(validationErrorKey2, "-")}` : "";
            cachedToggleClass(
              ctrl,
              VALID_CLASS + validationErrorKey2,
              isValid === true
            );
            cachedToggleClass(
              ctrl,
              INVALID_CLASS + validationErrorKey2,
              isValid === false
            );
          }
          if (isUndefined(state)) {
            createAndSet(this, "$pending", validationErrorKey);
          } else {
            unsetAndCleanup(this, "$pending", validationErrorKey);
          }
          if (!isBoolean(state)) {
            delete this.$error[validationErrorKey];
            delete this.$$success[validationErrorKey];
          } else if (state) {
            delete this.$error[validationErrorKey];
            this.set(this.$$success, validationErrorKey);
          } else {
            this.set(this.$error, validationErrorKey);
            delete this.$$success[validationErrorKey];
          }
          if (this.$pending) {
            cachedToggleClass(this, PENDING_CLASS, true);
            this.$valid = this.$invalid = void 0;
            toggleValidationCss(this, "", null);
          } else {
            cachedToggleClass(this, PENDING_CLASS, false);
            this.$valid = isObjectEmpty(this.$error);
            this.$invalid = !this.$valid;
            toggleValidationCss(this, "", this.$valid);
          }
          let combinedState;
          if (this.$pending && this.$pending[validationErrorKey]) {
            combinedState = void 0;
          } else if (this.$error[validationErrorKey]) {
            combinedState = false;
          } else if (this.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(this, validationErrorKey, combinedState);
          this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
        }
        $$initGetterSetters() {
          if (this.$options.getOption("getterSetter")) {
            const invokeModelGetter = this.$$parse(`${this.$$attr["ngModel"]}()`);
            const invokeModelSetter = this.$$parse(`${this.$$attr["ngModel"]}($$$p)`);
            this.$$ngModelGet = ($scope) => {
              let modelValue = this.$$parsedNgModel($scope);
              if (isFunction(modelValue)) {
                modelValue = invokeModelGetter($scope);
              }
              return modelValue;
            };
            this.$$ngModelSet = ($scope, newValue) => {
              if (isFunction(this.$$parsedNgModel($scope))) {
                invokeModelSetter($scope, { $$$p: newValue });
              } else {
                this.$$parsedNgModelAssign($scope, newValue);
              }
            };
          } else if (!this.$$parsedNgModel.assign) {
            throw ngModelMinErr(
              "nonassign",
              "Expression '{0}' is non-assignable. Element: {1}",
              this.$$attr["ngModel"],
              startingTag(this.$$element)
            );
          }
        }
        /**
         * Called when the view needs to be updated. It is expected that the user of the ng-model
         * directive will implement this method.
         *
         * The `$render()` method is invoked in the following situations:
         *
         * * `$rollbackViewValue()` is called.  If we are rolling back the view value to the last
         *   committed value then `$render()` is called to update the input control.
         * * The value referenced by `ng-model` is changed programmatically and both the `$modelValue` and
         *   the `$viewValue` are different from last time.
         *
         * Since `ng-model` does not do a deep watch, `$render()` is only invoked if the values of
         * `$modelValue` and `$viewValue` are actually different from their previous values. If `$modelValue`
         * or `$viewValue` are objects (rather than a string or number) then `$render()` will not be
         * invoked if you only change a property on the objects.
         */
        $render() {
        }
        /**
         * This is called when we need to determine if the value of an input is empty.
         *
         * For instance, the required directive does this to work out if the input has data or not.
         *
         * The default `$isEmpty` function checks whether the value is `undefined`, `''`, `null` or `NaN`.
         *
         * You can override this for input directives whose concept of being empty is different from the
         * default. The `checkboxInputType` directive does this because in its case a value of `false`
         * implies empty.
         *
         * @param {*} value The value of the input to check for emptiness.
         * @returns {boolean} True if `value` is "empty".
         */
        $isEmpty(value) {
          return isUndefined(value) || value === "" || value === null || value !== value;
        }
        $$updateEmptyClasses(value) {
          if (this.$isEmpty(value)) {
            if (hasAnimate(this.$$element)) {
              this.$$animate.removeClass(this.$$element, NOT_EMPTY_CLASS);
              this.$$animate.addClass(this.$$element, EMPTY_CLASS);
            } else {
              this.$$element.classList.remove(NOT_EMPTY_CLASS);
              this.$$element.classList.add(EMPTY_CLASS);
            }
          } else {
            if (hasAnimate(this.$$element)) {
              this.$$animate.removeClass(this.$$element, EMPTY_CLASS);
              this.$$animate.addClass(this.$$element, NOT_EMPTY_CLASS);
            } else {
              this.$$element.classList.remove(EMPTY_CLASS);
              this.$$element.classList.add(NOT_EMPTY_CLASS);
            }
          }
        }
        /**
         * Sets the control to its pristine state.
         *
         * This method can be called to remove the `ng-dirty` class and set the control to its pristine
         * state (`ng-pristine` class). A model is considered to be pristine when the control
         * has not been changed from when first compiled.
         */
        $setPristine() {
          this.$dirty = false;
          this.$pristine = true;
          if (!this.$$element) return;
          if (hasAnimate(this.$$element)) {
            this.$$animate.removeClass(this.$$element, EMPTY_CLASS);
            this.$$animate.addClass(this.$$element, PRISTINE_CLASS);
          } else {
            this.$$element.classList.remove(EMPTY_CLASS);
            this.$$element.classList.add(PRISTINE_CLASS);
          }
        }
        /**
         * Sets the control to its dirty state.
         *
         * This method can be called to remove the `ng-pristine` class and set the control to its dirty
         * state (`ng-dirty` class). A model is considered to be dirty when the control has been changed
         * from when first compiled.
         */
        $setDirty() {
          this.$dirty = true;
          this.$pristine = false;
          if (hasAnimate(this.$$element)) {
            this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
            this.$$animate.addClass(this.$$element, DIRTY_CLASS);
          } else {
            this.$$element.classList.remove(PRISTINE_CLASS);
            this.$$element.classList.add(DIRTY_CLASS);
          }
          this.$$parentForm.$setDirty();
        }
        /**
         * Sets the control to its untouched state.
         *
         * This method can be called to remove the `ng-touched` class and set the control to its
         * untouched state (`ng-untouched` class). Upon compilation, a model is set as untouched
         * by default, however this function can be used to restore that state if the model has
         * already been touched by the user.
         */
        $setUntouched() {
          this.$touched = false;
          this.$untouched = true;
          if (hasAnimate(this.$$element)) {
            this.$$animate.setClass(this.$$element, UNTOUCHED_CLASS, TOUCHED_CLASS);
          } else {
            this.$$element.classList.remove(TOUCHED_CLASS);
            this.$$element.classList.add(UNTOUCHED_CLASS);
          }
        }
        /**
         * Sets the control to its touched state.
         *
         * This method can be called to remove the `ng-untouched` class and set the control to its
         * touched state (`ng-touched` class). A model is considered to be touched when the user has
         * first focused the control element and then shifted focus away from the control (blur event).
         */
        $setTouched() {
          this.$touched = true;
          this.$untouched = false;
          if (hasAnimate(this.$$element)) {
            this.$$animate.setClass(this.$$element, TOUCHED_CLASS, UNTOUCHED_CLASS);
          } else {
            this.$$element.classList.remove(UNTOUCHED_CLASS);
            this.$$element.classList.add(TOUCHED_CLASS);
          }
        }
        /**
             * Cancel an update and reset the input element's value to prevent an update to the `$modelValue`,
             * which may be caused by a pending debounced event or because the input is waiting for some
             * future event.
             *
             * If you have an input that uses `ng-model-options` to set up debounced updates or updates that
             * depend on special events such as `blur`, there can be a period when the `$viewValue` is out of
             * sync with the ngModel's `$modelValue`.
             *
             * In this case, you can use `$rollbackViewValue()` to manually cancel the debounced / future update
             * and reset the input to the last committed view value.
             *
             * It is also possible that you run into difficulties if you try to update the ngModel's `$modelValue`
             * programmatically before these debounced/future events have resolved/occurred, because AngularTS's
             * dirty checking mechanism is not able to tell whether the model has actually changed or not.
             *
             * The `$rollbackViewValue()` method should be called before programmatically changing the model of an
             * input which may have such events pending. This is important in order to make sure that the
             * input field will be updated with the new model value and any pending operations are cancelled.
             *
             * @example
             * <example name="ng-model-cancel-update" module="cancel-update-example">
             *   <file name="app.js">
             *     angular.module('cancel-update-example', [])
             *
             *     .controller('CancelUpdateController', ['$scope', function($scope) {
             *       $scope.model = {value1: '', value2: ''};
             *
             *       $scope.setEmpty = function(e, value, rollback) {
             *         if (e.keyCode === 27) {
             *           e.preventDefault();
             *           if (rollback) {
             *             $scope.myForm[value].$rollbackViewValue();
             *           }
             *           $scope.model[value] = '';
             *         }
             *       };
             *     }]);
             *   </file>
             *   <file name="index.html">
             *     <div ng-controller="CancelUpdateController">
             *       <p>Both of these inputs are only updated if they are blurred. Hitting escape should
             *       empty them. Follow these steps and observe the difference:</p>
             *       <ol>
             *         <li>Type something in the input. You will see that the model is not yet updated</li>
             *         <li>Press the Escape key.
             *           <ol>
             *             <li> In the first example, nothing happens, because the model is already '', and no
             *             update is detected. If you blur the input, the model will be set to the current view.
             *             </li>
             *             <li> In the second example, the pending update is cancelled, and the input is set back
             *             to the last committed view value (''). Blurring the input does nothing.
             *             </li>
             *           </ol>
             *         </li>
             *       </ol>
             *
             *       <form name="myForm" ng-model-options="{ updateOn: 'blur' }">
             *         <div>
             *           <p id="inputDescription1">Without $rollbackViewValue():</p>
             *           <input name="value1" aria-describedby="inputDescription1" ng-model="model.value1"
             *                  ng-keydown="setEmpty($event, 'value1')">
             *           value1: "{{ model.value1 }}"
             *         </div>
             *
             *         <div>
             *           <p id="inputDescription2">With $rollbackViewValue():</p>
             *           <input name="value2" aria-describedby="inputDescription2" ng-model="model.value2"
             *                  ng-keydown="setEmpty($event, 'value2', true)">
             *           value2: "{{ model.value2 }}"
             *         </div>
             *       </form>
             *     </div>
             *   </file>
                 <file name="style.css">
                    div {
                      display: table-cell;
                    }
                    div:nth-child(1) {
                      padding-right: 30px;
                    }
        
                  </file>
             * </example>
             */
        $rollbackViewValue() {
          clearTimeout(this.$$pendingDebounce);
          this.$viewValue = this.$$lastCommittedViewValue;
          this.$render();
        }
        /**
         * Runs each of the registered validators (first synchronous validators and then
         * asynchronous validators).
         * If the validity changes to invalid, the model will be set to `undefined`,
         * unless {@link ngModelOptions `ngModelOptions.allowInvalid`} is `true`.
         * If the validity changes to valid, it will set the model to the last available valid
         * `$modelValue`, i.e. either the last parsed value or the last value set from the scope.
         */
        $validate() {
          if (isNumberNaN(this.$modelValue)) {
            return;
          }
          const viewValue = this.$$lastCommittedViewValue;
          const modelValue = this.$$rawModelValue;
          const prevValid = this.$valid;
          const prevModelValue = this.$modelValue;
          const allowInvalid = this.$options.getOption("allowInvalid");
          const that = this;
          this.$$runValidators(modelValue, viewValue, (allValid) => {
            if (!allowInvalid && prevValid !== allValid) {
              that.$modelValue = allValid ? modelValue : void 0;
              if (that.$modelValue !== prevModelValue) {
                that.$$writeModelToScope();
              }
            }
          });
        }
        $$runValidators(modelValue, viewValue, doneCallback) {
          this.$$currentValidationRunId++;
          const localValidationRunId = this.$$currentValidationRunId;
          const that = this;
          if (!processParseErrors()) {
            validationDone(false);
            return;
          }
          if (!processSyncValidators()) {
            validationDone(false);
            return;
          }
          processAsyncValidators();
          function processParseErrors() {
            const errorKey = that.$$parserName;
            if (isUndefined(that.$$parserValid)) {
              setValidity(errorKey, null);
            } else {
              if (!that.$$parserValid) {
                Object.keys(that.$validators).forEach((name2) => {
                  setValidity(name2, null);
                });
                Object.keys(that.$asyncValidators).forEach((name2) => {
                  setValidity(name2, null);
                });
              }
              setValidity(errorKey, that.$$parserValid);
              return that.$$parserValid;
            }
            return true;
          }
          function processSyncValidators() {
            let syncValidatorsValid = true;
            Object.entries(that.$validators).forEach(([name2, validator]) => {
              const result = Boolean(validator(modelValue, viewValue));
              syncValidatorsValid = syncValidatorsValid && result;
              setValidity(name2, result);
            });
            if (!syncValidatorsValid) {
              Object.keys(that.$asyncValidators).forEach((name2) => {
                setValidity(name2, null);
              });
              return false;
            }
            return true;
          }
          function processAsyncValidators() {
            const validatorPromises = [];
            let allValid = true;
            Object.entries(that.$asyncValidators).forEach(([name2, validator]) => {
              const promise = validator(modelValue, viewValue);
              if (!isPromiseLike(promise)) {
                throw ngModelMinErr(
                  "nopromise",
                  "Expected asynchronous validator to return a promise but got '{0}' instead.",
                  promise
                );
              }
              setValidity(name2, void 0);
              validatorPromises.push(
                promise.then(
                  () => {
                    setValidity(name2, true);
                  },
                  () => {
                    allValid = false;
                    setValidity(name2, false);
                  }
                )
              );
            });
            if (!validatorPromises.length) {
              validationDone(true);
            } else {
              Promise.all(validatorPromises).then(
                () => {
                  validationDone(allValid);
                },
                () => {
                }
              );
            }
          }
          function setValidity(name2, isValid) {
            if (localValidationRunId === that.$$currentValidationRunId) {
              that.$setValidity(name2, isValid);
            }
          }
          function validationDone(allValid) {
            if (localValidationRunId === that.$$currentValidationRunId) {
              doneCallback(allValid);
            }
          }
        }
        /**
         * Commit a pending update to the `$modelValue`.
         *
         * Updates may be pending by a debounced event or because the input is waiting for a some future
         * event defined in `ng-model-options`. this method is rarely needed as `NgModelController`
         * usually handles calling this in response to input events.
         */
        $commitViewValue() {
          clearTimeout(this.$$pendingDebounce);
          if (this.$$lastCommittedViewValue === this.$viewValue && (this.$viewValue !== "" || !this.$$hasNativeValidators)) {
            return;
          }
          if (this.$$lastCommittedViewValue === void 0 && Number.isNaN(this.$viewValue)) {
            return;
          }
          this.$$updateEmptyClasses(this.$viewValue);
          this.$$lastCommittedViewValue = this.$viewValue;
          if (this.$pristine) {
            this.$setDirty();
          }
          this.$$parseAndValidate();
        }
        $$parseAndValidate() {
          let modelValue = this.$$lastCommittedViewValue;
          const that = this;
          this.$$parserValid = isUndefined(modelValue) ? void 0 : true;
          this.$setValidity(this.$$parserName, null);
          this.$$parserName = "parse";
          if (this.$$parserValid) {
            for (let i = 0; i < this.$parsers.length; i++) {
              modelValue = this.$parsers[i](modelValue);
              if (isUndefined(modelValue)) {
                this.$$parserValid = false;
                break;
              }
            }
          }
          if (isNumberNaN(this.$modelValue)) {
            this.$modelValue = this.$$ngModelGet(this.$$scope);
          }
          const prevModelValue = this.$modelValue;
          const allowInvalid = this.$options.getOption("allowInvalid");
          this.$$rawModelValue = modelValue;
          if (allowInvalid) {
            this.$modelValue = modelValue;
            writeToModelIfNeeded();
          }
          this.$$runValidators(
            modelValue,
            this.$$lastCommittedViewValue,
            (allValid) => {
              if (!allowInvalid) {
                that.$modelValue = allValid ? modelValue : void 0;
                writeToModelIfNeeded();
              }
            }
          );
          function writeToModelIfNeeded() {
            if (that.$modelValue != prevModelValue) {
              that.$$writeModelToScope();
            }
          }
        }
        $$writeModelToScope() {
          this.$$ngModelSet(this.$$scope, this.$modelValue);
          Object.values(this.$viewChangeListeners).forEach((listener) => {
            try {
              listener();
            } catch (e) {
              this.$$exceptionHandler(e);
            }
          }, this);
        }
        /**
         * Update the view value.
         *
         * This method should be called when a control wants to change the view value; typically,
         * this is done from within a DOM event handler. For example, the {@link ng.directive:input input}
         * directive calls it when the value of the input changes and {@link ng.directive:select select}
         * calls it when an option is selected.
         *
         * When `$setViewValue` is called, the new `value` will be staged for committing through the `$parsers`
         * and `$validators` pipelines. If there are no special {@link ngModelOptions} specified then the staged
         * value is sent directly for processing through the `$parsers` pipeline. After this, the `$validators` and
         * `$asyncValidators` are called and the value is applied to `$modelValue`.
         * Finally, the value is set to the **expression** specified in the `ng-model` attribute and
         * all the registered change listeners, in the `$viewChangeListeners` list are called.
         *
         * In case the {@link ng.directive:ngModelOptions ngModelOptions} directive is used with `updateOn`
         * and the `default` trigger is not listed, all those actions will remain pending until one of the
         * `updateOn` events is triggered on the DOM element.
         * All these actions will be debounced if the {@link ng.directive:ngModelOptions ngModelOptions}
         * directive is used with a custom debounce for this particular event.
         * Note that a `$digest` is only triggered once the `updateOn` events are fired, or if `debounce`
         * is specified, once the timer runs out.
         *
         * When used with standard inputs, the view value will always be a string (which is in some cases
         * parsed into another type, such as a `Date` object for `input[date]`.)
         * However, custom controls might also pass objects to this method. In this case, we should make
         * a copy of the object before passing it to `$setViewValue`. This is because `ngModel` does not
         * perform a deep watch of objects, it only looks for a change of identity. If you only change
         * the property of the object then ngModel will not realize that the object has changed and
         * will not invoke the `$parsers` and `$validators` pipelines. For this reason, you should
         * not change properties of the copy once it has been passed to `$setViewValue`.
         * Otherwise you may cause the model value on the scope to change incorrectly.
         *
         * <div class="alert alert-info">
         * In any case, the value passed to the method should always reflect the current value
         * of the control. For example, if you are calling `$setViewValue` for an input element,
         * you should pass the input DOM value. Otherwise, the control and the scope model become
         * out of sync. It's also important to note that `$setViewValue` does not call `$render` or change
         * the control's DOM value in any way. If we want to change the control's DOM value
         * programmatically, we should update the `ngModel` scope expression. Its new value will be
         * picked up by the model controller, which will run it through the `$formatters`, `$render` it
         * to update the DOM, and finally call `$validate` on it.
         * </div>
         *
         * @param {*} value value from the view.
         * @param {string} [trigger] Event that triggered the update.
         */
        $setViewValue(value, trigger) {
          this.$viewValue = value;
          if (this.$options?.getOption("updateOnDefault")) {
            this.$$debounceViewValueCommit(trigger);
          }
        }
        $$debounceViewValueCommit(trigger) {
          let debounceDelay = this.$options.getOption("debounce");
          if (isNumber(debounceDelay[trigger])) {
            debounceDelay = debounceDelay[trigger];
          } else if (isNumber(debounceDelay["default"]) && /** @type {string} */
          this.$options.getOption("updateOn").indexOf(
            trigger
          ) === -1) {
            debounceDelay = debounceDelay["default"];
          } else if (isNumber(debounceDelay["*"])) {
            debounceDelay = debounceDelay["*"];
          }
          clearTimeout(this.$$pendingDebounce);
          const that = this;
          if (
            /** @type {number} */
            debounceDelay > 0
          ) {
            this.$$pendingDebounce = setTimeout(
              () => {
                that.$commitViewValue();
              },
              /** @type {number} */
              debounceDelay
            );
          } else {
            this.$commitViewValue();
          }
        }
        /**
         *
         * Override the current model options settings programmatically.
         *
         * The previous `ModelOptions` value will not be modified. Instead, a
         * new `ModelOptions` object will inherit from the previous one overriding
         * or inheriting settings that are defined in the given parameter.
         *
         * See {@link ngModelOptions} for information about what options can be specified
         * and how model option inheritance works.
         *
         * <div class="alert alert-warning">
         * **Note:** this function only affects the options set on the `ngModelController`,
         * and not the options on the {@link ngModelOptions} directive from which they might have been
         * obtained initially.
         * </div>
         *
         * <div class="alert alert-danger">
         * **Note:** it is not possible to override the `getterSetter` option.
         * </div>
         *
         * @param {Object} options a hash of settings to override the previous options
         *
         */
        $overrideModelOptions(options) {
          this.$$removeAllEventListeners();
          this.$options = this.$options.createChild(options);
          this.$$updateEvents = this.$options.$$options.updateOn;
          this.$$setUpdateOnEvents();
        }
        /**
             * Runs the model -> view pipeline on the current
             * {@link ngModel.NgModelController#$modelValue $modelValue}.
             *
             * The following actions are performed by this method:
             *
             * - the `$modelValue` is run through the {@link ngModel.NgModelController#$formatters $formatters}
             * and the result is set to the {@link ngModel.NgModelController#$viewValue $viewValue}
             * - the `ng-empty` or `ng-not-empty` class is set on the element
             * - if the `$viewValue` has changed:
             *   - {@link ngModel.NgModelController#$render $render} is called on the control
             *   - the {@link ngModel.NgModelController#$validators $validators} are run and
             *   the validation status is set.
             *
             * This method is called by ngModel internally when the bound scope value changes.
             * Application developers usually do not have to call this function themselves.
             *
             * This function can be used when the `$viewValue` or the rendered DOM value are not correctly
             * formatted and the `$modelValue` must be run through the `$formatters` again.
             *
             * @example
             * Consider a text input with an autocomplete list (for fruit), where the items are
             * objects with a name and an id.
             * A user enters `ap` and then selects `Apricot` from the list.
             * Based on this, the autocomplete widget will call `$setViewValue({name: 'Apricot', id: 443})`,
             * but the rendered value will still be `ap`.
             * The widget can then call `ctrl.$processModelValue()` to run the model -> view
             * pipeline again, which formats the object to the string `Apricot`,
             * then updates the `$viewValue`, and finally renders it in the DOM.
             *
             * <example module="inputExample" name="ng-model-process">
               <file name="index.html">
                <div ng-controller="inputController" style="display: flex;">
                  <div style="margin-right: 30px;">
                    Search Fruit:
                    <basic-autocomplete items="items" on-select="selectedFruit = item"></basic-autocomplete>
                  </div>
                  <div>
                    Model:<br>
                    <pre>{{selectedFruit | json}}</pre>
                  </div>
                </div>
               </file>
               <file name="app.js">
                angular.module('inputExample', [])
                  .controller('inputController', function($scope) {
                    $scope.items = [
                      {name: 'Apricot', id: 443},
                      {name: 'Clementine', id: 972},
                      {name: 'Durian', id: 169},
                      {name: 'Jackfruit', id: 982},
                      {name: 'Strawberry', id: 863}
                    ];
                  })
                  .component('basicAutocomplete', {
                    bindings: {
                      items: '<',
                      onSelect: '&'
                    },
                    templateUrl: 'autocomplete.html',
                    controller: function($element, $scope) {
                      let that = this;
                      let ngModel;
        
                      that.$postLink = function() {
                        ngModel = $element.querySelectorAll('input').controller('ngModel');
        
                        ngModel.$formatters.push(function(value) {
                          return (value && value.name) || value;
                        });
        
                        ngModel.$parsers.push(function(value) {
                          let match = value;
                          for (let i = 0; i < that.items.length; i++) {
                            if (that.items[i].name === value) {
                              match = that.items[i];
                              break;
                            }
                          }
        
                          return match;
                        });
                      };
        
                      that.selectItem = function(item) {
                        ngModel.$setViewValue(item);
                        ngModel.$processModelValue();
                        that.onSelect({item: item});
                      };
                    }
                  });
               </file>
               <file name="autocomplete.html">
                 <div>
                   <input type="search" ng-model="$ctrl.searchTerm" />
                   <ul>
                     <li ng-repeat="item in $ctrl.items | filter:$ctrl.searchTerm">
                       <button ng-click="$ctrl.selectItem(item)">{{ item.name }}</button>
                     </li>
                   </ul>
                 </div>
               </file>
             * </example>
             *
             */
        $processModelValue() {
          const viewValue = this.$$format();
          if (this.$viewValue !== viewValue) {
            this.$$updateEmptyClasses(viewValue);
            this.$viewValue = this.$$lastCommittedViewValue = viewValue;
            this.$render();
            this.$$runValidators(this.$modelValue, this.$viewValue, () => {
            });
          }
        }
        /**
         * This method is called internally to run the $formatters on the $modelValue
         */
        $$format() {
          const formatters = this.$formatters;
          let idx = formatters.length;
          let viewValue = this.$modelValue;
          while (idx--) {
            viewValue = formatters[idx](viewValue);
          }
          return viewValue;
        }
        /**
         * This method is called internally when the bound scope value changes.
         */
        $$setModelValue(modelValue) {
          this.$modelValue = this.$$rawModelValue = modelValue;
          this.$$parserValid = void 0;
          this.$processModelValue();
        }
        $$removeAllEventListeners() {
          this.$$eventRemovers.forEach((removeCallback) => removeCallback());
          this.$$eventRemovers.clear();
        }
        $$setUpdateOnEvents() {
          if (this.$$updateEvents) {
            this.$$updateEvents.split(" ").forEach((ev) => {
              this.$$element.addEventListener(ev, this.$$updateEventHandler);
              this.$$eventRemovers.add(
                () => this.$$element.removeEventListener(ev, this.$$updateEventHandler)
              );
            });
          }
          this.$$updateEvents = /** @type {string} */
          this.$options.getOption("updateOn");
          if (this.$$updateEvents) {
            this.$$updateEvents.split(" ").forEach((ev) => {
              this.$$element.addEventListener(ev, this.$$updateEventHandler);
              this.$$eventRemovers.add(
                () => this.$$element.removeEventListener(ev, this.$$updateEventHandler)
              );
            });
          }
        }
        $$updateEventHandler(ev) {
          this.$$debounceViewValueCommit(ev && ev.type);
        }
      }
      function setupModelWatcher(ctrl) {
        ctrl.$$scope.$watch("value", () => {
          const modelValue = ctrl.$$ngModelGet(ctrl.$$scope);
          if (modelValue !== ctrl.$modelValue && // checks for NaN is needed to allow setting the model to NaN when there's an asyncValidator
          (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$$setModelValue(modelValue);
          }
        });
      }
      function ngModelDirective() {
        return {
          restrict: "A",
          require: ["ngModel", "^?form", "^?ngModelOptions"],
          controller: NgModelController,
          // Prelink needs to run before any input directive
          // so that we can set the NgModelOptions in NgModelController
          // before anyone else uses it.
          priority: 1,
          compile: (
            /** @param {Element} element  */
            (element) => {
              element.classList.add(PRISTINE_CLASS, UNTOUCHED_CLASS, VALID_CLASS);
              return {
                pre: (scope, _element, attr, ctrls) => {
                  const modelCtrl = ctrls[0];
                  const formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                  const optionsCtrl = ctrls[2];
                  if (optionsCtrl) {
                    modelCtrl.$options = optionsCtrl.$options;
                  }
                  modelCtrl.$$initGetterSetters();
                  formCtrl.$addControl(modelCtrl);
                  attr.$observe("name", (newValue) => {
                    if (modelCtrl.$name !== newValue) {
                      modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                    }
                  });
                  let deregisterWatch = scope.$watch(attr["ngModel"], (val2) => {
                    modelCtrl.$$setModelValue(isProxy(val2) ? val2.$target : val2);
                  });
                  scope.$on("$destroy", () => {
                    modelCtrl.$$parentForm.$removeControl(modelCtrl);
                    deregisterWatch();
                  });
                },
                post: (scope, element2, _attr, ctrls) => {
                  const modelCtrl = ctrls[0];
                  modelCtrl.$$setUpdateOnEvents();
                  function setTouched() {
                    modelCtrl.$setTouched();
                  }
                  element2.addEventListener("blur", () => {
                    if (modelCtrl.$touched) return;
                    setTouched();
                  });
                  modelCtrl.$viewChangeListeners.push(
                    () => scope.$eval(element2.dataset["change"])
                  );
                }
              };
            }
          )
        };
      }
      const ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
      const URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
      const EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
      const NUMBER_REGEXP = /^\s*([-+])?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
      const DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
      const DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      const WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
      const MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
      const TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      const VALIDITY_STATE_PROPERTY = "validity";
      const PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown";
      const PARTIAL_VALIDATION_TYPES = /* @__PURE__ */ new Map();
      "date,datetime-local,month,time,week".split(",").forEach((type) => {
        PARTIAL_VALIDATION_TYPES.set(type, true);
      });
      const inputType = {
        text: textInputType,
        date: createDateInputType(
          "date",
          DATE_REGEXP,
          createDateParser(DATE_REGEXP, ["yyyy", "MM", "dd"])
        ),
        "datetime-local": createDateInputType(
          "datetimelocal",
          DATETIMELOCAL_REGEXP,
          createDateParser(DATETIMELOCAL_REGEXP, [
            "yyyy",
            "MM",
            "dd",
            "HH",
            "mm",
            "ss",
            "sss"
          ])
        ),
        time: createDateInputType(
          "time",
          TIME_REGEXP,
          createDateParser(TIME_REGEXP, ["HH", "mm", "ss", "sss"])
        ),
        week: createDateInputType("week", WEEK_REGEXP, weekParser),
        month: createDateInputType(
          "month",
          MONTH_REGEXP,
          createDateParser(MONTH_REGEXP, ["yyyy", "MM"])
        ),
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        range: rangeInputType,
        checkbox: checkboxInputType,
        hidden: () => {
        },
        button: () => {
        },
        submit: () => {
        },
        reset: () => {
        },
        file: () => {
        }
      };
      function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(
          (value) => ctrl.$isEmpty(value) ? value : value.toString()
        );
      }
      function textInputType(scope, element, attr, ctrl) {
        baseInputType(scope, element, attr, ctrl);
        stringBasedInputType(ctrl);
      }
      function baseInputType(scope, element, attr, ctrl) {
        const type = element.type.toLowerCase();
        let composing = false;
        element.addEventListener("compositionstart", () => {
          composing = true;
        });
        element.addEventListener("compositionend", () => {
          composing = false;
          listener();
        });
        let timeout;
        let listener = function(ev) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          if (composing) return;
          let value = element.value;
          const event = ev && ev.type;
          if (type !== "password" && (!attr.ngTrim || attr.ngTrim !== "false")) {
            value = trim(value);
          }
          if (ctrl.$viewValue !== value || value === "" && ctrl.$$hasNativeValidators) {
            ctrl.$target.$setViewValue(value, event);
          }
        };
        ["input", "change", "paste", "drop", "cut"].forEach((event) => {
          element.addEventListener(event, listener);
        });
        if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
          element.addEventListener(PARTIAL_VALIDATION_EVENTS, function(ev) {
            if (!timeout) {
              const validity = this[VALIDITY_STATE_PROPERTY];
              const origBadInput = validity.badInput;
              const origTypeMismatch = validity.typeMismatch;
              timeout = setTimeout(() => {
                timeout = null;
                if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                  listener(ev);
                }
              });
            }
          });
        }
        ctrl.$render = function() {
          const value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
          if (element.value !== value) {
            element.value = value;
          }
        };
      }
      function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
          return isoWeek;
        }
        function getFirstThursdayOfYear(year) {
          const dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
          return new Date(
            year,
            0,
            (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst
          );
        }
        if (isString(isoWeek)) {
          WEEK_REGEXP.lastIndex = 0;
          const parts = WEEK_REGEXP.exec(isoWeek);
          if (parts) {
            const year = +parts[1];
            const week = +parts[2];
            let hours = 0;
            let minutes = 0;
            let seconds = 0;
            let milliseconds = 0;
            const firstThurs = getFirstThursdayOfYear(year);
            const addDays = (week - 1) * 7;
            if (existingDate) {
              hours = existingDate.getHours();
              minutes = existingDate.getMinutes();
              seconds = existingDate.getSeconds();
              milliseconds = existingDate.getMilliseconds();
            }
            return new Date(
              year,
              0,
              firstThurs.getDate() + addDays,
              hours,
              minutes,
              seconds,
              milliseconds
            );
          }
        }
        return NaN;
      }
      function createDateParser(regexp, mapping) {
        return function(iso, previousDate) {
          let parts;
          let map2;
          if (isDate(iso)) {
            return iso;
          }
          if (isString(iso)) {
            if (iso.charAt(0) === '"' && iso.charAt(iso.length - 1) === '"') {
              iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
              return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
              parts.shift();
              if (previousDate) {
                map2 = {
                  yyyy: previousDate.getFullYear(),
                  MM: previousDate.getMonth() + 1,
                  dd: previousDate.getDate(),
                  HH: previousDate.getHours(),
                  mm: previousDate.getMinutes(),
                  ss: previousDate.getSeconds(),
                  sss: previousDate.getMilliseconds() / 1e3
                };
              } else {
                map2 = { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 };
              }
              Object.entries(parts).forEach(([index, part]) => {
                if (index < mapping.length) {
                  map2[mapping[index]] = +part;
                }
              });
              const date = new Date(
                map2.yyyy,
                map2.MM - 1,
                map2.dd,
                map2.HH,
                map2.mm,
                map2.ss || 0,
                map2.sss * 1e3 || 0
              );
              if (map2.yyyy < 100) {
                date.setFullYear(map2.yyyy);
              }
              return date;
            }
          }
          return NaN;
        };
      }
      const MONTH_INPUT_FORMAT = /\b\d{4}-(0[1-9]|1[0-2])\b/;
      function createDateInputType(type, regexp, parseDate) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $filter, $parse2) {
          badInputChecker(scope, element, attr, ctrl, type);
          baseInputType(scope, element, attr, ctrl);
          let previousDate;
          ctrl.$parsers.push((value) => {
            if (ctrl.$isEmpty(value)) return null;
            if (regexp.test(value)) {
              if (["month", "week", "datetimelocal", "time", "date"].includes(type)) {
                return value;
              }
              return parseDateAndConvertTimeZoneToLocal(value, previousDate);
            }
            ctrl.$$parserName = type;
            return void 0;
          });
          ctrl.$formatters.push(function(value) {
            if (value && !isString(value)) {
              throw ngModelMinErr("datefmt", "Expected `{0}` to be a String", value);
            }
            if (type === "month") {
              if (value == null) {
                return "";
              }
              if (!MONTH_INPUT_FORMAT.test(value)) {
                throw ngModelMinErr(
                  "datefmt",
                  "Expected month `{0}` to be a 'YYYY-DD'",
                  value
                );
              }
            }
            if (type === "week") {
              if (value == null) {
                return "";
              }
              if (!WEEK_REGEXP.test(value)) {
                throw ngModelMinErr(
                  "datefmt",
                  "Expected week `{0}` to be a 'yyyy-Www'",
                  value
                );
              }
            }
            if (type === "datetimelocal") {
              if (value == null) {
                return "";
              }
              if (!DATETIMELOCAL_REGEXP.test(value)) {
                throw ngModelMinErr(
                  "datefmt",
                  "Expected week `{0}` to be a in date time format. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Date_and_time_formats#local_date_and_time_strings",
                  value
                );
              }
            }
            return value;
          });
          if (isDefined(attr.min) || attr.ngMin) {
            let minVal = attr.min || $parse2(attr.ngMin)(scope);
            let parsedMinVal = parseObservedDateValue(
              isProxy(minVal) ? minVal.$target : minVal
            );
            ctrl.$validators.min = function(value) {
              if (type === "month") {
                return isUndefined(parsedMinVal) || parseDate(value) >= parseDate(parsedMinVal);
              }
              return !isValidDate(value) || isUndefined(parsedMinVal) || parseDate(value) >= parsedMinVal;
            };
            attr.$observe("min", (val2) => {
              if (val2 !== minVal) {
                parsedMinVal = parseObservedDateValue(val2);
                minVal = val2;
                ctrl.$validate();
              }
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            let maxVal = attr.max || $parse2(attr.ngMax)(scope);
            let parsedMaxVal = parseObservedDateValue(
              isProxy(maxVal) ? maxVal.$target : maxVal
            );
            ctrl.$validators.max = function(value) {
              if (type === "month") {
                return isUndefined(parsedMaxVal) || parseDate(value) <= parseDate(parsedMaxVal);
              }
              return !isValidDate(value) || isUndefined(parsedMaxVal) || parseDate(value) <= parsedMaxVal;
            };
            attr.$observe("max", (val2) => {
              if (val2 !== maxVal) {
                parsedMaxVal = parseObservedDateValue(val2);
                maxVal = val2;
                ctrl.$validate();
              }
            });
          }
          function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
          }
          function parseObservedDateValue(val2) {
            return isDefined(val2) && !isDate(val2) ? parseDateAndConvertTimeZoneToLocal(val2) || void 0 : val2;
          }
          function parseDateAndConvertTimeZoneToLocal(value, previousDate2) {
            const timezone = ctrl.$options.getOption("timezone");
            let parsedDate = parseDate(value, previousDate2);
            if (!Number.isNaN(parsedDate) && timezone) {
              parsedDate = convertTimezoneToLocal(parsedDate, timezone);
            }
            return parsedDate;
          }
        };
      }
      function badInputChecker(scope, element, attr, ctrl, parserName) {
        const nativeValidation = ctrl.$$hasNativeValidators = isObject(
          element.validity
        );
        if (nativeValidation) {
          ctrl.$parsers.push((value) => {
            const validity = element[VALIDITY_STATE_PROPERTY] || {};
            if (validity.badInput || validity.typeMismatch) {
              ctrl.$$parserName = parserName;
              return void 0;
            }
            return value;
          });
        }
      }
      function numberFormatterParser(ctrl) {
        ctrl.$parsers.push((value) => {
          if (ctrl.$isEmpty(value)) return null;
          if (NUMBER_REGEXP.test(value)) return parseFloat(value);
          ctrl.$$parserName = "number";
          return void 0;
        });
        ctrl.$formatters.push((value) => {
          if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
              throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
            }
            value = value.toString();
          }
          return value;
        });
      }
      function parseNumberAttrVal(val2) {
        if (isDefined(val2) && !isNumber(val2)) {
          val2 = parseFloat(val2);
        }
        return !isNumberNaN(val2) ? val2 : void 0;
      }
      function isNumberInteger(num) {
        return (num | 0) === num;
      }
      function countDecimals(num) {
        const numString = num.toString();
        const decimalSymbolIndex = numString.indexOf(".");
        if (decimalSymbolIndex === -1) {
          if (num > -1 && num < 1) {
            const match = /e-(\d+)$/.exec(numString);
            if (match) {
              return Number(match[1]);
            }
          }
          return 0;
        }
        return numString.length - decimalSymbolIndex - 1;
      }
      function isValidForStep(viewValue, stepBase, step) {
        let value = Number(viewValue);
        const isNonIntegerValue = !isNumberInteger(value);
        const isNonIntegerStepBase = !isNumberInteger(stepBase);
        const isNonIntegerStep = !isNumberInteger(step);
        if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {
          const valueDecimals = isNonIntegerValue ? countDecimals(value) : 0;
          const stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0;
          const stepDecimals = isNonIntegerStep ? countDecimals(step) : 0;
          const decimalCount = Math.max(
            valueDecimals,
            stepBaseDecimals,
            stepDecimals
          );
          const multiplier = 10 ** decimalCount;
          value *= multiplier;
          stepBase *= multiplier;
          step *= multiplier;
          if (isNonIntegerValue) value = Math.round(value);
          if (isNonIntegerStepBase) stepBase = Math.round(stepBase);
          if (isNonIntegerStep) step = Math.round(step);
        }
        return (value - stepBase) % step === 0;
      }
      function numberInputType(scope, element, attr, ctrl, $filter, $parse2) {
        badInputChecker(scope, element, attr, ctrl, "number");
        numberFormatterParser(ctrl);
        baseInputType(scope, element, attr, ctrl);
        let parsedMinVal;
        if (isDefined(attr.min) || attr.ngMin) {
          let minVal = attr.min || $parse2(attr.ngMin)(scope);
          parsedMinVal = parseNumberAttrVal(minVal);
          ctrl.$validators.min = function(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(parsedMinVal) || viewValue >= parsedMinVal;
          };
          attr.$observe("min", (val2) => {
            if (val2 !== minVal) {
              parsedMinVal = parseNumberAttrVal(val2);
              minVal = val2;
              ctrl.$validate();
            }
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          let maxVal = attr.max || $parse2(attr.ngMax)(scope);
          let parsedMaxVal = parseNumberAttrVal(maxVal);
          ctrl.$validators.max = function(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(parsedMaxVal) || viewValue <= parsedMaxVal;
          };
          attr.$observe("max", (val2) => {
            if (val2 !== maxVal) {
              parsedMaxVal = parseNumberAttrVal(val2);
              maxVal = val2;
              ctrl.$validate();
            }
          });
        }
        if (isDefined(attr.step) || attr.ngStep) {
          let stepVal = attr.step || $parse2(attr.ngStep)(scope);
          let parsedStepVal = parseNumberAttrVal(stepVal);
          ctrl.$validators.step = function(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(parsedStepVal) || isValidForStep(viewValue, parsedMinVal || 0, parsedStepVal);
          };
          attr.$observe("step", (val2) => {
            if (val2 !== stepVal) {
              parsedStepVal = parseNumberAttrVal(val2);
              stepVal = val2;
              ctrl.$validate();
            }
          });
        }
      }
      function rangeInputType(scope, element, attr, ctrl) {
        badInputChecker(scope, element, attr, ctrl, "range");
        numberFormatterParser(ctrl);
        baseInputType(scope, element, attr, ctrl);
        const supportsRange = ctrl.$$hasNativeValidators && element.type === "range";
        let minVal = supportsRange ? 0 : void 0;
        let maxVal = supportsRange ? 100 : void 0;
        let stepVal = supportsRange ? 1 : void 0;
        const { validity } = element;
        const hasMinAttr = isDefined(attr.min);
        const hasMaxAttr = isDefined(attr.max);
        const hasStepAttr = isDefined(attr.step);
        const originalRender = ctrl.$render;
        ctrl.$render = supportsRange && isDefined(validity.rangeUnderflow) && isDefined(validity.rangeOverflow) ? (
          // Browsers that implement range will set these values automatically, but reading the adjusted values after
          // $render would cause the min / max validators to be applied with the wrong value
          function rangeRender() {
            originalRender();
            ctrl.$setViewValue(element.value);
          }
        ) : originalRender;
        if (hasMinAttr) {
          minVal = parseNumberAttrVal(attr.min);
          ctrl.$validators.min = supportsRange ? (
            // Since all browsers set the input to a valid value, we don't need to check validity
            function noopMinValidator() {
              return true;
            }
          ) : (
            // non-support browsers validate the min val
            function minValidator(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal;
            }
          );
          setInitialValueAndObserver("min", minChange);
        }
        if (hasMaxAttr) {
          maxVal = parseNumberAttrVal(attr.max);
          ctrl.$validators.max = supportsRange ? (
            // Since all browsers set the input to a valid value, we don't need to check validity
            function noopMaxValidator() {
              return true;
            }
          ) : (
            // non-support browsers validate the max val
            function maxValidator(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || viewValue <= maxVal;
            }
          );
          setInitialValueAndObserver("max", maxChange);
        }
        if (hasStepAttr) {
          stepVal = parseNumberAttrVal(attr.step);
          ctrl.$validators.step = supportsRange ? function nativeStepValidator() {
            return !validity.stepMismatch;
          } : (
            // ngStep doesn't set the setp attr, so the browser doesn't adjust the input value as setting step would
            function stepValidator(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
            }
          );
          setInitialValueAndObserver("step", stepChange);
        }
        function setInitialValueAndObserver(htmlAttrName, changeFn) {
          element.setAttribute(htmlAttrName, attr[htmlAttrName]);
          let oldVal = attr[htmlAttrName];
          attr.$observe(htmlAttrName, (val2) => {
            if (val2 !== oldVal) {
              oldVal = val2;
              changeFn(val2);
            }
          });
        }
        function minChange(val2) {
          minVal = parseNumberAttrVal(val2);
          if (isNumberNaN(ctrl.$modelValue)) {
            return;
          }
          if (supportsRange) {
            let elVal = element.value;
            if (minVal > elVal) {
              elVal = minVal;
              element.value = elVal;
            }
            ctrl.$setViewValue(elVal);
          } else {
            ctrl.$validate();
          }
        }
        function maxChange(val2) {
          maxVal = parseNumberAttrVal(val2);
          if (isNumberNaN(ctrl.$modelValue)) {
            return;
          }
          if (supportsRange) {
            let elVal = element.value;
            if (maxVal < elVal) {
              element.value = maxVal;
              elVal = maxVal < minVal ? minVal : maxVal;
            }
            ctrl.$setViewValue(elVal);
          } else {
            ctrl.$validate();
          }
        }
        function stepChange(val2) {
          stepVal = parseNumberAttrVal(val2);
          if (isNumberNaN(ctrl.$modelValue)) {
            return;
          }
          if (!supportsRange) {
            ctrl.$validate();
          } else if (ctrl.$viewValue !== element.value) {
            ctrl.$setViewValue(element.value);
          }
        }
      }
      function urlInputType(scope, element, attr, ctrl) {
        baseInputType(scope, element, attr, ctrl);
        stringBasedInputType(ctrl);
        ctrl.$validators.url = function(modelValue, viewValue) {
          const value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
      }
      function emailInputType(scope, element, attr, ctrl) {
        baseInputType(scope, element, attr, ctrl);
        stringBasedInputType(ctrl);
        ctrl.$validators.email = function(modelValue, viewValue) {
          const value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
      }
      function radioInputType(scope, element, attr, ctrl) {
        const doTrim = !attr.ngTrim || trim(attr.ngTrim) !== "false";
        if (isUndefined(attr.name)) {
          element.setAttribute("name", nextUid());
        }
        const listener = function(ev) {
          let value;
          if (element.checked) {
            value = attr.value;
            if (doTrim) {
              value = trim(value);
            }
            ctrl.$setViewValue(value, ev && ev.type);
          }
        };
        element.addEventListener("change", listener);
        ctrl.$render = function() {
          let { value } = attr;
          if (doTrim) {
            value = trim(value);
          }
          const deproxy = isProxy(ctrl.$viewValue) ? ctrl.$viewValue.$target : ctrl.$viewValue;
          element.checked = (isProxy(value) ? value.$target : value) === (isProxy(deproxy) ? deproxy.$target : deproxy);
        };
        attr.$observe("value", ctrl.$render);
      }
      function parseConstantExpr($parse2, context, name2, expression, fallback) {
        let parseFn;
        if (isDefined(expression)) {
          parseFn = $parse2(expression);
          if (!parseFn.constant) {
            throw ngModelMinErr(
              "constexpr",
              "Expected constant expression for `{0}`, but saw `{1}`.",
              name2,
              expression
            );
          }
          return parseFn(context);
        }
        return fallback;
      }
      function checkboxInputType(scope, element, attr, ctrl, $filter, $parse2) {
        const trueValue = parseConstantExpr(
          $parse2,
          scope,
          "ngTrueValue",
          attr.ngTrueValue,
          true
        );
        const falseValue = parseConstantExpr(
          $parse2,
          scope,
          "ngFalseValue",
          attr.ngFalseValue,
          false
        );
        const listener = function(ev) {
          ctrl.$setViewValue(element.checked, ev && ev.type);
        };
        element.addEventListener("change", listener);
        ctrl.$render = function() {
          element.checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
          return value === false;
        };
        ctrl.$formatters.push((value) => equals$1(value, trueValue));
        ctrl.$parsers.push((value) => value ? trueValue : falseValue);
      }
      inputDirective.$inject = ["$filter", "$parse"];
      function inputDirective($filter, $parse2) {
        return {
          restrict: "E",
          require: ["?ngModel"],
          link: {
            pre(scope, element, attr, ctrls) {
              if (ctrls[0]) {
                (inputType[lowercase(attr["type"])] || inputType.text)(
                  scope,
                  element,
                  attr,
                  ctrls[0],
                  $filter,
                  $parse2
                );
              }
            }
          }
        };
      }
      function hiddenInputBrowserCacheDirective() {
        const valueProperty = {
          configurable: true,
          enumerable: false,
          get() {
            return this.getAttribute("value") || "";
          },
          set(val2) {
            this.setAttribute("value", val2);
          }
        };
        return {
          restrict: "E",
          priority: 200,
          compile(_, attr) {
            if (lowercase(attr["type"]) !== "hidden") {
              return;
            }
            return {
              pre(scope, element) {
                const node = element;
                if (node.parentNode) {
                  node.parentNode.insertBefore(node, node.nextSibling);
                }
                if (Object.defineProperty) {
                  Object.defineProperty(node, "value", valueProperty);
                }
              }
            };
          }
        };
      }
      const CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
      function ngValueDirective() {
        function updateElementValue(element, attr, value) {
          element["value"] = isDefined(value) ? isProxy(value) ? value.$target : value : null;
          attr.$set("value", value);
        }
        return {
          restrict: "A",
          priority: 100,
          compile(tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr["ngValue"])) {
              return function ngValueConstantLink(scope, elm, attr) {
                const value = scope.$eval(attr["ngValue"]);
                updateElementValue(elm, attr, value);
              };
            }
            return function ngValueLink(scope, elm, attr) {
              scope.$watch(attr["ngValue"], (value) => {
                updateElementValue(elm, attr, value);
              });
            };
          }
        };
      }
      scriptDirective.$inject = ["$templateCache"];
      function scriptDirective($templateCache) {
        return {
          restrict: "E",
          terminal: true,
          compile(element, attr) {
            if (attr["type"] === "text/ng-template") {
              $templateCache.set(attr["id"], element.innerText);
            }
          }
        };
      }
      class SelectController {
        static $nonscope = [
          "ngModelCtrl",
          "selectValueMap",
          "emptyOption",
          "optionsMap",
          "$scope",
          "$element"
        ];
        /**
         * @type {Array<string>}
         */
        /* @ignore */
        static $inject = ["$element", "$scope"];
        /**
         * @param {HTMLSelectElement} $element
         * @param {import('../../core/scope/scope.js').Scope} $scope
         */
        constructor($element, $scope) {
          this.$element = $element;
          this.$scope = $scope;
          this.selectValueMap = {};
          this.ngModelCtrl = {};
          this.multiple = false;
          this.unknownOption = document.createElement("option");
          this.hasEmptyOption = false;
          this.emptyOption = void 0;
          this.optionsMap = /* @__PURE__ */ new Map();
          this.renderScheduled = false;
          this.updateScheduled = false;
          $scope.$on("$destroy", () => {
            this.renderUnknownOption = () => {
            };
          });
        }
        /**
         * Render the unknown option when the viewValue doesn't match any options.
         * @param {*} val
         */
        renderUnknownOption(val2) {
          const unknownVal = this.generateUnknownOptionValue(val2);
          this.unknownOption.value = unknownVal;
          this.$element.prepend(this.unknownOption);
          this.unknownOption.selected = true;
          this.unknownOption.setAttribute("selected", "selected");
          this.$element.value = unknownVal;
        }
        /**
         * Update the unknown option if it's already rendered.
         * @param {*} val
         */
        updateUnknownOption(val2) {
          const unknownVal = this.generateUnknownOptionValue(val2);
          this.unknownOption.value = unknownVal;
          this.unknownOption.selected = true;
          this.unknownOption.setAttribute("selected", "selected");
          this.$element.value = unknownVal;
        }
        /**
         * Generate a special value used for unknown options.
         * @param {*} val
         * @returns {string}
         */
        generateUnknownOptionValue(val2) {
          if (isUndefined(val2)) {
            return `? undefined:undefined ?`;
          }
          return `? ${hashKey(val2)} ?`;
        }
        /**
         * Remove the unknown option from the select element if it exists.
         */
        removeUnknownOption() {
          if (this.unknownOption.parentElement) this.unknownOption.remove();
        }
        /**
         * Select the empty option (value="") if it exists.
         */
        selectEmptyOption() {
          if (this.emptyOption) {
            this.$element.value = "";
            this.emptyOption.selected = true;
            this.emptyOption.setAttribute("selected", "selected");
          }
        }
        /**
         * Unselect the empty option if present.
         */
        unselectEmptyOption() {
          if (this.hasEmptyOption) {
            this.emptyOption.selected = false;
          }
        }
        /**
         * Read the current value from the select element.
         * @returns {*|null}
         */
        readValue() {
          const val2 = this.$element.value;
          const realVal = val2 in this.selectValueMap ? this.selectValueMap[val2] : val2;
          return this.hasOption(realVal) ? realVal : null;
        }
        /**
         * Write a value to the select control.
         * @param {*} value
         */
        writeValue(value) {
          const currentlySelectedOption = this.$element.options[this.$element.selectedIndex];
          if (currentlySelectedOption) currentlySelectedOption.selected = false;
          if (this.hasOption(value)) {
            this.removeUnknownOption();
            const hashedVal = hashKey(value);
            this.$element.value = hashedVal in this.selectValueMap ? hashedVal : value;
            const selectedOption = this.$element.options[this.$element.selectedIndex];
            if (!selectedOption) {
              this.selectUnknownOrEmptyOption(value);
            } else {
              selectedOption.selected = true;
            }
          } else {
            this.selectUnknownOrEmptyOption(value);
          }
        }
        /**
         * Register a new option with the controller.
         * @param {*} value
         * @param {HTMLOptionElement} element
         */
        addOption(value, element) {
          if (element.nodeType === Node.COMMENT_NODE) return;
          assertNotHasOwnProperty(value, '"option value"');
          if (value === "") {
            this.hasEmptyOption = true;
            this.emptyOption = element;
          }
          const count = this.optionsMap.get(value) || 0;
          this.optionsMap.set(value, count + 1);
          this.scheduleRender();
        }
        /**
         * Remove an option from the controller.
         * @param {*} value
         */
        removeOption(value) {
          const count = this.optionsMap.get(value);
          if (count) {
            if (count === 1) {
              this.optionsMap.delete(value);
              if (value === "") {
                this.hasEmptyOption = false;
                this.emptyOption = void 0;
              }
            } else {
              this.optionsMap.set(value, count - 1);
            }
          }
        }
        /**
         * Check if an option exists for the given value.
         * @param {*} value
         * @returns {boolean}
         */
        hasOption(value) {
          return !!this.optionsMap.get(value);
        }
        /**
         * @returns {boolean} Whether the select element currently has an empty option.
         */
        $hasEmptyOption() {
          return this.hasEmptyOption;
        }
        /**
         * @returns {boolean} Whether the unknown option is currently selected.
         */
        $isUnknownOptionSelected() {
          return this.$element.options[0] === this.unknownOption;
        }
        /**
         * @returns {boolean} Whether the empty option is selected.
         */
        $isEmptyOptionSelected() {
          return this.hasEmptyOption && this.$element.options[this.$element.selectedIndex] === this.emptyOption;
        }
        /**
         * Select unknown or empty option depending on the value.
         * @param {*} value
         */
        selectUnknownOrEmptyOption(value) {
          if (value == null && this.emptyOption) {
            this.removeUnknownOption();
            this.selectEmptyOption();
          } else if (this.unknownOption.parentElement) {
            this.updateUnknownOption(value);
          } else {
            this.renderUnknownOption(value);
          }
        }
        /**
         * Schedule a render at the end of the digest cycle.
         */
        scheduleRender() {
          if (this.renderScheduled) return;
          this.renderScheduled = true;
          this.$scope.$postUpdate(() => {
            this.renderScheduled = false;
            this.ngModelCtrl.$render();
          });
        }
        /**
         * Schedule a view value update at the end of the digest cycle.
         * @param {boolean} [renderAfter=false]
         */
        scheduleViewValueUpdate(renderAfter = false) {
          if (this.updateScheduled) return;
          this.updateScheduled = true;
          this.$scope.$postUpdate(() => {
            if (this.$scope.$$destroyed) return;
            this.updateScheduled = false;
            this.ngModelCtrl.$setViewValue(this.readValue());
            if (renderAfter) this.ngModelCtrl.$render();
          });
        }
        /**
         * Register an option with interpolation or dynamic value/text.
         * @param {any} optionScope
         * @param {HTMLOptionElement} optionElement
         * @param {any} optionAttrs
         * @param {Function} [interpolateValueFn]
         * @param {Function} [interpolateTextFn]
         */
        registerOption(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
          let oldVal;
          let hashedVal;
          if (optionAttrs.$attr.ngValue) {
            optionAttrs.$observe("value", (newVal) => {
              let removal;
              const previouslySelected = optionElement.selected;
              if (isDefined(hashedVal)) {
                this.removeOption(oldVal);
                delete this.selectValueMap[hashedVal];
                removal = true;
              }
              hashedVal = hashKey(newVal);
              oldVal = newVal;
              this.selectValueMap[hashedVal] = newVal;
              this.addOption(newVal, optionElement);
              optionElement.setAttribute("value", hashedVal);
              if (removal && previouslySelected) {
                this.scheduleViewValueUpdate();
              }
            });
          } else if (interpolateValueFn) {
            optionAttrs.$observe("value", (newVal) => {
              this.readValue();
              let removal;
              const previouslySelected = optionElement.selected;
              if (isDefined(oldVal)) {
                this.removeOption(oldVal);
                removal = true;
              }
              oldVal = newVal;
              this.addOption(newVal, optionElement);
              if (removal && previouslySelected) {
                this.scheduleViewValueUpdate();
              }
            });
          } else if (interpolateTextFn) {
            optionScope.value = interpolateTextFn(optionScope);
            if (!optionAttrs["value"]) {
              optionAttrs.$set("value", optionScope.value);
              this.addOption(optionScope.value, optionElement);
            }
            let oldVal2;
            optionScope.$watch("value", () => {
              let newVal = interpolateTextFn(optionScope);
              if (!optionAttrs["value"]) {
                optionAttrs.$set("value", newVal);
              }
              const previouslySelected = optionElement.selected;
              if (oldVal2 !== newVal) {
                this.removeOption(oldVal2);
                oldVal2 = newVal;
              }
              this.addOption(newVal, optionElement);
              if (oldVal2 && previouslySelected) {
                this.scheduleViewValueUpdate();
              }
            });
          } else {
            this.addOption(optionAttrs.value, optionElement);
          }
          optionAttrs.$observe("disabled", (newVal) => {
            if (newVal === "true" || newVal && optionElement.selected) {
              if (this.multiple) {
                this.scheduleViewValueUpdate(true);
              } else {
                this.ngModelCtrl.$setViewValue(null);
                this.ngModelCtrl.$render();
              }
            }
          });
          optionElement.addEventListener("$destroy", () => {
            const currentValue = this.readValue();
            const removeValue = optionAttrs.value;
            this.removeOption(removeValue);
            this.scheduleRender();
            if (this.multiple && currentValue && currentValue.indexOf(removeValue) !== -1 || currentValue === removeValue) {
              this.scheduleViewValueUpdate(true);
            }
          });
        }
      }
      function selectDirective() {
        return {
          restrict: "E",
          require: ["select", "?ngModel"],
          controller: SelectController,
          priority: 1,
          link: {
            pre: selectPreLink,
            post: selectPostLink
          }
        };
        function selectPreLink(_scope, element, attr, ctrls) {
          const selectCtrl = ctrls[0];
          const ngModelCtrl = ctrls[1];
          if (!ngModelCtrl) {
            selectCtrl.registerOption = () => {
            };
            return;
          }
          selectCtrl["ngModelCtrl"] = ngModelCtrl;
          element.addEventListener("change", () => {
            selectCtrl.removeUnknownOption();
            const viewValue = selectCtrl.readValue();
            ngModelCtrl.$setViewValue(viewValue);
          });
          if (attr.multiple) {
            selectCtrl.multiple = true;
            selectCtrl.readValue = function() {
              const array = [];
              const options = element.getElementsByTagName("option");
              Array.from(options).forEach(
                /**
                 * @param {HTMLOptionElement} option
                 */
                (option) => {
                  if (option.selected && !option.disabled) {
                    const val2 = option.value;
                    array.push(
                      val2 in selectCtrl.selectValueMap ? selectCtrl.selectValueMap[val2] : val2
                    );
                  }
                }
              );
              return array;
            };
            selectCtrl.writeValue = function(value) {
              const options = element.getElementsByTagName("option");
              Array.from(options).forEach(
                /**
                 * @param {HTMLOptionElement} option
                 */
                (option) => {
                  const shouldBeSelected = !!value && (includes(value, option.value) || includes(value, selectCtrl.selectValueMap[option.value]));
                  const currentlySelected = option.selected;
                  if (shouldBeSelected !== currentlySelected) {
                    option.selected = shouldBeSelected;
                  }
                }
              );
            };
            let lastView;
            let lastViewRef = NaN;
            if (lastViewRef === ngModelCtrl.$viewValue && !equals$1(lastView, ngModelCtrl.$viewValue)) {
              lastView = shallowCopy(ngModelCtrl.$viewValue);
              ngModelCtrl.$render();
            }
            lastViewRef = ngModelCtrl.$viewValue;
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
          }
        }
        function selectPostLink(_scope, _element, _attrs, ctrls) {
          const ngModelCtrl = ctrls[1];
          if (!ngModelCtrl) return;
          const selectCtrl = ctrls[0];
          ngModelCtrl.$render = function() {
            selectCtrl.writeValue(ngModelCtrl.$viewValue);
          };
        }
      }
      optionDirective.$inject = ["$interpolate"];
      function optionDirective($interpolate) {
        return {
          restrict: "E",
          priority: 100,
          compile(element, attr) {
            let interpolateValueFn;
            let interpolateTextFn;
            if (isDefined(attr.ngValue)) ;
            else if (isDefined(attr.value)) {
              interpolateValueFn = $interpolate(attr.value, true);
            } else {
              interpolateTextFn = $interpolate(element.textContent, true);
              if (!interpolateTextFn) {
                attr.$set("value", element.textContent);
              }
            }
            return function(scope, element2, attr2) {
              const selectCtrlName = "$selectController";
              const parent = element2.parentElement;
              const selectCtrl = getCacheData(parent, selectCtrlName) || getCacheData(parent.parentElement, selectCtrlName);
              if (selectCtrl) {
                selectCtrl.registerOption(
                  scope,
                  element2,
                  attr2,
                  interpolateValueFn,
                  interpolateTextFn
                );
              }
            };
          }
        };
      }
      function ngBindDirective() {
        return {
          /**
           * @param {import('../../core/scope/scope.js').Scope} scope
           * @param {Element} element
           * @param {import('../../core/compile/attributes.js').Attributes} attr
           */
          link(scope, element, attr) {
            scope.$watch(
              attr["ngBind"],
              (value) => {
                element.textContent = stringify$1(
                  isProxy(value) ? value.$target : value
                );
              },
              isDefined(attr["lazy"])
            );
          }
        };
      }
      function ngBindTemplateDirective() {
        return {
          /**
           * @param {import('../../core/scope/scope.js').Scope} _scope
           * @param {Element} element
           * @param {import('../../core/compile/attributes.js').Attributes} attr
           */
          link(_scope, element, attr) {
            attr.$observe("ngBindTemplate", (value) => {
              element.textContent = isUndefined(value) ? "" : value;
            });
          }
        };
      }
      ngBindHtmlDirective.$inject = [$injectTokens.$parse];
      function ngBindHtmlDirective($parse2) {
        return {
          restrict: "A",
          compile(_tElement, tAttrs) {
            $parse2(tAttrs["ngBindHtml"]);
            return (
              /**
               * @param {import('../../core/scope/scope.js').Scope} scope
               * @param {Element} element
               */
              ((scope, element) => {
                scope.$watch(tAttrs["ngBindHtml"], (val2) => {
                  if (isUndefined(val2) || isNull(val2)) {
                    val2 = "";
                  }
                  element.innerHTML = val2;
                });
              })
            );
          }
        };
      }
      function classDirective(name2, selector) {
        name2 = `ngClass${name2}`;
        return function() {
          return {
            /**
             * @param {import("../../core/scope/scope.js").Scope} scope
             * @param {Element} element
             * @param {import("../../core/compile/attributes").Attributes} attr
             */
            link(scope, element, attr) {
              let classCounts = getCacheData(element, "$classCounts");
              let oldModulo = true;
              let oldClassString;
              if (!classCounts) {
                classCounts = /* @__PURE__ */ Object.create(null);
                setCacheData(element, "$classCounts", classCounts);
              }
              if (name2 !== "ngClass") {
                scope.$watch("$index", () => {
                  ngClassIndexWatchAction(scope["$index"] & 1);
                });
              }
              scope.$watch(attr[name2], (val2) => {
                ngClassWatchAction(toClassString(val2));
              });
              function addClasses(classString) {
                classString = digestClassCounts(split(classString), 1);
                if (hasAnimate(element)) {
                  attr.$addClass(classString);
                } else {
                  scope.$postUpdate(() => {
                    if (classString !== "") {
                      element.classList.add(...classString.trim().split(" "));
                    }
                  });
                }
              }
              function removeClasses(classString) {
                classString = digestClassCounts(split(classString), -1);
                if (hasAnimate(element)) {
                  attr.$removeClass(classString);
                } else {
                  scope.$postUpdate(() => {
                    if (classString !== "") {
                      element.classList.remove(...classString.trim().split(" "));
                    }
                  });
                }
              }
              function updateClasses(oldClassString2, newClassString) {
                const oldClassArray = split(oldClassString2);
                const newClassArray = split(newClassString);
                const toRemoveArray = arrayDifference(oldClassArray, newClassArray);
                const toAddArray = arrayDifference(newClassArray, oldClassArray);
                const toRemoveString = digestClassCounts(toRemoveArray, -1);
                const toAddString = digestClassCounts(toAddArray, 1);
                if (hasAnimate(element)) {
                  attr.$addClass(toAddString);
                  attr.$removeClass(toRemoveString);
                } else {
                  if (toAddString !== "") {
                    element.classList.add(...toAddString.trim().split(" "));
                  }
                  if (toRemoveString !== "") {
                    element.classList.remove(...toRemoveString.trim().split(" "));
                  }
                }
              }
              function digestClassCounts(classArray, count) {
                const classesToUpdate = [];
                if (classArray) {
                  classArray.forEach((className) => {
                    if (count > 0 || classCounts[className]) {
                      classCounts[className] = (classCounts[className] || 0) + count;
                      if (classCounts[className] === +(count > 0)) {
                        classesToUpdate.push(className);
                      }
                    }
                  });
                }
                return classesToUpdate.join(" ");
              }
              function ngClassIndexWatchAction(newModulo) {
                if (newModulo === selector) {
                  addClasses(oldClassString);
                } else {
                  removeClasses(oldClassString);
                }
                oldModulo = newModulo;
              }
              function ngClassWatchAction(newClassString) {
                if (oldModulo === selector) {
                  updateClasses(oldClassString, newClassString);
                }
                oldClassString = newClassString;
              }
            }
          };
        };
      }
      function arrayDifference(tokens1, tokens2) {
        if (!tokens1 || !tokens1.length) return [];
        if (!tokens2 || !tokens2.length) return tokens1;
        const values = [];
        outer: for (let i = 0; i < tokens1.length; i++) {
          const token = tokens1[i];
          for (let j = 0; j < tokens2.length; j++) {
            if (token === tokens2[j]) continue outer;
          }
          values.push(token);
        }
        return values;
      }
      function split(classString) {
        return classString && classString.split(" ");
      }
      function toClassString(classValue) {
        if (!classValue) return classValue;
        let classString = classValue;
        if (Array.isArray(classValue)) {
          classString = classValue.map(toClassString).join(" ");
        } else if (isObject(classValue)) {
          classString = Object.keys(classValue).filter((key) => classValue[key]).join(" ");
        } else if (!isString(classValue)) {
          classString = `${classValue}`;
        }
        return classString;
      }
      const ngClassDirective = classDirective("", true);
      const ngClassOddDirective = classDirective("Odd", 0);
      const ngClassEvenDirective = classDirective("Even", 1);
      function ngCloakDirective() {
        return {
          compile(element, attr) {
            attr.$set("ngCloak", void 0);
            element.classList.remove("ng-cloak");
          }
        };
      }
      function ngControllerDirective() {
        return {
          restrict: "A",
          scope: true,
          controller: "@",
          priority: 500
        };
      }
      const NG_HIDE_CLASS = "ng-hide";
      const NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate";
      ngShowDirective.$inject = ["$animate"];
      function ngShowDirective($animate) {
        return {
          restrict: "A",
          /**
           * @param scope
           * @param {Element} element
           * @param $attr
           */
          link(scope, element, $attr) {
            scope.$watch($attr["ngShow"], (value) => {
              if (hasAnimate(element)) {
                $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {
                  tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                });
              } else {
                if (value) {
                  element.classList.remove(NG_HIDE_CLASS);
                } else {
                  element.classList.add(NG_HIDE_CLASS);
                }
              }
            });
          }
        };
      }
      ngHideDirective.$inject = ["$animate"];
      function ngHideDirective($animate) {
        return {
          restrict: "A",
          link(scope, element, attr) {
            scope.$watch(attr["ngHide"], (value) => {
              if (hasAnimate(element)) {
                $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {
                  tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                });
              } else {
                if (value) {
                  element.classList.add(NG_HIDE_CLASS);
                } else {
                  element.classList.remove(NG_HIDE_CLASS);
                }
              }
            });
          }
        };
      }
      ngIfDirective.$inject = ["$animate"];
      function ngIfDirective($animate) {
        return {
          transclude: "element",
          priority: 600,
          terminal: true,
          restrict: "A",
          /**
           *
           * @param {import("../../core/scope/scope.js").Scope} $scope
           * @param {Element} $element
           * @param {import("../../core/compile/attributes.js").Attributes} $attr
           * @param {Object} _ctrl
           * @param {*} $transclude
           */
          link($scope, $element, $attr, _ctrl, $transclude) {
            let block;
            let childScope;
            let previousElements;
            $scope.$watch($attr["ngIf"], (value) => {
              if (value) {
                if (!childScope) {
                  $transclude((clone, newScope) => {
                    childScope = newScope;
                    block = clone;
                    if (hasAnimate(clone)) {
                      $animate.enter(clone, $element.parentElement, $element);
                    } else {
                      $element.after(clone);
                    }
                  });
                }
              } else {
                if (previousElements) {
                  removeElement(previousElements);
                  previousElements = null;
                }
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                if (block) {
                  previousElements = block;
                  if (hasAnimate(previousElements)) {
                    $animate.leave(previousElements).done((response) => {
                      if (response !== false) previousElements = null;
                    });
                  } else {
                    $element.nextElementSibling.remove();
                  }
                  block = null;
                }
              }
            });
          }
        };
      }
      ngIncludeDirective.$inject = [
        $injectTokens.$templateRequest,
        $injectTokens.$anchorScroll,
        $injectTokens.$animate,
        $injectTokens.$exceptionHandler
      ];
      function ngIncludeDirective($templateRequest, $anchorScroll, $animate, $exceptionHandler2) {
        return {
          priority: 400,
          terminal: true,
          transclude: "element",
          controller: () => {
          },
          compile(_element, attr) {
            const srcExp = attr["ngInclude"] || attr["src"];
            const onloadExp = attr["onload"] || "";
            const autoScrollExp = attr["autoscroll"];
            return (scope, $element, _$attr, ctrl, $transclude) => {
              function maybeScroll() {
                if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                  $anchorScroll();
                }
              }
              let changeCounter = 0;
              let currentScope;
              let previousElement;
              let currentElement;
              const cleanupLastIncludeContent = () => {
                if (previousElement) {
                  previousElement.remove();
                  previousElement = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentElement) {
                  if (hasAnimate(currentElement)) {
                    $animate.leave(currentElement).done((response) => {
                      if (response !== false) previousElement = null;
                    });
                  } else {
                    currentElement.remove();
                  }
                  previousElement = currentElement;
                  currentElement = null;
                }
              };
              scope.$watch(srcExp, async (src) => {
                const afterAnimation = function(response) {
                  response !== false && maybeScroll();
                };
                const thisChangeId = ++changeCounter;
                if (src) {
                  await $templateRequest(src, true).then(
                    (response) => {
                      if (scope.$$destroyed) return;
                      if (thisChangeId !== changeCounter) return;
                      const newScope = scope.$new();
                      ctrl["template"] = response;
                      const clone = $transclude(newScope, (clone2) => {
                        cleanupLastIncludeContent();
                        if (hasAnimate(clone2)) {
                          $animate.enter(clone2, null, $element).done(afterAnimation);
                        } else {
                          $element.after(clone2);
                          maybeScroll();
                        }
                      });
                      currentScope = newScope;
                      currentElement = clone;
                      currentScope.$emit("$includeContentLoaded", src);
                      scope.$eval(onloadExp);
                    },
                    (err2) => {
                      if (scope.$$destroyed) return;
                      if (thisChangeId === changeCounter) {
                        cleanupLastIncludeContent();
                        scope.$emit("$includeContentError", src);
                      }
                      $exceptionHandler2(new Error(err2));
                    }
                  );
                  scope.$emit("$includeContentRequested", src);
                } else {
                  cleanupLastIncludeContent();
                  ctrl["template"] = null;
                }
              });
            };
          }
        };
      }
      ngIncludeFillContentDirective.$inject = [$injectTokens.$compile];
      function ngIncludeFillContentDirective($compile) {
        return {
          priority: -400,
          require: "ngInclude",
          link(scope, $element, _$attr, ctrl) {
            $element.innerHTML = ctrl["template"];
            $compile($element.childNodes)(scope);
          }
        };
      }
      function ngInitDirective() {
        return {
          priority: 450,
          compile() {
            return {
              pre(scope, element, attrs) {
                const controller = getController(element);
                if (controller) {
                  controller.$eval(attrs["ngInit"]);
                } else {
                  scope.$eval(attrs["ngInit"]);
                }
              }
            };
          }
        };
      }
      function ngNonBindableDirective() {
        return {
          terminal: true,
          priority: 1e3
        };
      }
      const ngRefMinErr = minErr("ngRef");
      ngRefDirective.$inject = ["$parse"];
      function ngRefDirective($parse2) {
        return {
          priority: -1,
          // Needed for compatibility with element transclusion on the same element
          restrict: "A",
          compile(tElement, tAttrs) {
            const controllerName = directiveNormalize(getNodeName(tElement));
            const getter = $parse2(tAttrs.ngRef);
            const setter = getter.assign || function() {
              throw ngRefMinErr(
                "nonassign",
                'Expression in ngRef="{0}" is non-assignable!',
                tAttrs.ngRef
              );
            };
            return (scope, element, attrs) => {
              let refValue;
              if (hasOwn(attrs, "ngRefRead")) {
                if (attrs.ngRefRead === "$element") {
                  refValue = element;
                } else {
                  refValue = getCacheData(element, `$${attrs.ngRefRead}Controller`);
                  if (!refValue) {
                    throw ngRefMinErr(
                      "noctrl",
                      'The controller for ngRefRead="{0}" could not be found on ngRef="{1}"',
                      attrs.ngRefRead,
                      tAttrs.ngRef
                    );
                  }
                }
              } else {
                refValue = getCacheData(element, `$${controllerName}Controller`);
              }
              refValue = refValue || element;
              setter(scope, refValue);
              element.addEventListener("$destroy", () => {
                if (getter(scope) === refValue) {
                  setter(scope, null);
                }
              });
            };
          }
        };
      }
      const NG_REMOVED = "$$NG_REMOVED";
      const ngRepeatMinErr = minErr("ngRepeat");
      const VAR_OR_TUPLE_REGEX = /^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/;
      ngRepeatDirective.$inject = [$injectTokens.$animate];
      function ngRepeatDirective($animate) {
        function updateScope(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
          if (scope[valueIdentifier] !== value) {
            scope[valueIdentifier] = value;
          }
          if (keyIdentifier) scope[keyIdentifier] = key;
          if (value) {
            scope.$target.$$hashKey = value.$$hashKey;
          }
          scope.$index = index;
          scope.$first = index === 0;
          scope.$last = index === arrayLength - 1;
          scope.$middle = !(scope.$first || scope.$last);
          scope.$odd = !(scope.$even = (index & 1) === 0);
        }
        function getBlockStart(block) {
          return block.clone;
        }
        function getBlockEnd(block) {
          return block.clone;
        }
        function trackByIdArrayFn(_$scope, _key, value) {
          return hashKey(value);
        }
        function trackByIdObjFn(_$scope, key) {
          return key;
        }
        return {
          restrict: "A",
          transclude: "element",
          priority: 1e3,
          terminal: true,
          compile: (_$element, $attr) => {
            const expression = $attr["ngRepeat"];
            const hasAnimate2 = !!$attr["animate"];
            let match = expression.match(
              /^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/
            );
            if (!match) {
              throw ngRepeatMinErr(
                "iexp",
                "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
                expression
              );
            }
            const lhs = match[1];
            const rhs = match[2];
            const aliasAs = match[3];
            match = lhs.match(VAR_OR_TUPLE_REGEX);
            if (!match) {
              throw ngRepeatMinErr(
                "iidexp",
                "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.",
                lhs
              );
            }
            const valueIdentifier = match[3] || match[1];
            const keyIdentifier = match[2];
            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(
              aliasAs
            ))) {
              throw ngRepeatMinErr(
                "badident",
                "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.",
                aliasAs
              );
            }
            const swap = callBackOnce(() => {
              if (isDefined($attr["lazy"]) && isDefined($attr["swap"])) {
                document.querySelectorAll($attr["swap"]).forEach((x) => removeElement(x));
              }
            });
            return function ngRepeatLink($scope, $element, $attr2, ctrl, $transclude) {
              let lastBlockMap = /* @__PURE__ */ Object.create(null);
              $scope.$watch(
                rhs,
                (collection) => {
                  swap();
                  let index, length, previousNode = $element, nextNode;
                  const nextBlockMap = /* @__PURE__ */ Object.create(null);
                  let collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove;
                  if (aliasAs) {
                    $scope[aliasAs] = collection;
                  }
                  if (isArrayLike(collection)) {
                    collectionKeys = collection;
                    trackByIdFn = trackByIdArrayFn;
                  } else {
                    trackByIdFn = trackByIdObjFn;
                    collectionKeys = [];
                    for (const itemKey in collection) {
                      if (hasOwn(collection, itemKey) && itemKey.charAt(0) !== "$") {
                        collectionKeys.push(itemKey);
                      }
                    }
                  }
                  collectionLength = collectionKeys.length;
                  nextBlockOrder = new Array(collectionLength);
                  for (index = 0; index < collectionLength; index++) {
                    key = collection === collectionKeys ? index : collectionKeys[index];
                    value = collection[key];
                    trackById = trackByIdFn($scope, key, value);
                    if (lastBlockMap[trackById]) {
                      block = lastBlockMap[trackById];
                      delete lastBlockMap[trackById];
                      nextBlockMap[trackById] = block;
                      nextBlockOrder[index] = block;
                    } else if (nextBlockMap[trackById]) {
                      Object.values(nextBlockOrder).forEach((block2) => {
                        if (block2 && block2.scope) lastBlockMap[block2.id] = block2;
                      });
                      throw ngRepeatMinErr(
                        "dupes",
                        "Duplicates keys in a repeater are not allowed. Repeater: {0}, Duplicate key: {1} for value: {2}",
                        expression,
                        trackById,
                        value
                      );
                    } else {
                      nextBlockOrder[index] = {
                        id: trackById,
                        scope: void 0,
                        clone: void 0
                      };
                      nextBlockMap[trackById] = true;
                    }
                  }
                  for (let blockKey in lastBlockMap) {
                    block = lastBlockMap[blockKey];
                    elementsToRemove = block.clone;
                    if (hasAnimate2) {
                      $animate.leave(elementsToRemove);
                    } else {
                      elementsToRemove.remove();
                    }
                    if (elementsToRemove.parentNode) {
                      for (index = 0, length = elementsToRemove.length; index < length; index++) {
                        elementsToRemove[index][NG_REMOVED] = true;
                      }
                    }
                    block.scope.$destroy();
                  }
                  for (index = 0; index < collectionLength; index++) {
                    key = collection === collectionKeys ? index : collectionKeys[index];
                    value = collection[key];
                    block = nextBlockOrder[index];
                    if (block.scope) {
                      nextNode = previousNode;
                      do {
                        nextNode = nextNode.nextSibling;
                      } while (nextNode && nextNode[NG_REMOVED]);
                      if (getBlockStart(block) !== nextNode) {
                        $animate.move(getBlockNodes(block.clone), null, previousNode);
                      }
                      previousNode = getBlockEnd(block);
                      updateScope(
                        block.scope,
                        index,
                        valueIdentifier,
                        value,
                        keyIdentifier,
                        key,
                        collectionLength
                      );
                    } else {
                      $transclude(
                        /**
                         * Clone attach function
                         * @param {Array<NodeList>} clone
                         * @param {import("../../core/scope/scope.js").Scope} scope
                         */
                        (clone, scope) => {
                          block.scope = scope;
                          const endNode = clone;
                          if (hasAnimate2) {
                            $animate.enter(clone, null, previousNode);
                          } else {
                            previousNode.after(clone);
                          }
                          previousNode = endNode;
                          block.clone = clone;
                          nextBlockMap[block.id] = block;
                          updateScope(
                            block.scope,
                            index,
                            valueIdentifier,
                            value,
                            keyIdentifier,
                            key,
                            collectionLength
                          );
                        }
                      );
                    }
                  }
                  lastBlockMap = nextBlockMap;
                },
                isDefined($attr2["lazy"])
              );
            };
          }
        };
      }
      function ngStyleDirective() {
        return {
          restrict: "A",
          link(scope, element, attr) {
            let oldStyles;
            scope.$watch(attr["ngStyle"], (newStyles) => {
              if (oldStyles) {
                const oldKeys = Object.keys(oldStyles);
                for (let i = 0, length = oldKeys.length; i < length; i++) {
                  element.style.removeProperty(oldKeys[i]);
                }
              }
              if (newStyles) {
                oldStyles = { ...newStyles.$target };
                const newEntries = Object.entries(newStyles);
                for (let i = 0, length = newEntries.length; i < length; i++) {
                  const [key, value] = newEntries[i];
                  element.style.setProperty(key, value);
                }
              }
            });
          }
        };
      }
      ngSwitchDirective.$inject = ["$animate"];
      function ngSwitchDirective($animate) {
        return {
          require: "ngSwitch",
          // asks for $scope to fool the BC controller module
          controller: [
            "$scope",
            class {
              constructor() {
                this.cases = {};
              }
            }
          ],
          link(scope, _element, attr, ngSwitchController) {
            const watchExpr = attr["ngSwitch"] || attr["on"];
            let selectedTranscludes = [];
            const selectedElements = [];
            const previousLeaveAnimations = [];
            const selectedScopes = [];
            const spliceFactory = function(array, index) {
              return function(response) {
                if (response !== false) array.splice(index, 1);
              };
            };
            scope.$watch(watchExpr, (value) => {
              let i;
              let ii;
              while (previousLeaveAnimations.length) {
                $animate.cancel(previousLeaveAnimations.pop());
              }
              for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                const selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                if (hasAnimate(selected)) {
                  const runner = previousLeaveAnimations[i] = $animate.leave(selected);
                  runner.done(spliceFactory(previousLeaveAnimations, i));
                } else {
                  selected.remove();
                }
              }
              selectedElements.length = 0;
              selectedScopes.length = 0;
              if (selectedTranscludes = ngSwitchController["cases"][`!${value}`] || ngSwitchController["cases"]["?"]) {
                Object.values(selectedTranscludes).forEach((selectedTransclude) => {
                  selectedTransclude.transclude((caseElement, selectedScope) => {
                    selectedScopes.push(selectedScope);
                    const anchor = selectedTransclude.element;
                    const block = {
                      clone: caseElement,
                      comment: document.createComment("")
                    };
                    selectedElements.push(block);
                    if (hasAnimate(caseElement)) {
                      $animate.enter(caseElement, anchor.parentElement, anchor);
                    } else {
                      domInsert(caseElement, anchor.parentElement, anchor);
                    }
                  });
                });
              }
            });
          }
        };
      }
      function ngSwitchWhenDirective() {
        return {
          transclude: "element",
          terminal: true,
          priority: 1200,
          require: "^ngSwitch",
          link(scope, element, attrs, ctrl, $transclude) {
            const cases = attrs["ngSwitchWhen"].split(attrs["ngSwitchWhenSeparator"]).sort().filter(
              // Filter duplicate cases
              (element2, index, array) => array[index - 1] !== element2
            );
            cases.forEach((whenCase) => {
              ctrl["cases"][`!${whenCase}`] = ctrl["cases"][`!${whenCase}`] || [];
              ctrl["cases"][`!${whenCase}`].push({
                transclude: $transclude,
                element
              });
            });
          }
        };
      }
      function ngSwitchDefaultDirective() {
        return {
          transclude: "element",
          terminal: true,
          priority: 1200,
          require: "^ngSwitch",
          link(_scope, element, _attr, ctrl, $transclude) {
            ctrl["cases"]["?"] = ctrl["cases"]["?"] || [];
            ctrl["cases"]["?"].push({ transclude: $transclude, element });
          }
        };
      }
      const ngOptionsMinErr = minErr("ngOptions");
      const optionTemplate = document.createElement("option");
      const optGroupTemplate = document.createElement("optgroup");
      const NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      ngOptionsDirective.$inject = ["$compile", "$parse"];
      function ngOptionsDirective($compile, $parse2) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
          const match = optionsExp.match(NG_OPTIONS_REGEXP);
          if (!match) {
            throw ngOptionsMinErr(
              "iexp",
              "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}",
              optionsExp,
              startingTag(selectElement)
            );
          }
          const valueName = match[5] || match[7];
          const keyName = match[6];
          const selectAs = / as /.test(match[0]) && match[1];
          const trackBy = match[9];
          const valueFn = $parse2(match[2] ? match[1] : valueName);
          const selectAsFn = selectAs && $parse2(selectAs);
          const viewValueFn = selectAsFn || valueFn;
          const trackByFn = trackBy && $parse2(trackBy);
          const getTrackByValueFn = trackBy ? function(value, locals2) {
            return trackByFn(scope, locals2);
          } : function getHashOfValue(value) {
            return hashKey(value);
          };
          const getTrackByValue = function(value, key) {
            return getTrackByValueFn(value, getLocals2(value, key));
          };
          const displayFn = $parse2(match[2] || match[1]);
          const groupByFn = $parse2(match[3] || "");
          const disableWhenFn = $parse2(match[4] || "");
          const valuesFn = $parse2(match[8]);
          const locals = {};
          let getLocals2 = keyName ? function(value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          } : function(value) {
            locals[valueName] = value;
            return locals;
          };
          class Option {
            constructor(selectValue, viewValue, label, group, disabled) {
              this.selectValue = selectValue;
              this.viewValue = viewValue;
              this.label = label;
              this.group = group;
              this.disabled = disabled;
            }
          }
          function getOptionValuesKeys(optionValues) {
            let optionValuesKeys;
            if (!keyName && isArrayLike(optionValues)) {
              optionValuesKeys = optionValues;
            } else {
              optionValuesKeys = [];
              for (const itemKey in optionValues) {
                if (hasOwn(optionValues, itemKey) && itemKey.charAt(0) !== "$") {
                  optionValuesKeys.push(itemKey);
                }
              }
            }
            return optionValuesKeys;
          }
          return {
            trackBy,
            getTrackByValue,
            getWatchables: $parse2(valuesFn, (optionValues) => {
              const watchedArray = [];
              optionValues = optionValues || [];
              const optionValuesKeys = getOptionValuesKeys(optionValues);
              const optionValuesLength = optionValuesKeys.length;
              for (let index = 0; index < optionValuesLength; index++) {
                const key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                const value = optionValues[key];
                const locals2 = getLocals2(value, key);
                const selectValue = getTrackByValueFn(value, locals2);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                  const label = displayFn(scope, locals2);
                  watchedArray.push(label);
                }
                if (match[4]) {
                  const disableWhen = disableWhenFn(scope, locals2);
                  watchedArray.push(disableWhen);
                }
              }
              return watchedArray;
            }),
            getOptions() {
              const optionItems = [];
              const selectValueMap = {};
              const optionValues = valuesFn(scope) || [];
              const optionValuesKeys = getOptionValuesKeys(optionValues);
              const optionValuesLength = optionValuesKeys.length;
              for (let index = 0; index < optionValuesLength; index++) {
                const key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                const value = optionValues[key];
                const locals2 = getLocals2(value, key);
                const viewValue = viewValueFn(scope, locals2);
                const selectValue = getTrackByValueFn(viewValue, locals2);
                const label = displayFn(scope, locals2);
                const group = groupByFn(scope, locals2);
                const disabled = disableWhenFn(scope, locals2);
                const optionItem = new Option(
                  selectValue,
                  viewValue,
                  label,
                  group,
                  disabled
                );
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
              }
              return {
                items: optionItems,
                selectValueMap,
                getOptionFromViewValue(value) {
                  return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption(option) {
                  return trackBy ? structuredClone(option.viewValue) : option.viewValue;
                }
              };
            }
          };
        }
        function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
          const selectCtrl = ctrls[0];
          const ngModelCtrl = ctrls[1];
          const multiple = attr["multiple"];
          for (let i = 0, children = selectElement.childNodes, ii = children.length; i < ii; i++) {
            if (
              /** @type {HTMLOptionElement} */
              children[i].value === ""
            ) {
              selectCtrl.hasEmptyOption = true;
              selectCtrl.emptyOption = children[i];
              break;
            }
          }
          emptyElement(selectElement);
          const providedEmptyOption = !!selectCtrl.emptyOption;
          const unknownOption = optionTemplate.cloneNode(false);
          unknownOption.nodeValue = "?";
          let options;
          const ngOptions = parseOptionsExpression(
            attr["ngOptions"],
            selectElement,
            scope
          );
          const listFragment = document.createDocumentFragment();
          selectCtrl.generateUnknownOptionValue = () => "?";
          if (!multiple) {
            selectCtrl.writeValue = function writeNgOptionsValue(value) {
              if (!options) return;
              const selectedOption = selectElement.options[selectElement.selectedIndex];
              const option = options.getOptionFromViewValue(value);
              if (selectedOption) selectedOption.removeAttribute("selected");
              if (option) {
                if (selectElement.value !== option.selectValue) {
                  selectCtrl.removeUnknownOption();
                  selectElement.value = option.selectValue;
                  option.element.selected = true;
                }
                option.element.setAttribute("selected", "selected");
              } else {
                selectCtrl.selectUnknownOrEmptyOption(value);
              }
            };
            selectCtrl.readValue = function readNgOptionsValue() {
              const selectedOption = options.selectValueMap[selectElement.value];
              if (selectedOption && !selectedOption.disabled) {
                selectCtrl.unselectEmptyOption();
                selectCtrl.removeUnknownOption();
                return options.getViewValueFromOption(selectedOption);
              }
              return null;
            };
            if (ngOptions.trackBy) {
              scope.$watch(ngOptions.getTrackByValue(ngModelCtrl.$viewValue), () => {
                ngModelCtrl.$render();
              });
            }
          } else {
            selectCtrl.writeValue = function writeNgOptionsMultiple(values) {
              if (!options) return;
              const selectedOptions = values && values.map(getAndUpdateSelectedOption) || [];
              options.items.forEach((option) => {
                if (option.element.selected && !includes(selectedOptions, option)) {
                  option.element.selected = false;
                }
              });
            };
            selectCtrl.readValue = function readNgOptionsMultiple() {
              const selectedValues = selectElement.value || [];
              const selections = [];
              selectedValues.forEach((value) => {
                const option = options.selectValueMap[value];
                if (option && !option.disabled)
                  selections.push(options.getViewValueFromOption(option));
              });
              return selections;
            };
          }
          if (providedEmptyOption) {
            const linkFn = $compile(selectCtrl.emptyOption);
            assertArg$1(linkFn, "LinkFn required");
            selectElement.prepend(selectCtrl.emptyOption);
            linkFn(scope);
            if (selectCtrl.emptyOption.nodeType === Node.COMMENT_NODE) {
              selectCtrl.hasEmptyOption = false;
              selectCtrl.registerOption = function(optionScope, optionEl) {
                if (optionEl.value === "") {
                  selectCtrl.hasEmptyOption = true;
                  selectCtrl.emptyOption = optionEl;
                  ngModelCtrl.$render();
                  optionEl.addEventListener("$destroy", () => {
                    const needsRerender = selectCtrl.$isEmptyOptionSelected();
                    selectCtrl.hasEmptyOption = false;
                    selectCtrl.emptyOption = void 0;
                    if (needsRerender) ngModelCtrl.$render();
                  });
                }
              };
            }
          }
          scope.$watch(
            ngOptions.getWatchables.decoratedNode.body[0].expression.name,
            updateOptions
          );
          function addOptionElement(option, parent) {
            const optionElement = (
              /** @type {HTMLOptionElement} */
              optionTemplate.cloneNode(false)
            );
            parent.appendChild(optionElement);
            updateOptionElement(option, optionElement);
          }
          function getAndUpdateSelectedOption(viewValue) {
            const option = options.getOptionFromViewValue(viewValue);
            const element = option && option.element;
            if (element && !element.selected) element.selected = true;
            return option;
          }
          function updateOptionElement(option, element) {
            option.element = element;
            element.disabled = option.disabled;
            if (option.label !== element.label) {
              element.label = option.label;
              element.textContent = option.label;
            }
            element.value = option.selectValue;
          }
          function updateOptions() {
            const previousValue = options && selectCtrl.readValue();
            if (options) {
              for (let i = options.items.length - 1; i >= 0; i--) {
                const option = options.items[i];
                if (isDefined(option.group)) {
                  removeElement(option.element.parentNode);
                } else {
                  removeElement(option.element);
                }
              }
            }
            options = ngOptions.getOptions();
            const groupElementMap = {};
            options.items.forEach((option) => {
              let groupElement;
              if (isDefined(option.group)) {
                groupElement = groupElementMap[option.group];
                if (!groupElement) {
                  groupElement = optGroupTemplate.cloneNode(false);
                  listFragment.appendChild(groupElement);
                  groupElement.label = option.group === null ? "null" : option.group;
                  groupElementMap[option.group] = groupElement;
                }
                addOptionElement(option, groupElement);
              } else {
                addOptionElement(option, listFragment);
              }
            });
            selectElement.appendChild(listFragment);
            ngModelCtrl.$render();
            if (!ngModelCtrl.$isEmpty(previousValue)) {
              const nextValue = selectCtrl.readValue();
              const isNotPrimitive = ngOptions.trackBy || multiple;
              if (isNotPrimitive ? !equals$1(previousValue, nextValue) : previousValue !== nextValue) {
                ngModelCtrl.$setViewValue(nextValue);
                ngModelCtrl.$render();
              }
            }
          }
        }
        return {
          restrict: "A",
          terminal: true,
          require: ["select", "ngModel"],
          link: {
            pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
              ctrls[0].registerOption = () => {
              };
            },
            post: ngOptionsPostLink
          }
        };
      }
      const ngTranscludeMinErr = minErr("ngTransclude");
      ngTranscludeDirective.$inject = ["$compile"];
      function ngTranscludeDirective($compile) {
        return {
          compile: function ngTranscludeCompile(tElement) {
            const fallbackLinkFn = $compile(tElement.childNodes);
            emptyElement(tElement);
            function ngTranscludePostLink($scope, $element, $attrs, _controller, $transclude) {
              if (!$transclude) {
                throw ngTranscludeMinErr(
                  "orphan",
                  "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}",
                  startingTag($element)
                );
              }
              if ($attrs["ngTransclude"] === $attrs.$attr.ngTransclude) {
                $attrs["ngTransclude"] = "";
              }
              const slotName = $attrs["ngTransclude"] || $attrs["ngTranscludeSlot"];
              $transclude(ngTranscludeCloneAttachFn, null, slotName);
              if (slotName && !$transclude.isSlotFilled(slotName)) {
                useFallbackContent();
              }
              function ngTranscludeCloneAttachFn(clone, transcludedScope) {
                if (notWhitespace(clone)) {
                  if (clone instanceof NodeList) {
                    Array.from(clone).forEach((el) => {
                      $element.append(el);
                    });
                  } else {
                    $element.append(
                      /** @type {Node} */
                      clone
                    );
                  }
                } else {
                  useFallbackContent();
                  transcludedScope.$destroy();
                }
              }
              function useFallbackContent() {
                fallbackLinkFn(
                  $scope,
                  (clone) => {
                    $element.append(clone);
                  }
                );
              }
              function notWhitespace(node) {
                if (node instanceof Array) {
                  return false;
                } else if (node.nodeType !== Node.TEXT_NODE || node.nodeValue.trim()) {
                  return true;
                }
              }
            }
            return ngTranscludePostLink;
          }
        };
      }
      const REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
      const ngAttributeAliasDirectives = {};
      BOOLEAN_ATTR.forEach((i) => {
        if (i === "multiple") return;
        function defaultLinkFn(scope, _element, attr) {
          scope.$watch(attr[normalized], (value) => {
            attr.$set(i, !!value);
          });
        }
        let normalized = directiveNormalize(`ng-${i}`);
        let linkFn = defaultLinkFn;
        if (i === "checked") {
          linkFn = function(scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
              defaultLinkFn(scope, element, attr);
            }
          };
        }
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            restrict: "A",
            priority: 100,
            link: linkFn
          };
        };
      });
      Object.entries(ALIASED_ATTR).forEach(([ngAttr]) => {
        ngAttributeAliasDirectives[ngAttr] = function() {
          return {
            priority: 100,
            link(scope, element, attr) {
              if (ngAttr === "ngPattern" && attr["ngPattern"].charAt(0) === "/") {
                const match = attr["ngPattern"].match(REGEX_STRING_REGEXP);
                if (match) {
                  attr.$set("ngPattern", new RegExp(match[1], match[2]).toString());
                  return;
                }
              }
              scope.$watch(attr[ngAttr], (value) => {
                attr.$set(ngAttr, value);
              });
            }
          };
        };
      });
      ["src", "srcset", "href"].forEach((attrName) => {
        const normalized = directiveNormalize(`ng-${attrName}`);
        ngAttributeAliasDirectives[normalized] = [
          $injectTokens.$sce,
          function($sce) {
            return {
              priority: 99,
              // it needs to run after the attributes are interpolated
              link(_scope, element, attr) {
                let name2 = attrName;
                if (attrName === "href" && toString.call(element["href"]) === "[object SVGAnimatedString]") {
                  name2 = "xlinkHref";
                  attr.$attr[name2] = "href";
                }
                attr.$set(normalized, $sce.getTrustedMediaUrl(attr[normalized]));
                attr.$observe(normalized, (value) => {
                  if (!value) {
                    if (attrName === "href") {
                      attr.$set(name2, null);
                    }
                    return;
                  }
                  attr.$set(name2, value);
                });
              }
            };
          }
        ];
      });
      const requiredDirective = [
        $injectTokens.$parse,
        /**
         * @param {import("../../core/parse/interface.ts").ParseService} $parse
         * @returns {import("../../interface.ts").Directive}
         */
        ($parse2) => ({
          restrict: "A",
          require: "?ngModel",
          link: (
            /**
             * @param {import("../../core/scope/scope.js").Scope} scope
             * @param {Element} _elm
             * @param {import("../../core/compile/attributes.js").Attributes} attr
             * @param {import("../../interface.ts").NgModelController} ctrl
             * @returns
             */
            (scope, _elm, attr, ctrl) => {
              if (!ctrl) return;
              let value = hasOwn(attr, "required") || $parse2(attr["ngRequired"])(scope);
              if (!attr["ngRequired"]) {
                attr["required"] = true;
              }
              ctrl["$validators"].required = (_modelValue, viewValue) => {
                return !value || !ctrl.$isEmpty(viewValue);
              };
              attr.$observe("required", (newVal) => {
                if (value !== newVal) {
                  value = newVal;
                  ctrl.$validate();
                }
              });
            }
          )
        })
      ];
      const patternDirective = [
        $injectTokens.$parse,
        /**
         * @param {import("../../core/parse/interface.ts").ParseService} $parse
         * @returns {import("../../interface.ts").Directive}
         */
        ($parse2) => ({
          restrict: "A",
          require: "?ngModel",
          compile: (_Elm, tAttr) => {
            let patternExp;
            let parseFn;
            if (tAttr["ngPattern"]) {
              patternExp = tAttr["ngPattern"];
              if (tAttr["ngPattern"].charAt(0) === "/" && REGEX_STRING_REGEXP.test(tAttr["ngPattern"])) {
                parseFn = function() {
                  return tAttr["ngPattern"];
                };
              } else {
                parseFn = $parse2(tAttr["ngPattern"]);
              }
            }
            return function(scope, elm, attr, ctrl) {
              if (!ctrl) return;
              let attrVal = attr["pattern"];
              if (attr["ngPattern"]) {
                attrVal = parseFn(scope);
              } else {
                patternExp = attr["pattern"];
              }
              let regexp = parsePatternAttr(attrVal, patternExp, elm);
              attr.$observe("pattern", (newVal) => {
                const oldRegexp = regexp;
                regexp = parsePatternAttr(newVal, patternExp, elm);
                if ((oldRegexp && oldRegexp.toString()) !== (regexp && regexp.toString())) {
                  ctrl["$validate"]();
                }
              });
              ctrl["$validators"]["pattern"] = (_modelValue, viewValue) => {
                return (
                  // @ts-ignore
                  ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue)
                );
              };
            };
          }
        })
      ];
      const maxlengthDirective = [
        $injectTokens.$parse,
        /**
         * @param {import("../../core/parse/interface.ts").ParseService} $parse
         * @returns {import("../../interface.ts").Directive}
         */
        ($parse2) => ({
          restrict: "A",
          require: "?ngModel",
          link: (
            /**
             * @param {import("../../core/scope/scope.js").Scope} scope
             * @param {*} _elm
             * @param {import("../../core/compile/attributes.js").Attributes} attr
             * @param {import("../../interface.ts").NgModelController} ctrl
             * @returns
             */
            (scope, _elm, attr, ctrl) => {
              if (!ctrl) return;
              let maxlength = attr["maxlength"] || $parse2(attr["ngMaxlength"])(scope);
              let maxlengthParsed = parseLength(maxlength);
              attr.$observe("maxlength", (value) => {
                if (maxlength !== value) {
                  maxlengthParsed = parseLength(value);
                  maxlength = value;
                  ctrl.$validate();
                }
              });
              ctrl["$validators"].maxlength = function(_modelValue, viewValue) {
                return maxlengthParsed < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlengthParsed;
              };
            }
          )
        })
      ];
      const minlengthDirective = [
        $injectTokens.$parse,
        ($parse2) => ({
          restrict: "A",
          require: "?ngModel",
          link(scope, elm, attr, ctrl) {
            if (!ctrl) return;
            let minlength = attr.minlength || $parse2(attr.ngMinlength)(scope);
            let minlengthParsed = parseLength(minlength) || -1;
            attr.$observe("minlength", (value) => {
              if (minlength !== value) {
                minlengthParsed = parseLength(value) || -1;
                minlength = value;
                ctrl.$validate();
              }
            });
            ctrl.$validators.minlength = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || viewValue.length >= minlengthParsed;
            };
          }
        })
      ];
      function parsePatternAttr(regex, patternExp, elm) {
        if (!regex) return void 0;
        if (isProxy(regex)) {
          regex = regex.$target;
        }
        if (isString(regex)) {
          const match = regex.match(/^\/(.*)\/([gimsuy]*)$/);
          if (match) {
            regex = new RegExp(match[1], match[2]);
          } else {
            regex = new RegExp(`^${regex}$`);
          }
        }
        if (!regex.test) {
          throw minErr("ngPattern")(
            "noregexp",
            "Expected {0} to be a RegExp but was {1}. Element: {2}",
            patternExp,
            regex,
            startingTag(elm)
          );
        }
        return regex;
      }
      function parseLength(val2) {
        const intVal = parseInt(val2, 10);
        return isNumberNaN(intVal) ? -1 : intVal;
      }
      class AnchorScrollProvider {
        constructor() {
          this.autoScrollingEnabled = true;
        }
        $get = [
          $injectTokens.$location,
          $injectTokens.$rootScope,
          /**
           *
           * @param {import('../services/location/location.js').Location} $location
           * @param {import('../core/scope/scope.js').Scope} $rootScope
           * @returns
           */
          function($location, $rootScope) {
            function getFirstAnchor(list) {
              let result = null;
              Array.prototype.some.call(list, (element) => {
                if (getNodeName(element) === "a") {
                  result = element;
                  return true;
                }
              });
              return result;
            }
            function getYOffset() {
              let offset = (
                /** @type {AnchorScrollObject} */
                scroll.yOffset
              );
              if (isFunction(offset)) {
                offset = /** @type {Function} */
                offset();
              } else if (isElement(offset)) {
                const elem = offset[0];
                const style = window.getComputedStyle(elem);
                if (style.position !== "fixed") {
                  offset = 0;
                } else {
                  offset = elem.getBoundingClientRect().bottom;
                }
              } else if (!isNumber(offset)) {
                offset = 0;
              }
              return offset;
            }
            function scrollTo(elem) {
              if (elem) {
                elem.scrollIntoView();
                const offset = getYOffset();
                if (offset) {
                  const elemTop = elem.getBoundingClientRect().top;
                  window.scrollBy(0, elemTop - /** @type {number} */
                  offset);
                }
              } else {
                window.scrollTo(0, 0);
              }
            }
            const scroll = function(hash) {
              hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.getHash();
              let elm;
              if (!hash) {
                scrollTo(null);
              } else if (elm = document.getElementById(hash)) scrollTo(elm);
              else if (elm = getFirstAnchor(document.getElementsByName(hash)))
                scrollTo(elm);
              else if (hash === "top") scrollTo(null);
            };
            if (this.autoScrollingEnabled) {
              $rootScope["$location"] = $location;
              $rootScope.$watch("$location.$$hash", (newVal, oldVal) => {
                if (newVal === oldVal && newVal === "") return;
                const action = () => Promise.resolve().then(scroll);
                if (document.readyState === "complete") {
                  window.setTimeout(() => action());
                } else {
                  window.addEventListener("load", () => action());
                }
              });
            }
            return scroll;
          }
        ];
      }
      const ASTType = {
        Program: 1,
        ExpressionStatement: 2,
        AssignmentExpression: 3,
        ConditionalExpression: 4,
        LogicalExpression: 5,
        BinaryExpression: 6,
        UnaryExpression: 7,
        CallExpression: 8,
        MemberExpression: 9,
        Identifier: 10,
        Literal: 11,
        ArrayExpression: 12,
        Property: 13,
        ObjectExpression: 14,
        ThisExpression: 15,
        LocalsExpression: 16,
        NGValueParameter: 17
      };
      const ADD_CLASS_SUFFIX = "-add";
      const REMOVE_CLASS_SUFFIX = "-remove";
      const EVENT_CLASS_PREFIX = "ng-";
      const ACTIVE_CLASS_SUFFIX = "-active";
      const PREPARE_CLASS_SUFFIX = "-prepare";
      const NG_ANIMATE_CLASSNAME = "ng-animate";
      const NG_ANIMATE_CHILDREN_DATA = "$$ngAnimateChildren";
      let TRANSITION_PROP;
      let TRANSITIONEND_EVENT;
      let ANIMATION_PROP;
      let ANIMATIONEND_EVENT;
      if (window.ontransitionend === void 0 && window.onwebkittransitionend !== void 0) {
        TRANSITION_PROP = "WebkitTransition";
        TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend";
      } else {
        TRANSITION_PROP = "transition";
        TRANSITIONEND_EVENT = "transitionend";
      }
      if (window.onanimationend === void 0 && window.onwebkitanimationend !== void 0) {
        ANIMATION_PROP = "WebkitAnimation";
        ANIMATIONEND_EVENT = "webkitAnimationEnd animationend";
      } else {
        ANIMATION_PROP = "animation";
        ANIMATIONEND_EVENT = "animationend";
      }
      const DURATION_KEY = "Duration";
      const PROPERTY_KEY = ASTType.Property;
      const DELAY_KEY = "Delay";
      const TIMING_KEY = "TimingFunction";
      const ANIMATION_ITERATION_COUNT_KEY = "IterationCount";
      const ANIMATION_PLAYSTATE_KEY = "PlayState";
      const SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
      const ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
      const ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
      const TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
      const TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
      const ngMinErr$1 = minErr("ng");
      function assertArg(arg, name2, reason) {
        if (!arg) {
          throw ngMinErr$1(
            "areq",
            "Argument '{0}' is {1}",
            name2 || "?",
            reason
          );
        }
        return arg;
      }
      function packageStyles(options) {
        const styles = {};
        if (options && (options.to || options.from)) {
          styles.to = options.to;
          styles.from = options.from;
        }
        return styles;
      }
      function pendClasses(classes, fix, isPrefix) {
        let className = "";
        classes = Array.isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
        classes.forEach((klass, i) => {
          if (klass && klass.length > 0) {
            className += i > 0 ? " " : "";
            className += isPrefix ? fix + klass : klass + fix;
          }
        });
        return className;
      }
      function removeFromArray(arr, val2) {
        const index = arr.indexOf(val2);
        if (val2 >= 0) {
          arr.splice(index, 1);
        }
      }
      function stripCommentsFromElement(element) {
        if (element instanceof NodeList) {
          return Array.from(element).filter((x) => x.nodeType == Node.ELEMENT_NODE);
        } else if (element.nodeType === Node.ELEMENT_NODE) {
          return (
            /** @type {Node} */
            element
          );
        } else {
          return void 0;
        }
      }
      function extractElementNode(element) {
        if (!element) return (
          /** @type {Node} */
          element
        );
        for (let i = 0; i < /** @type {NodeList} */
        element.length; i++) {
          const elm = element[i];
          if (elm.nodeType === Node.ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function applyAnimationClassesFactory() {
        return function(element, options) {
          if (options.addClass) {
            element.classList.add(...options.addClass.trim().split(" "));
            options.addClass = null;
          }
          if (options.removeClass) {
            element.classList.remove(...options.removeClass.trim().split(" "));
            options.removeClass = null;
          }
        };
      }
      function prepareAnimationOptions(options) {
        options = options || {};
        if (!options.$$prepared) {
          let domOperation = options.domOperation || (() => {
          });
          options.domOperation = function() {
            options.$$domOperationFired = true;
            domOperation();
            domOperation = () => {
            };
          };
          options.$$prepared = true;
        }
        return options;
      }
      function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options);
        applyAnimationToStyles(element, options);
      }
      function applyAnimationFromStyles(element, options) {
        if (options.from) {
          options.from = null;
        }
      }
      function applyAnimationToStyles(element, options) {
        if (options.to) {
          options.to = null;
        }
      }
      function mergeAnimationDetails(element, oldAnimation, newAnimation) {
        const target = oldAnimation.options || {};
        const newOptions = newAnimation.options || {};
        const toAdd = `${target.addClass || ""} ${newOptions.addClass || ""}`;
        const toRemove = `${target.removeClass || ""} ${newOptions.removeClass || ""}`;
        const classes = resolveElementClasses(
          element.getAttribute("class"),
          toAdd,
          toRemove
        );
        if (newOptions.preparationClasses) {
          target.preparationClasses = concatWithSpace(
            newOptions.preparationClasses,
            target.preparationClasses
          );
          delete newOptions.preparationClasses;
        }
        extend(target, newOptions);
        if (classes.addClass) {
          target.addClass = classes.addClass;
        } else {
          target.addClass = null;
        }
        if (classes.removeClass) {
          target.removeClass = classes.removeClass;
        } else {
          target.removeClass = null;
        }
        oldAnimation.addClass = target.addClass;
        oldAnimation.removeClass = target.removeClass;
        return target;
      }
      function resolveElementClasses(existing, toAdd, toRemove) {
        const ADD_CLASS = 1;
        const REMOVE_CLASS = -1;
        const flags = {};
        existing = splitClassesToLookup(existing);
        toAdd = splitClassesToLookup(toAdd);
        Object.keys(toAdd).forEach((key) => {
          flags[key] = ADD_CLASS;
        });
        toRemove = splitClassesToLookup(toRemove);
        Object.keys(toRemove).forEach((key) => {
          flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        const classes = {
          addClass: "",
          removeClass: ""
        };
        Object.entries(flags).forEach(([klass, val2]) => {
          let prop, allow;
          if (val2 === ADD_CLASS) {
            prop = "addClass";
            allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];
          } else if (val2 === REMOVE_CLASS) {
            prop = "removeClass";
            allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];
          }
          if (allow) {
            if (classes[prop].length) {
              classes[prop] += " ";
            }
            classes[prop] += klass;
          }
        });
        function splitClassesToLookup(classes2) {
          if (isString(classes2)) {
            classes2 = classes2.trim().split(" ");
          }
          const obj = {};
          if (classes2) {
            classes2.forEach((klass) => {
              if (klass.length) {
                obj[klass] = true;
              }
            });
          }
          return obj;
        }
        return classes;
      }
      function applyGeneratedPreparationClasses(element, event, options) {
        let classes = "";
        if (event) {
          classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
        }
        if (options.addClass) {
          classes = concatWithSpace(
            classes,
            pendClasses(options.addClass, ADD_CLASS_SUFFIX)
          );
        }
        if (options.removeClass) {
          classes = concatWithSpace(
            classes,
            pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX)
          );
        }
        if (classes.length) {
          options.preparationClasses = classes;
          element.className += ` ${classes}`;
        }
      }
      function clearGeneratedClasses(element, options) {
        if (options.preparationClasses) {
          options.preparationClasses.split(" ").forEach((cls) => element.classList.remove(cls));
          options.preparationClasses = null;
        }
        if (options.activeClasses) {
          options.activeClasses.split(" ").forEach((cls) => element.classList.remove(cls));
          options.activeClasses = null;
        }
      }
      function blockKeyframeAnimations(node, applyBlock) {
        const value = applyBlock ? "paused" : "";
        const key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        applyInlineStyle(node, [key, value]);
        return [key, value];
      }
      function applyInlineStyle(node, styleTuple) {
        const prop = styleTuple[0];
        node.style[prop] = styleTuple[1];
      }
      function concatWithSpace(a, b) {
        if (!a) return b;
        if (!b) return a;
        return `${a} ${b}`;
      }
      const $animateMinErr = minErr("$animate");
      function mergeClasses(a, b) {
        if (!a && !b) return "";
        if (!a) return b;
        if (!b) return a;
        if (Array.isArray(a)) a = a.join(" ");
        if (Array.isArray(b)) b = b.join(" ");
        return `${a} ${b}`;
      }
      function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
      }
      AnimateProvider.$inject = ["$provide"];
      function AnimateProvider($provide) {
        const provider2 = this;
        let classNameFilter = null;
        let customFilter = null;
        this.$$registeredAnimations = /* @__PURE__ */ Object.create(null);
        this.register = function(name2, factory) {
          if (name2 && name2.charAt(0) !== ".") {
            throw $animateMinErr(
              "notcsel",
              "Expecting class selector starting with '.' got '{0}'.",
              name2
            );
          }
          const key = `${name2}-animation`;
          provider2.$$registeredAnimations[name2.substring(1)] = key;
          $provide.factory(key, factory);
        };
        this.customFilter = function(filterFn) {
          if (arguments.length === 1) {
            customFilter = isFunction(filterFn) ? filterFn : null;
          }
          return customFilter;
        };
        this.classNameFilter = function(expression) {
          if (arguments.length === 1) {
            classNameFilter = expression instanceof RegExp ? expression : null;
            if (classNameFilter) {
              const reservedRegex = new RegExp(
                `[(\\s|\\/)]${NG_ANIMATE_CLASSNAME}[(\\s|\\/)]`
              );
              if (reservedRegex.test(classNameFilter.toString())) {
                classNameFilter = null;
                throw $animateMinErr(
                  "nongcls",
                  '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.',
                  NG_ANIMATE_CLASSNAME
                );
              }
            }
          }
          return classNameFilter;
        };
        this.$get = [
          "$$animateQueue",
          function($$animateQueue) {
            return {
              /**
               *
               * Sets up an event listener to fire whenever the animation event (enter, leave, move, etc...)
               *    has fired on the given element or among any of its children. Once the listener is fired, the provided callback
               *    is fired with the following params:
               *
               * ```js
               * $animate.on('enter', container,
               *    function callback(element, phase) {
               *      // cool we detected an enter animation within the container
               *    }
               * );
               * ```
               *
               * <div class="alert alert-warning">
               * **Note**: Generally, the events that are fired correspond 1:1 to `$animate` method names,
               * e.g. {@link ng.$animate#addClass addClass()} will fire `addClass`, and {@link ng.ngClass}
               * will fire `addClass` if classes are added, and `removeClass` if classes are removed.
               * However, there are two exceptions:
               *
               * <ul>
               *   <li>if both an {@link ng.$animate#addClass addClass()} and a
               *   {@link ng.$animate#removeClass removeClass()} action are performed during the same
               *   animation, the event fired will be `setClass`. This is true even for `ngClass`.</li>
               *   <li>an {@link ng.$animate#animate animate()} call that adds and removes classes will fire
               *   the `setClass` event, but if it either removes or adds classes,
               *   it will fire `animate` instead.</li>
               * </ul>
               *
               * </div>
               *
               * @param {string} event the animation event that will be captured (e.g. enter, leave, move, addClass, removeClass, etc...)
               * @param {Element} container the container element that will capture each of the animation events that are fired on itself
               *     as well as among its children
               * @param {Function} callback the callback function that will be fired when the listener is triggered.
               *
               * The arguments present in the callback function are:
               * * `element` - The captured DOM element that the animation was fired on.
               * * `phase` - The phase of the animation. The two possible phases are **start** (when the animation starts) and **close** (when it ends).
               * * `data` - an object with these properties:
               *     * addClass - `{string|null}` - space-separated CSS classes to add to the element
               *     * removeClass - `{string|null}` - space-separated CSS classes to remove from the element
               *     * from - `{Object|null}` - CSS properties & values at the beginning of the animation
               *     * to - `{Object|null}` - CSS properties & values at the end of the animation
               *
               * Note that the callback does not trigger a scope digest. Wrap your call into a
               * {@link $rootScope.Scope#$apply scope.$apply} to propagate changes to the scope.
               */
              on: $$animateQueue.on,
              /**
               * Deregisters an event listener based on the event which has been associated with the provided element. This method
               * can be used in three different ways depending on the arguments:
               *
               * ```js
               * // remove all the animation event listeners listening for `enter`
               * $animate.off('enter');
               *
               * // remove listeners for all animation events from the container element
               * $animate.off(container);
               *
               * // remove all the animation event listeners listening for `enter` on the given element and its children
               * $animate.off('enter', container);
               *
               * // remove the event listener function provided by `callback` that is set
               * // to listen for `enter` on the given `container` as well as its children
               * $animate.off('enter', container, callback);
               * ```
               *
               * @param {string|Element} event|container the animation event (e.g. enter, leave, move,
               * addClass, removeClass, etc...), or the container element. If it is the element, all other
               * arguments are ignored.
               * @param {Element=} container the container element the event listener was placed on
               * @param {Function=} callback the callback function that was registered as the listener
               */
              off: $$animateQueue.off,
              /**
               *  Associates the provided element with a host parent element to allow the element to be animated even if it exists
               *  outside of the DOM structure of the AngularTS application. By doing so, any animation triggered via `$animate` can be issued on the
               *  element despite being outside the realm of the application or within another application. Say for example if the application
               *  was bootstrapped on an element that is somewhere inside of the `<body>` tag, but we wanted to allow for an element to be situated
               *  as a direct child of `document.body`, then this can be achieved by pinning the element via `$animate.pin(element)`. Keep in mind
               *  that calling `$animate.pin(element, parentElement)` will not actually insert into the DOM anywhere; it will just create the association.
               *
               *  Note that this feature is only active when the `ngAnimate` module is used.
               *
               * @param {Element} element the external element that will be pinned
               * @param {Element} parentElement the host parent element that will be associated with the external element
               */
              pin: $$animateQueue.pin,
              /**
               * Used to get and set whether animations are enabled or not on the entire application or on an element and its children. This
               * function can be called in four ways:
               *
               * ```js
               * // returns true or false
               * $animate.enabled();
               *
               * // changes the enabled state for all animations
               * $animate.enabled(false);
               * $animate.enabled(true);
               *
               * // returns true or false if animations are enabled for an element
               * $animate.enabled(element);
               *
               * // changes the enabled state for an element and its children
               * $animate.enabled(element, true);
               * $animate.enabled(element, false);
               * ```
               *
               * @param {Element=} element the element that will be considered for checking/setting the enabled state
               * @param {boolean=} enabled whether or not the animations will be enabled for the element
               *
               * @return {boolean} whether or not animations are enabled
               */
              enabled: $$animateQueue.enabled,
              /**
                       * Cancels the provided animation and applies the end state of the animation.
                       * Note that this does not cancel the underlying operation, e.g. the setting of classes or
                       * adding the element to the DOM.
                       *
                       * @param {import('./animate-runner.js').AnimateRunner} runner An animation runner returned by an $animate function.
                       *
                       * @example
                        <example module="animationExample" deps="angular-animate.js" animations="true" name="animate-cancel">
                          <file name="app.js">
                            angular.module('animationExample', []).component('cancelExample', {
                              templateUrl: 'template.html',
                              controller: function($element, $animate) {
                                this.runner = null;
              
                                this.addClass = function() {
                                  this.runner = $animate.addClass($element.querySelectorAll('div'), 'red');
                                  let ctrl = this;
                                  this.runner.finally(function() {
                                    ctrl.runner = null;
                                  });
                                };
              
                                this.removeClass = function() {
                                  this.runner = $animate.removeClass($element.querySelectorAll('div'), 'red');
                                  let ctrl = this;
                                  this.runner.finally(function() {
                                    ctrl.runner = null;
                                  });
                                };
              
                                this.cancel = function() {
                                  $animate.cancel(this.runner);
                                };
                              }
                            });
                          </file>
                          <file name="template.html">
                            <p>
                              <button id="add" ng-click="$ctrl.addClass()">Add</button>
                              <button ng-click="$ctrl.removeClass()">Remove</button>
                              <br>
                              <button id="cancel" ng-click="$ctrl.cancel()" ng-disabled="!$ctrl.runner">Cancel</button>
                              <br>
                              <div id="target">CSS-Animated Text</div>
                            </p>
                          </file>
                          <file name="index.html">
                            <cancel-example></cancel-example>
                          </file>
                          <file name="style.css">
                            .red-add, .red-remove {
                              transition: all 4s cubic-bezier(0.250, 0.460, 0.450, 0.940);
                            }
              
                            .red,
                            .red-add.red-add-active {
                              color: #FF0000;
                              font-size: 40px;
                            }
              
                            .red-remove.red-remove-active {
                              font-size: 10px;
                              color: black;
                            }
              
                          </file>
                        </example>
                       */
              cancel(runner) {
                if (runner.cancel) {
                  runner.cancel();
                }
              },
              /**
               * Inserts the element into the DOM either after the `after` element (if provided) or
               * as the first child within the `parent` element and then triggers an animation.
               * A promise is returned that will be resolved during the next digest once the animation
               * has completed.
               *
               * @param {Element} element - the element which will be inserted into the DOM
               * @param {Element} parent - the parent element which will append the element as a child (so long as the after element is not present)
               * @param {Element} after - after the sibling element after which the element will be appended
               * @param {AnimationOptions} [options] - an optional collection of options/styles that will be applied to the element.
               * @returns {import('./animate-runner.js').AnimateRunner} the animation runner
               */
              enter(element, parent, after, options) {
                parent = parent || after.parentElement;
                domInsert(element, parent, after);
                return $$animateQueue.push(
                  element,
                  "enter",
                  prepareAnimateOptions(options)
                );
              },
              /**
               * Inserts (moves) the element into its new position in the DOM either after
               * the `after` element (if provided) or as the first child within the `parent` element
               * and then triggers an animation. A promise is returned that will be resolved
               * during the next digest once the animation has completed.
               *
               * @param {Element} element - the element which will be inserted into the DOM
               * @param {Element} parent - the parent element which will append the element as a child (so long as the after element is not present)
               * @param {Element} after - after the sibling element after which the element will be appended
               * @param {AnimationOptions} [options] - an optional collection of options/styles that will be applied to the element.
               * @returns {import('./animate-runner.js').AnimateRunner} the animation runner
               */
              move(element, parent, after, options) {
                parent = parent || after.parentElement;
                domInsert(element, parent, after);
                return $$animateQueue.push(
                  element,
                  "move",
                  prepareAnimateOptions(options)
                );
              },
              /**
               * Triggers an animation and then removes the element from the DOM.
               * When the function is called a promise is returned that will be resolved during the next
               * digest once the animation has completed.
               *
               * @param {Element} element the element which will be removed from the DOM
               * @param {AnimationOptions} [options] an optional collection of options/styles that will be applied to the element.
               * @returns {import('./animate-runner.js').AnimateRunner} the animation runner
               */
              leave(element, options) {
                return $$animateQueue.push(
                  element,
                  "leave",
                  prepareAnimateOptions(options),
                  () => {
                    if (Array.isArray(element)) {
                      element.forEach((x) => removeElement(x));
                    } else {
                      removeElement(element);
                    }
                  }
                );
              },
              /**
               * Triggers an addClass animation surrounding the addition of the provided CSS class(es). Upon
               * execution, the addClass operation will only be handled after the next digest and it will not trigger an
               * animation if element already contains the CSS class or if the class is removed at a later step.
               * Note that class-based animations are treated differently compared to structural animations
               * (like enter, move and leave) since the CSS classes may be added/removed at different points
               * depending if CSS or JavaScript animations are used.
               *
               * @param {Element} element the element which the CSS classes will be applied to
               * @param {string} className the CSS class(es) that will be added (multiple classes are separated via spaces)
               * @param {AnimationOptions} [options] an optional collection of options/styles that will be applied to the element.
               * @return {import('./animate-runner.js').AnimateRunner}} animationRunner the animation runner
               */
              addClass(element, className, options) {
                options = prepareAnimateOptions(options);
                options.addClass = mergeClasses(options.addClass, className);
                return $$animateQueue.push(element, "addClass", options);
              },
              /**
               * Triggers a removeClass animation surrounding the removal of the provided CSS class(es). Upon
               * execution, the removeClass operation will only be handled after the next digest and it will not trigger an
               * animation if element does not contain the CSS class or if the class is added at a later step.
               * Note that class-based animations are treated differently compared to structural animations
               * (like enter, move and leave) since the CSS classes may be added/removed at different points
               * depending if CSS or JavaScript animations are used.
               *
               * @param {Element} element the element which the CSS classes will be applied to
               * @param {string} className the CSS class(es) that will be removed (multiple classes are separated via spaces)
               * @param {AnimationOptions} [options] an optional collection of options/styles that will be applied to the element.         *
               * @return {import('./animate-runner.js').AnimateRunner} animationRunner the animation runner
               */
              removeClass(element, className, options) {
                options = prepareAnimateOptions(options);
                options.removeClass = mergeClasses(options.removeClass, className);
                return $$animateQueue.push(element, "removeClass", options);
              },
              /**
               * Performs both the addition and removal of a CSS classes on an element and (during the process)
               * triggers an animation surrounding the class addition/removal. Much like `$animate.addClass` and
               * `$animate.removeClass`, `setClass` will only evaluate the classes being added/removed once a digest has
               * passed. Note that class-based animations are treated differently compared to structural animations
               * (like enter, move and leave) since the CSS classes may be added/removed at different points
               * depending if CSS or JavaScript animations are used.
               *
               * @param {Element} element the element which the CSS classes will be applied to
               * @param {string} add the CSS class(es) that will be added (multiple classes are separated via spaces)
               * @param {string} remove the CSS class(es) that will be removed (multiple classes are separated via spaces)
               * @param {object=} options an optional collection of options/styles that will be applied to the element.
               *
               * @return {import('./animate-runner.js').AnimateRunner} the animation runner
               */
              setClass(element, add, remove, options) {
                options = prepareAnimateOptions(options);
                options.addClass = mergeClasses(options.addClass, add);
                options.removeClass = mergeClasses(options.removeClass, remove);
                return $$animateQueue.push(element, "setClass", options);
              },
              /**
               * Performs an inline animation on the element which applies the provided to and from CSS styles to the element.
               * If any detected CSS transition, keyframe or JavaScript matches the provided className value, then the animation will take
               * on the provided styles. For example, if a transition animation is set for the given className, then the provided `from` and
               * `to` styles will be applied alongside the given transition. If the CSS style provided in `from` does not have a corresponding
               * style in `to`, the style in `from` is applied immediately, and no animation is run.
               * If a JavaScript animation is detected then the provided styles will be given in as function parameters into the `animate`
               * method (or as part of the `options` parameter):
               *
               * ```js
               * ngModule.animation('.my-inline-animation', function() {
               *   return {
               *     animate : function(element, from, to, done, options) {
               *       //animation
               *       done();
               *     }
               *   }
               * });
               * ```
               *  @return {import('./animate-runner.js').AnimateRunner} the animation runner
               */
              animate(element, from, to, className, options) {
                options = prepareAnimateOptions(options);
                options.from = options.from ? extend(options.from, from) : from;
                options.to = options.to ? extend(options.to, to) : to;
                className = className || "ng-inline-animate";
                options.tempClasses = mergeClasses(options.tempClasses, className);
                return $$animateQueue.push(element, "animate", options);
              }
            };
          }
        ];
      }
      function AnimateAsyncRunFactoryProvider() {
        this.$get = [
          function() {
            let waitQueue = [];
            function waitForTick(fn) {
              waitQueue.push(fn);
              if (waitQueue.length > 1) return;
              window.requestAnimationFrame(function() {
                for (let i = 0; i < waitQueue.length; i++) {
                  waitQueue[i]();
                }
                waitQueue = [];
              });
            }
            return function() {
              let passed = false;
              waitForTick(function() {
                passed = true;
              });
              return function(callback) {
                if (passed) {
                  callback();
                } else {
                  waitForTick(callback);
                }
              };
            };
          }
        ];
      }
      const INITIAL_STATE = 0;
      const DONE_PENDING_STATE = 1;
      const DONE_COMPLETE_STATE = 2;
      let $$animateAsyncRun;
      function AnimateRunnerFactoryProvider() {
        this.$get = [
          "$$animateAsyncRun",
          function(animateAsyncRun) {
            $$animateAsyncRun = animateAsyncRun;
            return AnimateRunner;
          }
        ];
      }
      class AnimateRunner {
        static chain(chain, callback) {
          let index = 0;
          function next() {
            if (index === chain.length) {
              callback(true);
              return;
            }
            chain[index]((response) => {
              if (response === false) {
                callback(false);
                return;
              }
              index++;
              next();
            });
          }
          next();
        }
        static all(runners, callback) {
          let count = 0;
          let status = true;
          runners.forEach((runner) => {
            runner.done(onProgress);
          });
          function onProgress(response) {
            status = status && response;
            if (++count === runners.length) {
              callback(status);
            }
          }
        }
        constructor(host) {
          this.setHost(host);
          const rafTick = $$animateAsyncRun();
          const timeoutTick = (fn) => {
            setTimeout(fn, 0, false);
          };
          this._doneCallbacks = [];
          this._tick = (fn) => {
            if (document.hidden) {
              timeoutTick(fn);
            } else {
              rafTick(fn);
            }
          };
          this._state = 0;
        }
        setHost(host) {
          this.host = host || {};
        }
        done(fn) {
          if (this._state === DONE_COMPLETE_STATE) {
            fn();
          } else {
            this._doneCallbacks.push(fn);
          }
        }
        progress() {
        }
        getPromise() {
          if (!this.promise) {
            const self2 = this;
            this.promise = new Promise((resolve, reject) => {
              self2.done((status) => {
                if (status === false) {
                  reject();
                } else {
                  resolve();
                }
              });
            });
          }
          return this.promise;
        }
        then(resolveHandler, rejectHandler) {
          return this.getPromise().then(resolveHandler, rejectHandler);
        }
        catch(handler) {
          return this.getPromise().catch(handler);
        }
        finally(handler) {
          return this.getPromise().finally(handler);
        }
        pause() {
          if (this.host.pause) {
            this.host.pause();
          }
        }
        resume() {
          if (this.host.resume) {
            this.host.resume();
          }
        }
        end() {
          if (this.host.end) {
            this.host.end();
          }
          this._resolve(true);
        }
        cancel() {
          if (this.host.cancel) {
            this.host.cancel();
          }
          this._resolve(false);
        }
        complete(response) {
          if (this._state === INITIAL_STATE) {
            this._state = DONE_PENDING_STATE;
            this._tick(() => {
              this._resolve(response);
            });
          }
        }
        _resolve(response) {
          if (this._state !== DONE_COMPLETE_STATE) {
            this._doneCallbacks.forEach((fn) => {
              fn(response);
            });
            this._doneCallbacks.length = 0;
            this._state = DONE_COMPLETE_STATE;
          }
        }
      }
      class TemplateCacheProvider {
        constructor() {
          this.cache = /* @__PURE__ */ new Map();
        }
        /**
         * @returns {import('./interface.ts').TemplateCache}
         */
        $get() {
          return this.cache;
        }
      }
      class ExceptionHandlerProvider {
        constructor() {
          this.log = window.console;
          this.errorHandler = (exception, cause) => {
            this.log.error(exception, cause);
          };
          this.$get = [
            "$log",
            /**
             * @param {LogService} $log
             * @returns {ErrorHandler}
             */
            ($log) => {
              this.log = $log;
              return this.errorHandler;
            }
          ];
        }
      }
      function filterFilter() {
        return function(array, expression, comparator, anyPropertyKey) {
          if (!isArrayLike(array)) {
            if (array == null) {
              return array;
            }
            throw minErr("filter")(
              "notarray",
              "Expected array but received: {0}",
              array
            );
          }
          anyPropertyKey = anyPropertyKey || "$";
          let predicateFn;
          let matchAgainstAnyProp = false;
          switch (getTypeForFilter(expression)) {
            case "function":
              predicateFn = expression;
              break;
            case "boolean":
            case "null":
            case "number":
            case "string":
              matchAgainstAnyProp = true;
            // falls through
            case "object":
              predicateFn = createPredicateFn(
                expression,
                comparator,
                anyPropertyKey,
                matchAgainstAnyProp
              );
              break;
            default:
              return array;
          }
          return Array.prototype.filter.call(array, predicateFn);
        };
      }
      function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
        const shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression;
        let predicateFn;
        if (comparator === true) {
          comparator = equals$1;
        } else if (!isFunction(comparator)) {
          comparator = function(actual, expected) {
            if (isUndefined(actual)) {
              return false;
            }
            if (actual === null || expected === null) {
              return actual === expected;
            }
            if (isObject(expected) || isObject(actual) && !hasCustomToString(actual)) {
              return false;
            }
            actual = `${actual}`.toLowerCase();
            expected = `${expected}`.toLowerCase();
            return actual.indexOf(expected) !== -1;
          };
        }
        predicateFn = function(item) {
          if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(
              item,
              expression[anyPropertyKey],
              comparator,
              anyPropertyKey,
              false
            );
          }
          return deepCompare(
            item,
            expression,
            comparator,
            anyPropertyKey,
            matchAgainstAnyProp
          );
        };
        return predicateFn;
      }
      function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
        const actualType = getTypeForFilter(actual);
        const expectedType = getTypeForFilter(expected);
        if (expectedType === "string" && expected.charAt(0) === "!") {
          return !deepCompare(
            actual,
            expected.substring(1),
            comparator,
            anyPropertyKey,
            matchAgainstAnyProp
          );
        }
        if (Array.isArray(actual)) {
          return actual.some(
            (item) => deepCompare(
              item,
              expected,
              comparator,
              anyPropertyKey,
              matchAgainstAnyProp
            )
          );
        }
        switch (actualType) {
          case "object":
            if (matchAgainstAnyProp) {
              for (let key in actual) {
                if (key.charAt && key.charAt(0) !== "$" && deepCompare(actual[key], expected, comparator, anyPropertyKey, true)) {
                  return true;
                }
              }
              return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, anyPropertyKey, false);
            }
            if (expectedType === "object") {
              for (let key in expected) {
                const expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                  continue;
                }
                const matchAnyProperty = key === anyPropertyKey;
                const actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(
                  actualVal,
                  expectedVal,
                  comparator,
                  anyPropertyKey,
                  matchAnyProperty,
                  matchAnyProperty
                )) {
                  return false;
                }
              }
              return true;
            }
            return comparator(actual, expected);
          case "function":
            return false;
          default:
            return comparator(actual, expected);
        }
      }
      function getTypeForFilter(val2) {
        return val2 === null ? "null" : typeof val2;
      }
      function jsonFilter() {
        return function(object, spacing) {
          if (isUndefined(spacing)) {
            spacing = 2;
          }
          return toJson(object, spacing);
        };
      }
      function limitToFilter() {
        return function(input, limit, begin) {
          if (isFunction(input)) {
            input = /** @type {Function} */
            input();
          }
          if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
          } else {
            limit = parseInt(
              /** @type {string} */
              limit,
              10
            );
          }
          if (isNumberNaN(limit)) return input;
          if (isNumber(input)) input = input.toString();
          if (!isArrayLike(input)) return input;
          begin = !begin || isNaN(
            /** @type {any} */
            begin
          ) ? 0 : parseInt(
            /** @type {string} */
            begin,
            10
          );
          begin = begin < 0 ? Math.max(
            0,
            /** @type {[]} */
            input.length + begin
          ) : begin;
          if (limit >= 0) {
            return sliceFn(input, begin, begin + limit);
          } else {
            if (begin === 0) {
              return sliceFn(
                input,
                limit,
                /** @type {[]} */
                input.length
              );
            } else {
              return sliceFn(input, Math.max(0, begin + limit), begin);
            }
          }
        };
      }
      function sliceFn(input, begin, end) {
        if (isString(input)) return input.slice(begin, end);
        return [].slice.call(input, begin, end);
      }
      orderByFilter.$inject = [$injectTokens.$parse];
      function orderByFilter($parse2) {
        return function(array, sortPredicate, reverseOrder, compareFn) {
          if (array == null) return array;
          if (isFunction(array)) return array();
          if (!isArrayLike(array)) {
            throw minErr("orderBy")(
              "notarray",
              "Expected array but received: {0}",
              array
            );
          }
          if (!Array.isArray(sortPredicate)) {
            sortPredicate = [sortPredicate];
          }
          if (sortPredicate.length === 0) {
            sortPredicate = ["+"];
          }
          const predicates = processPredicates(sortPredicate);
          const descending = reverseOrder ? -1 : 1;
          const compare = isFunction(compareFn) ? compareFn : defaultCompare;
          const compareValues = Array.prototype.map.call(array, getComparisonObject);
          compareValues.sort(doComparison);
          array = compareValues.map((item) => item.value);
          return array;
          function getComparisonObject(value, index) {
            return {
              value,
              tieBreaker: { value: index, type: "number", index },
              predicateValues: predicates.map(
                (predicate) => getPredicateValue(predicate.get(value), index)
              )
            };
          }
          function doComparison(v1, v2) {
            for (let i = 0, ii = predicates.length; i < ii; i++) {
              const result = compare(v1.predicateValues[i], v2.predicateValues[i]);
              if (result) {
                return result * predicates[i].descending * descending;
              }
            }
            return (compare(v1.tieBreaker, v2.tieBreaker) || defaultCompare(v1.tieBreaker, v2.tieBreaker)) * descending;
          }
        };
        function processPredicates(sortPredicates) {
          return sortPredicates.map((predicate) => {
            let descending = 1;
            let get = (x) => x;
            if (isFunction(predicate)) {
              get = predicate;
            } else if (isString(predicate)) {
              if (predicate.charAt(0) === "+" || predicate.charAt(0) === "-") {
                descending = predicate.charAt(0) === "-" ? -1 : 1;
                predicate = predicate.substring(1);
              }
              if (predicate !== "") {
                let parsed = $parse2(predicate);
                if (parsed.constant) {
                  const key = parsed();
                  get = (value) => value[key];
                } else {
                  get = parsed;
                }
              }
            }
            return { get, descending };
          });
        }
        function isPrimitive(value) {
          switch (typeof value) {
            case "number":
            /* falls through */
            case "boolean":
            /* falls through */
            case "string":
              return true;
            default:
              return false;
          }
        }
        function objectValue(value) {
          if (isFunction(value.valueOf)) {
            value = value.valueOf();
            if (isPrimitive(value)) return value;
          }
          if (hasCustomToString(value)) {
            value = value.toString();
            if (isPrimitive(value)) return value;
          }
          return value;
        }
        function getPredicateValue(value, index) {
          let type = typeof value;
          if (value === null) {
            type = "null";
          } else if (type === "object") {
            value = objectValue(value);
          }
          return { value, type, index };
        }
        function defaultCompare(v1, v2) {
          let result = 0;
          const type1 = v1.type;
          const type2 = v2.type;
          if (type1 === type2) {
            let value1 = v1.value;
            let value2 = v2.value;
            if (type1 === "string") {
              value1 = value1.toLowerCase();
              value2 = value2.toLowerCase();
            } else if (type1 === "object") {
              if (isObject(value1)) value1 = v1.index;
              if (isObject(value2)) value2 = v2.index;
            }
            if (value1 !== value2) {
              result = value1 < value2 ? -1 : 1;
            }
          } else {
            result = type1 === "undefined" ? 1 : type2 === "undefined" ? -1 : type1 === "null" ? 1 : type2 === "null" ? -1 : type1 < type2 ? -1 : 1;
          }
          return result;
        }
      }
      $IsStateFilter.$inject = [$injectTokens.$state];
      function $IsStateFilter($state) {
        const isFilter = (state, params, options) => $state.is(state, params, options);
        isFilter.$stateful = true;
        return isFilter;
      }
      $IncludedByStateFilter.$inject = [$injectTokens.$state];
      function $IncludedByStateFilter($state) {
        const includesFilter = function(state, params, options) {
          return $state.includes(state, params, options);
        };
        includesFilter.$stateful = true;
        return includesFilter;
      }
      const SUFFIX = "Filter";
      class FilterProvider {
        /* @ignore */
        static $inject = [$injectTokens.$provide];
        /**
         * @param {import('../../interface.ts').Provider} $provide
         */
        constructor($provide) {
          this.$provide = $provide;
          this.register({
            filter: filterFilter,
            json: jsonFilter,
            limitTo: limitToFilter,
            orderBy: orderByFilter,
            isState: $IsStateFilter,
            includedByState: $IncludedByStateFilter
          });
        }
        /**
         * @param {string|Record<string, import('../../interface.ts').FilterFactory>} name
         * @param {import('../../interface.ts').FilterFactory} [factory]
         * @return {import('../../interface.ts').Provider}
         */
        register(name2, factory) {
          if (isObject(name2)) {
            Object.entries(name2).forEach(([key, filter2]) => {
              this.register(key, filter2);
            });
          }
          return this.$provide.factory(name2 + SUFFIX, factory);
        }
        $get = [
          $injectTokens.$injector,
          /**
           * @param {import("../../core/di/internal-injector.js").InjectorService} $injector
           * @returns {import('../../interface.ts').FilterFn}
           */
          ($injector) => (name2) => $injector.get(name2 + SUFFIX)
        ];
      }
      const PURITY_ABSOLUTE = 1;
      const PURITY_RELATIVE = 2;
      class ASTInterpreter {
        /**
         * @param {function(any):any} $filter
         */
        constructor($filter) {
          this.$filter = $filter;
        }
        /**
         * Compiles the AST into a function.
         * @param {import("./ast/ast").ASTNode} ast - The AST to compile.
         * @returns {import("./interface.ts").CompiledExpression}
         */
        compile(ast) {
          let decoratedNode = findConstantAndWatchExpressions(ast, this.$filter);
          let assignable;
          let assign;
          if (assignable = assignableAST(decoratedNode)) {
            assign = /** @type {import("./interface.ts").CompiledExpression} */
            this.recurse(assignable);
          }
          const toWatch = getInputs(decoratedNode.body);
          let inputs;
          if (toWatch) {
            inputs = [];
            for (const [key, watch] of Object.entries(toWatch)) {
              const input = (
                /** @type {import("./interface.ts").CompiledExpression} */
                this.recurse(watch)
              );
              input.isPure = watch.isPure;
              watch.input = input;
              inputs.push(input);
              watch.watchId = key;
            }
          }
          const expressions = [];
          decoratedNode.body.forEach((expression) => {
            expressions.push(this.recurse(expression.expression));
          });
          const fn = decoratedNode.body.length === 0 ? () => {
          } : decoratedNode.body.length === 1 ? expressions[0] : function(scope, locals) {
            let lastValue;
            expressions.forEach((exp) => {
              lastValue = exp(scope, locals);
            });
            return lastValue;
          };
          if (assign) {
            fn.assign = (scope, value, locals) => assign(scope, locals, value);
          }
          if (inputs) {
            fn.inputs = inputs;
          }
          fn.decoratedNode = decoratedNode;
          return fn;
        }
        /**
         * Recurses the AST nodes.
         * @param {import("./ast/ast").ASTNode} ast - The AST node.
         * @param {Object} [context] - The context.
         * @param {boolean|1} [create] - The create flag.
         * @returns {import("./interface.ts").CompiledExpressionFunction} The recursive function.
         */
        recurse(ast, context, create) {
          let left;
          let right;
          const self2 = this;
          let args;
          switch (ast.type) {
            case ASTType.Literal:
              return this.value(ast.value, context);
            case ASTType.UnaryExpression:
              right = this.recurse(ast.argument);
              return this[`unary${ast.operator}`](right, context);
            case ASTType.BinaryExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this[`binary${ast.operator}`](left, right, context);
            case ASTType.LogicalExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this[`binary${ast.operator}`](left, right, context);
            case ASTType.ConditionalExpression:
              return (
                /** @type {import("./interface.ts").CompiledExpressionFunction} */
                this["ternary?:"](
                  this.recurse(ast.test),
                  this.recurse(ast.alternate),
                  this.recurse(ast.consequent),
                  context
                )
              );
            case ASTType.Identifier:
              return self2.identifier(ast.name, context, create);
            case ASTType.MemberExpression:
              left = this.recurse(ast.object, false, !!create);
              if (!ast.computed) {
                right = ast.property.name;
              }
              if (ast.computed) right = this.recurse(ast.property);
              return (
                /** @type {import("./interface.ts").CompiledExpressionFunction} */
                ast.computed ? this.computedMember(
                  left,
                  /** @type {function } */
                  right,
                  context,
                  create
                ) : this.nonComputedMember(
                  left,
                  /** @type {string } */
                  right,
                  context,
                  create
                )
              );
            case ASTType.CallExpression:
              args = [];
              ast.arguments.forEach((expr) => {
                args.push(self2.recurse(expr));
              });
              if (ast.filter) right = this.$filter(ast.callee.name);
              if (!ast.filter) right = this.recurse(ast.callee, true);
              return ast.filter ? (scope, locals, assign) => {
                const values = [];
                for (let i = 0; i < args.length; ++i) {
                  const res = args[i](
                    scope && scope.$target ? scope.$target : scope,
                    locals,
                    assign
                  );
                  values.push(res);
                }
                const value = () => {
                  return right.apply(void 0, values);
                };
                return context ? { context: void 0, name: void 0, value } : value;
              } : (scope, locals, assign) => {
                const rhs = right(
                  scope.$target ? scope.$target : scope,
                  locals,
                  assign
                );
                let value;
                if (rhs.value != null && isFunction(rhs.value)) {
                  const values = [];
                  for (let i = 0; i < args.length; ++i) {
                    const res = args[i](scope, locals, assign);
                    values.push(isFunction(res) ? res() : res);
                  }
                  value = rhs.value.apply(rhs.context, values);
                }
                return context ? { value } : value;
              };
            case ASTType.AssignmentExpression:
              left = this.recurse(ast.left, true, 1);
              right = this.recurse(ast.right);
              return (scope, locals, assign) => {
                const lhs = left(scope, locals, assign);
                const rhs = right(scope, locals, assign);
                const ctx = isProxy(lhs.context) ? lhs.context : lhs.context.$proxy ?? lhs.context;
                ctx[lhs.name] = rhs;
                return context ? { value: rhs } : rhs;
              };
            case ASTType.ArrayExpression:
              args = [];
              ast.elements.forEach((expr) => {
                args.push(self2.recurse(expr));
              });
              return (scope, locals, assign) => {
                const value = [];
                for (let i = 0; i < args.length; ++i) {
                  value.push(args[i](scope, locals, assign));
                }
                return context ? { value } : value;
              };
            case ASTType.ObjectExpression:
              args = [];
              ast.properties.forEach((property) => {
                if (property.computed) {
                  args.push({
                    key: self2.recurse(property.key),
                    computed: true,
                    value: self2.recurse(property.value)
                  });
                } else {
                  args.push({
                    key: property.key.type === ASTType.Identifier ? property.key.name : `${property.key.value}`,
                    computed: false,
                    value: self2.recurse(property.value)
                  });
                }
              });
              return (scope, locals, assign) => {
                const value = {};
                for (let i = 0; i < args.length; ++i) {
                  if (args[i].computed) {
                    value[args[i].key(scope, locals, assign)] = args[i].value(
                      scope,
                      locals,
                      assign
                    );
                  } else {
                    value[args[i].key] = args[i].value(scope, locals, assign);
                  }
                }
                return context ? { value } : value;
              };
            case ASTType.ThisExpression:
              return (scope) => context ? { value: scope } : scope.$proxy;
            case ASTType.LocalsExpression:
              return (scope, locals) => context ? { value: locals } : locals;
            case ASTType.NGValueParameter:
              return (scope, locals, assign) => context ? { value: assign } : assign;
          }
        }
        /**
         * Unary plus operation.
         * @param {function} argument - The argument function.
         * @param {Object} [context] - The context.
         * @returns {function} The unary plus function.
         */
        "unary+"(argument, context) {
          return (scope, locals, assign) => {
            let arg = argument(scope, locals, assign);
            if (isDefined(arg)) {
              arg = +arg;
            } else {
              arg = 0;
            }
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Unary minus operation.
         * @param {function} argument - The argument function.
         * @param {Object} [context] - The context.
         * @returns {function} The unary minus function.
         */
        "unary-"(argument, context) {
          return (scope, locals, assign) => {
            let arg = argument(scope, locals, assign);
            if (isDefined(arg)) {
              arg = -arg;
            } else {
              arg = -0;
            }
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Unary negation operation.
         * @param {function} argument - The argument function.
         * @param {Object} [context] - The context.
         * @returns {function} The unary negation function.
         */
        "unary!"(argument, context) {
          return (scope, locals, assign) => {
            const arg = !argument(scope, locals, assign);
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Binary plus operation.
         * @param {function} left - The left operand function.
         * @param {function} right - The right operand function.
         * @param {Object} [context] - The context.
         * @returns {function} The binary plus function.
         */
        "binary+"(left, right, context) {
          return (scope, locals, assign) => {
            const lhs = left(scope, locals, assign);
            const rhs = right(scope, locals, assign);
            const arg = plusFn(lhs, rhs);
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Binary minus operation.
         * @param {function} left - The left operand function.
         * @param {function} right - The right operand function.
         * @param {Object} [context] - The context.
         * @returns {function} The binary minus function.
         */
        "binary-"(left, right, context) {
          return (scope, locals, assign) => {
            const lhs = left(scope, locals, assign);
            const rhs = right(scope, locals, assign);
            const arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Binary multiplication operation.
         * @param {function} left - The left operand function.
         * @param {function} right - The right operand function.
         * @param {Object} [context] - The context.
         * @returns {function} The binary multiplication function.
         */
        "binary*"(left, right, context) {
          return (scope, locals, assign) => {
            const arg = left(scope, locals, assign) * right(scope, locals, assign);
            return context ? { value: arg } : arg;
          };
        }
        "binary/"(left, right, context) {
          return (scope, locals, assign) => {
            const arg = left(scope, locals, assign) / right(scope, locals, assign);
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Binary division operation.
         * @param {function} left - The left operand function.
         * @param {function} right - The right operand function.
         * @param {Object} [context] - The context.
         * @returns {function} The binary division function.
         */
        "binary%"(left, right, context) {
          return (scope, locals, assign) => {
            const arg = left(scope, locals, assign) % right(scope, locals, assign);
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Binary strict equality operation.
         * @param {function} left - The left operand function.
         * @param {function} right - The right operand function.
         * @param {Object} [context] - The context.
         * @returns {function} The binary strict equality function.
         */
        "binary==="(left, right, context) {
          return (scope, locals, assign) => {
            const arg = left(scope, locals, assign) === right(scope, locals, assign);
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Binary strict inequality operation.
         * @param {function} left - The left operand function.
         * @param {function} right - The right operand function.
         * @param {Object} [context] - The context.
         * @returns {function} The binary strict inequality function.
         */
        "binary!=="(left, right, context) {
          return (scope, locals, assign) => {
            const arg = left(scope, locals, assign) !== right(scope, locals, assign);
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Binary equality operation.
         * @param {function} left - The left operand function.
         * @param {function} right - The right operand function.
         * @param {Object} [context] - The context.
         * @returns {function} The binary equality function.
         */
        "binary=="(left, right, context) {
          return (scope, locals, assign) => {
            const arg = left(scope, locals, assign) == right(scope, locals, assign);
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Binary inequality operation.
         * @param {function} left - The left operand function.
         * @param {function} right - The right operand function.
         * @param {Object} [context] - The context.
         * @returns {function} The binary inequality function.
         */
        "binary!="(left, right, context) {
          return (scope, locals, assign) => {
            const arg = left(scope, locals, assign) != right(scope, locals, assign);
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Binary less-than operation.
         * @param {function} left - The left operand function.
         * @param {function} right - The right operand function.
         * @param {Object} [context] - The context.
         * @returns {function} The binary less-than function.
         */
        "binary<"(left, right, context) {
          return (scope, locals, assign) => {
            const arg = left(scope, locals, assign) < right(scope, locals, assign);
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Binary greater-than operation.
         * @param {function} left - The left operand function.
         * @param {function} right - The right operand function.
         * @param {Object} [context] - The context.
         * @returns {function} The binary greater-than function.
         */
        "binary>"(left, right, context) {
          return (scope, locals, assign) => {
            const arg = left(scope, locals, assign) > right(scope, locals, assign);
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Binary less-than-or-equal-to operation.
         * @param {function} left - The left operand function.
         * @param {function} right - The right operand function.
         * @param {Object} [context] - The context.
         * @returns {function} The binary less-than-or-equal-to function.
         */
        "binary<="(left, right, context) {
          return (scope, locals, assign) => {
            const arg = left(scope, locals, assign) <= right(scope, locals, assign);
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Binary greater-than-or-equal-to operation.
         * @param {function} left - The left operand function.
         * @param {function} right - The right operand function.
         * @param {Object} [context] - The context.
         * @returns {function} The binary greater-than-or-equal-to function.
         */
        "binary>="(left, right, context) {
          return (scope, locals, assign) => {
            const arg = left(scope, locals, assign) >= right(scope, locals, assign);
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Binary logical AND operation.
         * @param {function} left - The left operand function.
         * @param {function} right - The right operand function.
         * @param {Object} [context] - The context.
         * @returns {function} The binary logical AND function.
         */
        "binary&&"(left, right, context) {
          return (scope, locals, assign) => {
            const arg = left(scope, locals, assign) && right(scope, locals, assign);
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Binary logical OR operation.
         * @param {function} left - The left operand function.
         * @param {function} right - The right operand function.
         * @param {Object} [context] - The context.
         * @returns {function} The binary logical OR function.
         */
        "binary||"(left, right, context) {
          return (scope, locals, assign) => {
            const arg = left(scope, locals, assign) || right(scope, locals, assign);
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Ternary conditional operation.
         * @param {function} test - The test function.
         * @param {function} alternate - The alternate function.
         * @param {function} consequent - The consequent function.
         * @param {Object} [context] - The context.
         * @returns {function} The ternary conditional function.
         */
        "ternary?:"(test, alternate, consequent, context) {
          return (scope, locals, assign) => {
            const arg = test(scope, locals, assign) ? alternate(scope, locals, assign) : consequent(scope, locals, assign);
            return context ? { value: arg } : arg;
          };
        }
        /**
         * Returns the value of a literal.
         * @param {*} value - The literal value.
         * @param {Object} [context] - The context.
         * @returns {import("./interface.ts").CompiledExpressionFunction} The function returning the literal value.
         */
        value(value, context) {
          return () => context ? { context: void 0, name: void 0, value } : value;
        }
        /**
         * Returns the value of an identifier.
         * @param {string} name - The identifier name.
         * @param {Object} [context] - The context.
         * @param {boolean|1} [create] - Whether to create the identifier if it does not exist.
         * @returns {import("./interface.ts").CompiledExpressionFunction} The function returning the identifier value.
         */
        identifier(name2, context, create) {
          return (scope, locals) => {
            const base = locals && name2 in locals ? locals : (scope && scope.$proxy) ?? scope;
            if (create && create !== 1 && base && base[name2] == null) {
              base[name2] = {};
            }
            let value = void 0;
            if (base) {
              value = base["$target"] ? base["$target"][name2] : base[name2];
            }
            if (context) {
              return { context: base, name: name2, value };
            }
            return value;
          };
        }
        /**
         * Returns the value of a computed member expression.
         * @param {function} left - The left operand function.
         * @param {function} right - The right operand function.
         * @param {Object} [context] - The context.
         * @param {boolean|1} [create] - Whether to create the member if it does not exist.
         * @returns {function} The function returning the computed member value.
         */
        computedMember(left, right, context, create) {
          return (scope, locals, assign) => {
            const lhs = left(scope, locals, assign);
            let rhs;
            let value;
            if (lhs != null) {
              rhs = right(scope, locals, assign);
              rhs = getStringValue(rhs);
              if (create && create !== 1) {
                if (lhs && !lhs[rhs]) {
                  lhs[rhs] = {};
                }
              }
              value = lhs[rhs];
            }
            if (context) {
              return { context: lhs, name: rhs, value };
            }
            return value;
          };
        }
        /**
         * Returns the value of a non-computed member expression.
         * @param {function} left - The left operand function.
         * @param {string} right - The right operand function.
         * @param {Object} [context] - The context.
         * @param {boolean|1} [create] - Whether to create the member if it does not exist.
         * @returns {function} The function returning the non-computed member value.
         */
        nonComputedMember(left, right, context, create) {
          return (scope, locals, assign) => {
            const lhs = left(scope, locals, assign);
            if (create && create !== 1) {
              if (lhs && lhs[right] == null) {
                lhs[right] = {};
              }
            }
            const value = lhs != null ? lhs[right] : void 0;
            if (context) {
              return { context: lhs, name: right, value };
            }
            return value;
          };
        }
      }
      function findConstantAndWatchExpressions(ast, $filter, parentIsPure) {
        let allConstants;
        let argsToWatch;
        let isStatelessFilter;
        let decoratedNode = (
          /** @type  {DecoratedASTNode} */
          ast
        );
        let decoratedLeft, decoratedRight, decoratedTest, decoratedAlternate, decoratedConsequent, decoratedObject, decoratedProperty, decoratedKey;
        const astIsPure = decoratedNode.isPure = isPure(ast, parentIsPure);
        switch (ast.type) {
          case ASTType.Program:
            allConstants = true;
            decoratedNode.body.forEach((expr) => {
              let decorated2 = findConstantAndWatchExpressions(
                expr.expression,
                $filter,
                astIsPure
              );
              allConstants = allConstants && decorated2.constant;
            });
            decoratedNode.constant = allConstants;
            return decoratedNode;
          case ASTType.Literal:
            decoratedNode.constant = true;
            decoratedNode.toWatch = [];
            return decoratedNode;
          case ASTType.UnaryExpression:
            var decorated = findConstantAndWatchExpressions(
              decoratedNode.argument,
              $filter,
              astIsPure
            );
            decoratedNode.constant = decorated.constant;
            decoratedNode.toWatch = decorated.toWatch;
            return decoratedNode;
          case ASTType.BinaryExpression:
            decoratedLeft = findConstantAndWatchExpressions(
              decoratedNode.left,
              $filter,
              astIsPure
            );
            decoratedRight = findConstantAndWatchExpressions(
              decoratedNode.right,
              $filter,
              astIsPure
            );
            decoratedNode.constant = decoratedLeft.constant && decoratedRight.constant;
            decoratedNode.toWatch = decoratedLeft.toWatch.concat(
              decoratedRight.toWatch
            );
            return decoratedNode;
          case ASTType.LogicalExpression:
            decoratedLeft = findConstantAndWatchExpressions(
              decoratedNode.left,
              $filter,
              astIsPure
            );
            decoratedRight = findConstantAndWatchExpressions(
              decoratedNode.right,
              $filter,
              astIsPure
            );
            decoratedNode.constant = decoratedLeft.constant && decoratedRight.constant;
            decoratedNode.toWatch = decoratedNode.constant ? [] : [ast];
            return decoratedNode;
          case ASTType.ConditionalExpression:
            decoratedTest = findConstantAndWatchExpressions(
              ast.test,
              $filter,
              astIsPure
            );
            decoratedAlternate = findConstantAndWatchExpressions(
              ast.alternate,
              $filter,
              astIsPure
            );
            decoratedConsequent = findConstantAndWatchExpressions(
              ast.consequent,
              $filter,
              astIsPure
            );
            decoratedNode.constant = decoratedTest.constant && decoratedAlternate.constant && decoratedConsequent.constant;
            decoratedNode.toWatch = decoratedNode.constant ? [] : [ast];
            return decoratedNode;
          case ASTType.Identifier:
            decoratedNode.constant = false;
            decoratedNode.toWatch = [ast];
            return decoratedNode;
          case ASTType.MemberExpression:
            decoratedObject = findConstantAndWatchExpressions(
              ast.object,
              $filter,
              astIsPure
            );
            if (ast.computed) {
              decoratedProperty = findConstantAndWatchExpressions(
                ast.property,
                $filter,
                astIsPure
              );
            }
            decoratedNode.constant = decoratedObject.constant && (!decoratedNode.computed || decoratedProperty.constant);
            decoratedNode.toWatch = decoratedNode.constant ? [] : [ast];
            return decoratedNode;
          case ASTType.CallExpression:
            isStatelessFilter = ast.filter ? isStateless($filter, ast.callee.name) : false;
            allConstants = isStatelessFilter;
            argsToWatch = [];
            ast.arguments.forEach((expr) => {
              decorated = findConstantAndWatchExpressions(expr, $filter, astIsPure);
              allConstants = allConstants && decorated.constant;
              argsToWatch.push.apply(argsToWatch, decorated.toWatch);
            });
            decoratedNode.constant = allConstants;
            decoratedNode.toWatch = isStatelessFilter ? argsToWatch : [decoratedNode];
            return decoratedNode;
          case ASTType.AssignmentExpression:
            decoratedLeft = findConstantAndWatchExpressions(
              ast.left,
              $filter,
              astIsPure
            );
            decoratedRight = findConstantAndWatchExpressions(
              ast.right,
              $filter,
              astIsPure
            );
            decoratedNode.constant = decoratedLeft.constant && decoratedRight.constant;
            decoratedNode.toWatch = [decoratedNode];
            return decoratedNode;
          case ASTType.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            ast.elements.forEach((expr) => {
              decorated = findConstantAndWatchExpressions(expr, $filter, astIsPure);
              allConstants = allConstants && decorated.constant;
              argsToWatch.push.apply(argsToWatch, decorated.toWatch);
            });
            decoratedNode.constant = allConstants;
            decoratedNode.toWatch = argsToWatch;
            return decoratedNode;
          case ASTType.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            ast.properties.forEach((property) => {
              decorated = findConstantAndWatchExpressions(
                property.value,
                $filter,
                astIsPure
              );
              allConstants = allConstants && decorated.constant;
              argsToWatch.push.apply(argsToWatch, decorated.toWatch);
              if (property.computed) {
                decoratedKey = findConstantAndWatchExpressions(
                  property.key,
                  $filter,
                  false
                );
                allConstants = allConstants && decoratedKey.constant;
                argsToWatch.push.apply(argsToWatch, decoratedKey.toWatch);
              }
            });
            decoratedNode.constant = allConstants;
            decoratedNode.toWatch = argsToWatch;
            return decoratedNode;
          case ASTType.ThisExpression:
            decoratedNode.constant = false;
            decoratedNode.toWatch = [];
            return decoratedNode;
          case ASTType.LocalsExpression:
            decoratedNode.constant = false;
            decoratedNode.toWatch = [];
            return decoratedNode;
        }
      }
      function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
          return {
            type: ASTType.AssignmentExpression,
            left: ast.body[0].expression,
            right: { type: ASTType.NGValueParameter },
            operator: "="
          };
        }
      }
      function plusFn(l, r) {
        if (typeof l === "undefined" || isObject(l)) return r;
        if (typeof r === "undefined" || isObject(r)) return l;
        return l + r;
      }
      function getInputs(body) {
        if (body.length !== 1) return;
        const lastExpression = (
          /** @type {DecoratedASTNode} */
          body[0].expression
        );
        const candidate = lastExpression.toWatch;
        if (candidate.length !== 1) return candidate;
        return candidate[0] !== lastExpression ? candidate : void 0;
      }
      function isPure(node, parentIsPure) {
        switch (node.type) {
          // Computed members might invoke a stateful toString()
          case ASTType.MemberExpression:
            if (node.computed) {
              return false;
            }
            break;
          // Unary always convert to primitive
          case ASTType.UnaryExpression:
            return PURITY_ABSOLUTE;
          // The binary + operator can invoke a stateful toString().
          case ASTType.BinaryExpression:
            return node.operator !== "+" ? PURITY_ABSOLUTE : false;
          // Functions / filters probably read state from within objects
          case ASTType.CallExpression:
            return false;
        }
        return void 0 === parentIsPure ? PURITY_RELATIVE : parentIsPure;
      }
      function isStateless($filter, filterName) {
        const fn = $filter(filterName);
        return !fn.$stateful;
      }
      function getStringValue(name2) {
        return `${name2}`;
      }
      function isAssignable(ast) {
        return ast.type === ASTType.Identifier || ast.type === ASTType.MemberExpression;
      }
      const $parseMinErr$1 = minErr("$parse");
      const ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "	",
        v: "\v",
        "'": "'",
        '"': '"'
      };
      const OPERATORS = new Set(
        "+ - * / % === !== == != < > <= >= && || ! = |".split(" ")
      );
      class Lexer {
        /**
         * Creates an instance of Lexer.
         * @param {LexerOptions} options - Lexer options.
         */
        constructor(options) {
          this.options = options;
        }
        /**
         * Tokenizes the input text.
         * @param {string} text Input text to lex.
         * @returns {Array<Token>} Array of tokens.
         */
        lex(text) {
          this.text = text;
          this.index = 0;
          this.tokens = [];
          while (this.index < this.text.length) {
            const ch = this.text.charAt(this.index);
            if (ch === '"' || ch === "'") {
              this.readString(ch);
            } else if (this.isNumber(ch) || ch === "." && this.isNumber(
              /** @type {string} */
              this.peek()
            )) {
              this.readNumber();
            } else if (this.isIdentifierStart && this.isIdentifierStart(this.peekMultichar())) {
              this.readIdent();
            } else if (this.is(ch, "(){}[].,;:?")) {
              this.tokens.push({ index: this.index, text: ch });
              this.index++;
            } else if (this.isWhitespace(ch)) {
              this.index++;
            } else {
              const ch2 = ch + this.peek();
              const ch3 = ch2 + this.peek(2);
              const op1 = OPERATORS.has(ch);
              const op2 = OPERATORS.has(ch2);
              const op3 = OPERATORS.has(ch3);
              if (op1 || op2 || op3) {
                const token = op3 ? ch3 : op2 ? ch2 : ch;
                this.tokens.push({ index: this.index, text: token, operator: true });
                this.index += token.length;
              } else {
                this.throwError(
                  "Unexpected next character ",
                  this.index,
                  this.index + 1
                );
              }
            }
          }
          return this.tokens;
        }
        /**
         * Checks if a character is contained in a set of characters.
         * @param {string} ch Character to check.
         * @param {string} chars Set of characters.
         * @returns {boolean} True if character is in the set, false otherwise.
         */
        is(ch, chars) {
          return chars.indexOf(ch) !== -1;
        }
        /**
         * Peeks at the next character in the text.
         * @param {number} [i=1] Number of characters to peek.
         * @returns {string|false} Next character or false if end of text.
         */
        peek(i) {
          const num = i || 1;
          return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
        }
        /**
         * Checks if a character is a number.
         * @param {string} ch Character to check.
         * @returns {boolean} True if character is a number, false otherwise.
         */
        isNumber(ch) {
          return ch >= "0" && ch <= "9" && typeof ch === "string";
        }
        /**
         * Checks if a character is whitespace.
         * @param {string} ch Character to check.
         * @returns {boolean} True if character is whitespace, false otherwise.
         */
        isWhitespace(ch) {
          return ch === " " || ch === "\r" || ch === "	" || ch === "\n" || ch === "\v";
        }
        /**
         * Checks if a character is a valid identifier start.
         * @param {string} ch Character to check.
         * @returns {boolean} True if character is a valid identifier start, false otherwise.
         */
        isIdentifierStart(ch) {
          return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch === "_" || ch === "$";
        }
        /**
         * Checks if a character is a valid identifier continuation.
         * @param {string} ch Character to check.
         * @returns {boolean} True if character is a valid identifier continuation, false otherwise.
         */
        isIdentifierContinue(ch) {
          return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch === "_" || ch === "$" || ch >= "0" && ch <= "9";
        }
        /**
         * Converts a character to its Unicode code point.
         * @param {string} ch Character to convert.
         * @returns {number} Unicode code point.
         */
        codePointAt(ch) {
          if (ch.length === 1) return ch.charCodeAt(0);
          return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888;
        }
        /**
         * Peeks at the next multicharacter sequence in the text.
         * @returns {string} Next multicharacter sequence.
         */
        peekMultichar() {
          const ch = this.text.charAt(this.index);
          const peek = this.peek();
          if (!peek) {
            return ch;
          }
          const cp1 = ch.charCodeAt(0);
          const cp2 = peek.charCodeAt(0);
          if (cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343) {
            return ch + peek;
          }
          return ch;
        }
        /**
         * Checks if a character is an exponent operator.
         * @param {string} ch Character to check.
         * @returns {boolean} True if character is an exponent operator, false otherwise.
         */
        isExpOperator(ch) {
          return ch === "-" || ch === "+" || this.isNumber(ch);
        }
        /**
         * Throws a lexer error.
         * @param {string} error Error message.
         * @param {number} [start] Start index.
         * @param {number} [end] End index.
         * @throws {Error} Lexer error.
         */
        throwError(error, start, end) {
          end = end || this.index;
          const colStr = isDefined(start) ? `s ${start}-${this.index} [${this.text.substring(start, end)}]` : ` ${end}`;
          throw $parseMinErr$1(
            "lexerr",
            `Lexer Error: ${error} at column${colStr} in expression [${this.text}].`
          );
        }
        /**
         * Reads and tokenizes a number from the text.
         * @return {void}
         */
        readNumber() {
          let number = "";
          const start = this.index;
          while (this.index < this.text.length) {
            const ch = this.text.charAt(this.index).toLowerCase();
            if (ch === "." || this.isNumber(ch)) {
              number += ch;
            } else {
              const peekCh = this.peek();
              if (ch === "e" && this.isExpOperator(
                /** @type {string} */
                peekCh
              )) {
                number += ch;
              } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) === "e") {
                number += ch;
              } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) === "e") {
                this.throwError("Invalid exponent");
              } else {
                break;
              }
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
          });
        }
        /**
         * Reads and tokenizes an identifier from the text.
         */
        readIdent() {
          const start = this.index;
          this.index += this.peekMultichar().length;
          while (this.index < this.text.length) {
            const ch = this.peekMultichar();
            if (this.isIdentifierContinue && !this.isIdentifierContinue(ch)) {
              break;
            }
            this.index += ch.length;
          }
          this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
          });
        }
        /**
         * Reads and tokenizes a string from the text.
         * @param {string} quote Quote character used for the string.
         */
        readString(quote) {
          const start = this.index;
          let string = "";
          let escape = false;
          this.index++;
          while (this.index < this.text.length) {
            const ch = this.text[this.index];
            if (escape) {
              if (ch === "u") {
                string += this.handleUnicodeEscape();
              } else {
                string += ESCAPE[ch] || ch;
              }
              escape = false;
            } else if (ch === "\\") {
              escape = true;
            } else if (ch === quote) {
              this.tokens.push({
                index: start,
                text: this.text.slice(start, this.index + 1),
                constant: true,
                value: string
              });
              this.index++;
              return;
            } else {
              string += ch;
            }
            this.index++;
          }
          this.throwError("Unterminated quote", start);
        }
        /**
         * @returns {string}
         */
        handleUnicodeEscape() {
          const hex = this.text.substring(this.index + 1, this.index + 5);
          if (!hex.match(/[\da-f]{4}/i)) {
            this.throwError(`Invalid unicode escape [\\u${hex}]`);
          }
          this.index += 4;
          return String.fromCharCode(parseInt(hex, 16));
        }
      }
      const $parseMinErr = minErr("$parse");
      const literals = /* @__PURE__ */ new Map([
        ["true", true],
        ["false", false],
        ["null", null],
        ["undefined", void 0]
      ]);
      class AST {
        /**
         * @param {import('../lexer/lexer.js').Lexer} lexer - The lexer instance for tokenizing input
         */
        constructor(lexer) {
          this.lexer = lexer;
          this.selfReferential = {
            this: { type: ASTType.ThisExpression },
            $locals: { type: ASTType.LocalsExpression }
          };
        }
        /**
         * Parses the input text and generates an AST.
         * @param {string} text - The input text to parse.
         * @returns {ASTNode} The root node of the AST.
         */
        ast(text) {
          this.text = text;
          this.tokens = this.lexer.lex(text);
          const value = this.program();
          if (this.tokens.length !== 0) {
            this.throwError("is an unexpected token", this.tokens[0]);
          }
          return value;
        }
        /**
         * Parses a program.
         * @returns {ASTNode} The program node.
         */
        program() {
          const body = [];
          let hasMore = true;
          while (hasMore) {
            if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]"))
              body.push(this.expressionStatement());
            if (!this.expect(";")) {
              hasMore = false;
            }
          }
          return { type: ASTType.Program, body };
        }
        /**
         * Parses an expression statement.
         * @returns {ASTNode} The expression statement node.
         */
        expressionStatement() {
          return {
            type: ASTType.ExpressionStatement,
            expression: this.filterChain()
          };
        }
        /**
         * Parses a filter chain.
         * @returns {ASTNode} The filter chain node.
         */
        filterChain() {
          let left = this.assignment();
          while (this.expect("|")) {
            left = this.filter(left);
          }
          return left;
        }
        /**
         * Parses an assignment expression.
         * @returns {ASTNode} The assignment expression node.
         */
        assignment() {
          let result = this.ternary();
          if (this.expect("=")) {
            if (!isAssignable(result)) {
              throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
            }
            result = {
              type: ASTType.AssignmentExpression,
              left: result,
              right: this.assignment(),
              operator: "="
            };
          }
          return result;
        }
        /**
         * Parses a ternary expression.
         * @returns {ASTNode} The ternary expression node.
         */
        ternary() {
          const test = this.logicalOR();
          let alternate;
          let consequent;
          if (this.expect("?")) {
            alternate = this.assignment();
            if (this.consume(":")) {
              consequent = this.assignment();
              return {
                type: ASTType.ConditionalExpression,
                test,
                alternate,
                consequent
              };
            }
          }
          return test;
        }
        /**
         * Parses a logical OR expression.
         * @returns {ASTNode} The logical OR expression node.
         */
        logicalOR() {
          let left = this.logicalAND();
          while (this.expect("||")) {
            left = {
              type: ASTType.LogicalExpression,
              operator: "||",
              left,
              right: this.logicalAND()
            };
          }
          return left;
        }
        /**
         * Parses a logical AND expression.
         * @returns {ASTNode} The logical AND expression node.
         */
        logicalAND() {
          let left = this.equality();
          while (this.expect("&&")) {
            left = {
              type: ASTType.LogicalExpression,
              operator: "&&",
              left,
              right: this.equality()
            };
          }
          return left;
        }
        /**
         * Parses an equality expression.
         * @returns {ASTNode} The equality expression node.
         */
        equality() {
          let left = this.relational();
          let token;
          while (token = this.expect("==", "!=", "===", "!==")) {
            left = {
              type: ASTType.BinaryExpression,
              operator: (
                /** @type {Token} */
                token.text
              ),
              left,
              right: this.relational()
            };
          }
          return left;
        }
        /**
         * Parses a relational expression.
         * @returns {ASTNode} The relational expression node.
         */
        relational() {
          let left = this.additive();
          let token;
          while (token = this.expect("<", ">", "<=", ">=")) {
            left = {
              type: ASTType.BinaryExpression,
              operator: (
                /** @type {Token} */
                token.text
              ),
              left,
              right: this.additive()
            };
          }
          return left;
        }
        /**
         * Parses an additive expression.
         * @returns {ASTNode} The additive expression node.
         */
        additive() {
          let left = this.multiplicative();
          let token;
          while (token = this.expect("+", "-")) {
            left = {
              type: ASTType.BinaryExpression,
              operator: (
                /** @type {Token} */
                token.text
              ),
              left,
              right: this.multiplicative()
            };
          }
          return left;
        }
        /**
         * Parses a multiplicative expression.
         * @returns {ASTNode} The multiplicative expression node.
         */
        multiplicative() {
          let left = this.unary();
          let token;
          while (token = this.expect("*", "/", "%")) {
            left = {
              type: ASTType.BinaryExpression,
              operator: (
                /** @type {import("../lexer/lexer.js").Token} */
                token.text
              ),
              left,
              right: this.unary()
            };
          }
          return left;
        }
        /**
         * Parses a unary expression.
         * @returns {ASTNode} The unary expression node.
         */
        unary() {
          let token;
          if (token = this.expect("+", "-", "!")) {
            return {
              type: ASTType.UnaryExpression,
              operator: (
                /** @type {import("../lexer/lexer.js").Token} */
                token.text
              ),
              prefix: true,
              argument: this.unary()
            };
          }
          return this.primary();
        }
        /**
         * Parses a primary expression.
         * @returns {ASTNode} The primary expression node.
         */
        primary() {
          let primary;
          if (this.expect("(")) {
            primary = this.filterChain();
            this.consume(")");
          } else if (this.expect("[")) {
            primary = this.arrayDeclaration();
          } else if (this.expect("{")) {
            primary = this.object();
          } else if (hasOwn(
            this.selfReferential,
            /** @type {import("../lexer/lexer.js").Token} */
            this.peek().text
          )) {
            primary = structuredClone(this.selfReferential[this.consume().text]);
          } else if (literals.has(
            /** @type {import("../lexer/lexer.js").Token} */
            this.peek().text
          )) {
            primary = {
              type: ASTType.Literal,
              value: literals.get(this.consume().text)
            };
          } else if (
            /** @type {import("../lexer/lexer.js").Token} */
            this.peek().identifier
          ) {
            primary = this.identifier();
          } else if (
            /** @type {import("../lexer/lexer.js").Token} */
            this.peek().constant
          ) {
            primary = this.constant();
          } else {
            this.throwError(
              "not a primary expression",
              /** @type {import("../lexer/lexer.js").Token} */
              this.peek()
            );
          }
          let next;
          while (next = this.expect("(", "[", ".")) {
            if (
              /** @type {import("../lexer/lexer.js").Token} */
              next.text === "("
            ) {
              primary = {
                type: ASTType.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
              };
              this.consume(")");
            } else if (
              /** @type {import("../lexer/lexer.js").Token} */
              next.text === "["
            ) {
              primary = {
                type: ASTType.MemberExpression,
                object: primary,
                property: this.assignment(),
                computed: true
              };
              this.consume("]");
            } else if (
              /** @type {import("../lexer/lexer.js").Token} */
              next.text === "."
            ) {
              primary = {
                type: ASTType.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: false
              };
            } else {
              this.throwError("IMPOSSIBLE");
            }
          }
          return primary;
        }
        /**
         * Parses a filter.
         * @param {ASTNode} baseExpression - The base expression to apply the filter to.
         * @returns {ASTNode} The filter node.
         */
        filter(baseExpression) {
          const args = [baseExpression];
          const result = {
            type: ASTType.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
          };
          while (this.expect(":")) {
            args.push(this.assignment());
          }
          return result;
        }
        /**
         * Parses function arguments.
         * @returns {ASTNode[]} The arguments array.
         */
        parseArguments() {
          const args = [];
          if (this.peekToken().text !== ")") {
            do {
              args.push(this.filterChain());
            } while (this.expect(","));
          }
          return args;
        }
        /**
         * Parses an identifier.
         * @returns {ASTNode} The identifier node.
         */
        identifier() {
          const token = this.consume();
          if (!token.identifier) {
            this.throwError("is not a valid identifier", token);
          }
          return { type: ASTType.Identifier, name: token.text };
        }
        /**
         * Parses a constant.
         * @returns {ASTNode} The constant node.
         */
        constant() {
          return { type: ASTType.Literal, value: this.consume().value };
        }
        /**
         * Parses an array declaration.
         * @returns {ASTNode} The array declaration node.
         */
        arrayDeclaration() {
          const elements = [];
          if (this.peekToken().text !== "]") {
            do {
              if (this.peek("]")) {
                break;
              }
              elements.push(this.assignment());
            } while (this.expect(","));
          }
          this.consume("]");
          return { type: ASTType.ArrayExpression, elements };
        }
        /**
         * Parses an object.
         * @returns {ASTNode} The object node.
         */
        object() {
          const properties = [];
          let property;
          if (this.peekToken().text !== "}") {
            do {
              if (this.peek("}")) {
                break;
              }
              property = { type: ASTType.Property, kind: "init" };
              if (
                /** @type {import("../lexer/lexer.js").Token} */
                this.peek().constant
              ) {
                property.key = this.constant();
                property.computed = false;
                this.consume(":");
                property.value = this.assignment();
              } else if (
                /** @type {import("../lexer/lexer.js").Token} */
                this.peek().identifier
              ) {
                property.key = this.identifier();
                property.computed = false;
                if (this.peek(":")) {
                  this.consume(":");
                  property.value = this.assignment();
                } else {
                  property.value = property.key;
                }
              } else if (this.peek("[")) {
                this.consume("[");
                property.key = this.assignment();
                this.consume("]");
                property.computed = true;
                this.consume(":");
                property.value = this.assignment();
              } else {
                this.throwError(
                  "invalid key",
                  /** @type {import("../lexer/lexer.js").Token} */
                  this.peek()
                );
              }
              properties.push(property);
            } while (this.expect(","));
          }
          this.consume("}");
          return { type: ASTType.ObjectExpression, properties };
        }
        /**
         * Throws a syntax error.
         * @param {string} msg - The error message.
         * @param {import("../lexer/lexer.js").Token} [token] - The token that caused the error.
         */
        throwError(msg, token) {
          throw $parseMinErr(
            "syntax",
            "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].",
            token.text,
            msg,
            token.index + 1,
            this.text,
            this.text.substring(token.index)
          );
        }
        /**
         * Consumes a token if it matches the expected type.
         * @param {string} [e1] - The expected token type.
         * @returns {import("../lexer/lexer.js").Token} The consumed token.
         */
        consume(e1) {
          if (this.tokens.length === 0) {
            throw $parseMinErr(
              "ueoe",
              "Unexpected end of expression: {0}",
              this.text
            );
          }
          const token = this.expect(e1);
          if (!token) {
            this.throwError(
              `is unexpected, expecting [${e1}]`,
              /** @type {import("../lexer/lexer.js").Token} */
              this.peek()
            );
          } else {
            return (
              /** @type  {import("../lexer/lexer.js").Token} */
              token
            );
          }
        }
        /**
         * Returns the next token without consuming it.
         * @returns {import("../lexer/lexer.js").Token} The next token.
         */
        peekToken() {
          if (this.tokens.length === 0) {
            throw $parseMinErr(
              "ueoe",
              "Unexpected end of expression: {0}",
              this.text
            );
          }
          return this.tokens[0];
        }
        /**
         * Checks if the next token matches any of the expected types.
         * @param {...string} [expected] - The expected token types.
         * @returns {import('../lexer/lexer.js').Token|boolean} The next token if it matches, otherwise false.
         */
        peek(...expected) {
          return this.peekAhead(0, ...expected);
        }
        /**
         * Checks if the token at the specified index matches any of the expected types.
         * @param {number} i - The index to check.
         * @param {...string} [expected] - The expected token types.
         * @returns {import("../lexer/lexer.js").Token|boolean} The token at the specified index if it matches, otherwise false.
         */
        peekAhead(i, ...expected) {
          if (this.tokens.length > i) {
            const token = this.tokens[i];
            const t = token.text;
            if (expected.includes(t) || !expected[0] && !expected[1] && !expected[2] && !expected[3]) {
              return token;
            }
          }
          return false;
        }
        /**
         * Consumes the next token if it matches any of the expected types.
         * @param {...string} [expected] - The expected token types.
         * @returns {import("../lexer/lexer.js").Token|boolean} The consumed token if it matches, otherwise false.
         */
        expect(...expected) {
          const token = this.peek(...expected);
          if (token) {
            this.tokens.shift();
            return token;
          }
          return false;
        }
      }
      class Parser {
        /**
         *
         * @param {import('../lexer/lexer.js').Lexer} lexer
         * @param {function(any):any} $filter
         */
        constructor(lexer, $filter) {
          this.ast = new AST(lexer);
          this.astCompiler = new ASTInterpreter($filter);
        }
        /**
         *
         * @param {string} exp - Expression to be parsed
         * @returns {import("../interface.ts").CompiledExpression}
         */
        parse(exp) {
          const { ast } = this.getAst(exp);
          const fn = this.astCompiler.compile(ast);
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        }
        /**
         * @param {string} exp - Expression to be parsed
         * @returns {ParsedAST}
         */
        getAst(exp) {
          exp = exp.trim();
          return {
            ast: this.ast.ast(exp)
          };
        }
      }
      function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === ASTType.Literal || ast.body[0].expression.type === ASTType.ArrayExpression || ast.body[0].expression.type === ASTType.ObjectExpression);
      }
      function isConstant(ast) {
        return ast.constant;
      }
      class ParseProvider {
        constructor() {
          const cache2 = /* @__PURE__ */ Object.create(null);
          let identStart;
          let identContinue;
          this.setIdentifierFns = function(identifierStart, identifierContinue) {
            identStart = identifierStart;
            identContinue = identifierContinue;
            return this;
          };
          this.$get = [
            "$filter",
            /**
             *
             * @param {(any) => any} $filter
             * @returns {import('./interface').ParseService}
             */
            function($filter) {
              const $lexerOptions = {
                isIdentifierStart: isFunction(identStart) && identStart,
                isIdentifierContinue: isFunction(identContinue) && identContinue
              };
              return $parse2;
              function $parse2(exp, interceptorFn) {
                let parsedExpression, cacheKey;
                switch (typeof exp) {
                  case "string":
                    exp = exp.trim();
                    cacheKey = exp;
                    parsedExpression = cache2[cacheKey];
                    if (!parsedExpression) {
                      const lexer = new Lexer($lexerOptions);
                      const parser = new Parser(lexer, $filter);
                      parsedExpression = parser.parse(exp);
                      cache2[cacheKey] = addWatchDelegate(parsedExpression);
                    }
                    return addInterceptor(parsedExpression, interceptorFn);
                  case "function":
                    return addInterceptor(exp, interceptorFn);
                  default:
                    return addInterceptor(() => {
                    }, interceptorFn);
                }
              }
              function addInterceptor(parsedExpression, interceptorFn) {
                if (!interceptorFn) {
                  return parsedExpression;
                }
                if (parsedExpression.$$interceptor) {
                  interceptorFn = chainInterceptors(
                    // @ts-ignore
                    parsedExpression.$$interceptor,
                    interceptorFn
                  );
                  parsedExpression = parsedExpression.$$intercepted;
                }
                let useInputs = false;
                const fn = function interceptedExpression(scope, locals, assign, inputs) {
                  const value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                  if (scope?.getter) {
                    return;
                  }
                  const res = isFunction(value) ? value() : value;
                  return interceptorFn(isProxy(res) ? res.$target : res);
                };
                fn.$$intercepted = parsedExpression;
                fn.$$interceptor = interceptorFn;
                fn.literal = parsedExpression.literal;
                fn.oneTime = parsedExpression.oneTime;
                fn.constant = parsedExpression.constant;
                fn.decoratedNode = parsedExpression.decoratedNode;
                if (!interceptorFn.$stateful) {
                  useInputs = !parsedExpression.inputs;
                  fn.inputs = parsedExpression.inputs ? (
                    // @ts-ignore
                    parsedExpression.inputs
                  ) : [parsedExpression];
                  if (!interceptorFn.$$pure) {
                    fn.inputs = fn.inputs.map(function(e) {
                      if (e.isPure === PURITY_RELATIVE) {
                        return function depurifier(s) {
                          return e(s);
                        };
                      }
                      return e;
                    });
                  }
                }
                return addWatchDelegate(fn);
              }
            }
          ];
        }
      }
      function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
        const unwatch = scope.$watch(
          () => {
            unwatch();
            return parsedExpression(scope);
          },
          listener,
          objectEquality
        );
        return unwatch;
      }
      function addWatchDelegate(parsedExpression) {
        if (parsedExpression.constant) {
          parsedExpression.$$watchDelegate = constantWatchDelegate;
        } else if (parsedExpression.inputs) {
          parsedExpression.$$watchDelegate = inputsWatchDelegate;
        }
        return parsedExpression;
      }
      function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression) {
        let inputExpressions = (
          /** @type {Function} */
          parsedExpression.inputs
        );
        let lastResult;
        if (inputExpressions.length === 1) {
          let oldInputValueOf = expressionInputDirtyCheck;
          let inputExpression = inputExpressions[0];
          return scope.$watch(
            // @ts-ignore
            ($scope) => {
              const newInputValue = inputExpression($scope);
              if (!expressionInputDirtyCheck(
                newInputValue,
                oldInputValueOf,
                inputExpression.isPure
              )) {
                lastResult = parsedExpression($scope, void 0, [newInputValue]);
                oldInputValueOf = newInputValue && getValueOf(newInputValue);
              }
              return lastResult;
            },
            listener,
            objectEquality
          );
        } else {
          const oldInputValueOfValues = [];
          const oldInputValues = [];
          for (let i = 0, ii = inputExpressions.length; i < ii; i++) {
            oldInputValueOfValues[i] = expressionInputDirtyCheck;
            oldInputValues[i] = null;
          }
          return scope.$watch(
            // @ts-ignore
            (scope2) => {
              let changed = false;
              for (let i = 0, ii = inputExpressions.length; i < ii; i++) {
                const newInputValue = inputExpressions[i](scope2);
                if (changed || (changed = !expressionInputDirtyCheck(
                  newInputValue,
                  oldInputValueOfValues[i],
                  inputExpressions[i].isPure
                ))) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(scope2, void 0, oldInputValues);
              }
              return lastResult;
            },
            listener,
            objectEquality
          );
        }
      }
      function chainInterceptors(first, second) {
        function chainedInterceptor(value) {
          return second(first(value));
        }
        chainedInterceptor.$stateful = first.$stateful || second.$stateful;
        chainedInterceptor.$$pure = first.$$pure && second.$$pure;
        return chainedInterceptor;
      }
      function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {
        if (newValue == null || oldValueOfValue == null) {
          return newValue === oldValueOfValue;
        }
        if (typeof newValue === "object") {
          newValue = getValueOf(newValue);
          if (typeof newValue === "object" && !compareObjectIdentity) {
            return false;
          }
        }
        return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
      }
      function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : {}.constructor.prototype.valueOf.call(value);
      }
      const $interpolateMinErr = minErr("$interpolate");
      function throwNoconcat(text) {
        throw $interpolateMinErr(
          "noconcat",
          "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce",
          text
        );
      }
      function interr(text, err2) {
        throw $interpolateMinErr(
          "interr",
          "Can't interpolate: {0}\n{1}",
          text,
          err2.toString()
        );
      }
      class InterpolateProvider {
        constructor() {
          this.startSymbol = "{{";
          this.endSymbol = "}}";
        }
        $get = [
          "$parse",
          "$sce",
          /**
           *
           * @param {import("../parse/interface.ts").ParseService} $parse
           * @param {*} $sce
           * @returns
           */
          function($parse2, $sce) {
            const provider2 = this;
            const startSymbolLength = provider2.startSymbol.length;
            const endSymbolLength = provider2.endSymbol.length;
            const escapedStartRegexp = new RegExp(
              provider2.startSymbol.replace(/./g, escape),
              "g"
            );
            const escapedEndRegexp = new RegExp(
              provider2.endSymbol.replace(/./g, escape),
              "g"
            );
            function escape(ch) {
              return `\\\\\\${ch}`;
            }
            function unescapeText(text) {
              return text.replace(escapedStartRegexp, provider2.startSymbol).replace(escapedEndRegexp, provider2.endSymbol);
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
              const contextAllowsConcatenation = trustedContext === $sce.URL || trustedContext === $sce.MEDIA_URL;
              if (!text.length || text.indexOf(provider2.startSymbol) === -1) {
                if (mustHaveExpression) return;
                let unescapedText = unescapeText(text);
                if (contextAllowsConcatenation) {
                  unescapedText = $sce.getTrusted(trustedContext, unescapedText);
                }
                const constantInterp = () => unescapedText;
                constantInterp.exp = text;
                constantInterp.expressions = [];
                constantInterp.$$watchDelegate = constantWatchDelegate;
                return constantInterp;
              }
              allOrNothing = !!allOrNothing;
              let startIndex;
              let endIndex;
              let index = 0;
              const expressions = [];
              let parseFns;
              const textLength = text.length;
              let exp;
              const concat2 = [];
              const expressionPositions = [];
              let singleExpression;
              while (index < textLength) {
                if ((startIndex = text.indexOf(provider2.startSymbol, index)) !== -1 && (endIndex = text.indexOf(
                  provider2.endSymbol,
                  startIndex + startSymbolLength
                )) !== -1) {
                  if (index !== startIndex) {
                    concat2.push(unescapeText(text.substring(index, startIndex)));
                  }
                  exp = text.substring(startIndex + startSymbolLength, endIndex);
                  expressions.push(exp);
                  index = endIndex + endSymbolLength;
                  expressionPositions.push(concat2.length);
                  concat2.push("");
                } else {
                  if (index !== textLength) {
                    concat2.push(unescapeText(text.substring(index)));
                  }
                  break;
                }
              }
              singleExpression = concat2.length === 1 && expressionPositions.length === 1;
              const interceptor = contextAllowsConcatenation && singleExpression ? void 0 : parseStringifyInterceptor;
              parseFns = expressions.map((exp2) => $parse2(exp2, interceptor));
              if (!mustHaveExpression || expressions.length) {
                const compute = function(values) {
                  for (let i = 0, ii = expressions.length; i < ii; i++) {
                    if (allOrNothing && isUndefined(values[i])) return;
                    concat2[expressionPositions[i]] = values[i];
                  }
                  if (contextAllowsConcatenation) {
                    return $sce.getTrusted(
                      trustedContext,
                      singleExpression ? concat2[0] : concat2.join("")
                    );
                  }
                  if (trustedContext && concat2.length > 1) {
                    throwNoconcat(text);
                  }
                  return concat2.join("");
                };
                return extend(
                  (context, cb) => {
                    let i = 0;
                    const ii = expressions.length;
                    const values = new Array(ii);
                    try {
                      for (; i < ii; i++) {
                        if (cb) {
                          const watchProp = expressions[i].trim();
                          context.$watch(watchProp, () => {
                            let vals = new Array(ii);
                            let j = 0;
                            for (; j < ii; j++) {
                              let fn = parseFns[j];
                              vals[j] = fn(context);
                            }
                            cb(compute(vals));
                          });
                        }
                        values[i] = parseFns[i](context);
                      }
                      return compute(values);
                    } catch (err2) {
                      interr(text, err2);
                    }
                  },
                  {
                    // Most likely we would need to register watches during interpolation
                    // all of these properties are undocumented for now
                    exp: text,
                    // just for compatibility with regular watchers created via $watch
                    expressions,
                    $$watchDelegate(scope, listener) {
                      let lastValue;
                      return scope.$watch(
                        parseFns,
                        function interpolateFnWatcher(values, oldValues) {
                          const currValue = compute(values);
                          listener.call(
                            this,
                            currValue,
                            values !== oldValues ? lastValue : currValue,
                            scope
                          );
                          lastValue = currValue;
                        }
                      );
                    }
                  }
                );
              }
              function parseStringifyInterceptor(value) {
                try {
                  value = trustedContext && !contextAllowsConcatenation ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                  return allOrNothing && !isDefined(value) ? value : stringify$1(value);
                } catch (err2) {
                  interr(text, err2);
                }
              }
            }
            $interpolate.startSymbol = function() {
              return provider2.startSymbol;
            };
            $interpolate.endSymbol = function() {
              return provider2.endSymbol;
            };
            return $interpolate;
          }
        ];
      }
      let lastCookies = {};
      let lastCookieString = "";
      function getCookies() {
        let cookieArray;
        let cookie;
        let i;
        let index;
        let name2;
        const currentCookieString = document.cookie;
        if (currentCookieString !== lastCookieString) {
          lastCookieString = currentCookieString;
          cookieArray = lastCookieString.split("; ");
          lastCookies = {};
          for (i = 0; i < cookieArray.length; i++) {
            cookie = cookieArray[i];
            index = cookie.indexOf("=");
            if (index > 0) {
              name2 = safeDecodeURIComponent(cookie.substring(0, index));
              if (isUndefined(lastCookies[name2])) {
                lastCookies[name2] = safeDecodeURIComponent(
                  cookie.substring(index + 1)
                );
              }
            }
          }
        }
        return lastCookies;
      }
      function safeDecodeURIComponent(str) {
        try {
          return decodeURIComponent(str);
        } catch {
          return str;
        }
      }
      const APPLICATION_JSON = "application/json";
      const CONTENT_TYPE_APPLICATION_JSON = {
        "Content-Type": `${APPLICATION_JSON};charset=utf-8`
      };
      const JSON_START = /^\[|^\{(?!\{)/;
      const JSON_ENDS = {
        "[": /]$/,
        "{": /}$/
      };
      const JSON_PROTECTION_PREFIX = /^\)]\}',?\n/;
      const $httpMinErr = minErr("$http");
      function serializeValue(v) {
        if (isObject(v)) {
          return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
      }
      function HttpParamSerializerProvider() {
        this.$get = function() {
          return function ngParamSerializer(params) {
            if (!params) return "";
            const parts = [];
            Object.keys(params).sort().forEach((key) => {
              const value = params[key];
              if (value === null || isUndefined(value) || isFunction(value)) return;
              if (Array.isArray(value)) {
                value.forEach((v) => {
                  parts.push(
                    `${encodeUriQuery(key)}=${encodeUriQuery(serializeValue(v))}`
                  );
                });
              } else {
                parts.push(
                  `${encodeUriQuery(key)}=${encodeUriQuery(serializeValue(value))}`
                );
              }
            });
            return parts.join("&");
          };
        };
      }
      function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
          const tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
          if (tempData) {
            const contentType = headers("Content-Type");
            const hasJsonContentType = contentType && contentType.indexOf(APPLICATION_JSON) === 0;
            if (hasJsonContentType || isJsonLike(tempData)) {
              try {
                data = fromJson(tempData);
              } catch (e) {
                if (!hasJsonContentType) {
                  return data;
                }
                throw $httpMinErr(
                  "baddata",
                  'Data must be a valid JSON object. Received: "{0}". Parse error: "{1}"',
                  data,
                  e
                );
              }
            }
          }
        }
        return data;
      }
      function isJsonLike(str) {
        const jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
      }
      function parseHeaders(headers) {
        const parsed = /* @__PURE__ */ Object.create(null);
        let i;
        function fillInParsed(key, val2) {
          if (key) {
            parsed[key] = parsed[key] ? `${parsed[key]}, ${val2}` : val2;
          }
        }
        if (isString(headers)) {
          headers.split("\n").forEach(
            /** @param {string} line */
            (line) => {
              i = line.indexOf(":");
              fillInParsed(
                line.substring(0, i).trim().toLowerCase(),
                trim(line.substring(i + 1))
              );
            }
          );
        } else if (isObject(headers)) {
          Object.entries(headers).forEach(([headerKey, headerVal]) => {
            fillInParsed(lowercase(headerKey), trim(headerVal));
          });
        }
        return parsed;
      }
      function headersGetter(headers) {
        let headersObj;
        return function(name2) {
          if (!headersObj) headersObj = parseHeaders(headers);
          if (name2) {
            let value = headersObj[lowercase(name2)];
            if (value === void 0) {
              value = null;
            }
            return value;
          }
          return headersObj;
        };
      }
      function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
          return fns(data, headers, status);
        }
        if (Array.isArray(fns)) {
          fns.forEach((fn) => {
            data = fn(data, headers, status);
          });
        }
        return data;
      }
      function isSuccess(status) {
        return status >= 200 && status < 300;
      }
      function HttpProvider() {
        const defaults2 = this.defaults = {
          // transform incoming response data
          transformResponse: [defaultHttpResponseTransform],
          // transform outgoing request data
          transformRequest: [
            function(d) {
              return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
            }
          ],
          // default headers
          headers: {
            common: {
              Accept: "application/json, text/plain, */*"
            },
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
          },
          xsrfCookieName: "XSRF-TOKEN",
          xsrfHeaderName: "X-XSRF-TOKEN",
          paramSerializer: "$httpParamSerializer"
        };
        let useApplyAsync = false;
        this.useApplyAsync = function(value) {
          if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
          }
          return useApplyAsync;
        };
        this.interceptors = [];
        this.xsrfTrustedOrigins = [];
        Object.defineProperty(this, "xsrfWhitelistedOrigins", {
          get() {
            return this.xsrfTrustedOrigins;
          },
          set(origins) {
            this.xsrfTrustedOrigins = origins;
          }
        });
        this.$get = [
          "$httpBackend",
          "$injector",
          "$sce",
          /**
           *
           * @param {*} $httpBackend
           * @param {import("../../core/di/internal-injector.js").InjectorService} $injector
           * @param {*} $sce
           * @returns
           */
          function($httpBackend, $injector, $sce) {
            const defaultCache = /* @__PURE__ */ new Map();
            defaults2.paramSerializer = isString(defaults2.paramSerializer) ? $injector.get(defaults2.paramSerializer) : defaults2.paramSerializer;
            const reversedInterceptors = [];
            this.interceptors.forEach((interceptorFactory) => {
              reversedInterceptors.unshift(
                isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory)
              );
            });
            const urlIsAllowedOrigin = urlIsAllowedOriginFactory(
              this.xsrfTrustedOrigins
            );
            function $http(requestConfig) {
              if (!isObject(requestConfig)) {
                throw minErr("$http")(
                  "badreq",
                  "Http request configuration must be an object.  Received: {0}",
                  requestConfig
                );
              }
              if (!isString($sce.valueOf(requestConfig.url))) {
                throw minErr("$http")(
                  "badreq",
                  "Http request configuration url must be a string or a $sce trusted object.  Received: {0}",
                  requestConfig.url
                );
              }
              const config = extend(
                {
                  method: "get",
                  transformRequest: defaults2.transformRequest,
                  transformResponse: defaults2.transformResponse,
                  paramSerializer: defaults2.paramSerializer
                },
                requestConfig
              );
              config.headers = mergeHeaders(requestConfig);
              config.method = uppercase(config.method);
              config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
              const requestInterceptors = [];
              const responseInterceptors = [];
              let promise = Promise.resolve(config);
              reversedInterceptors.forEach((interceptor) => {
                if (interceptor.request || interceptor.requestError) {
                  requestInterceptors.unshift(
                    interceptor.request,
                    interceptor.requestError
                  );
                }
                if (interceptor.response || interceptor.responseError) {
                  responseInterceptors.push(
                    interceptor.response,
                    interceptor.responseError
                  );
                }
              });
              promise = chainInterceptors2(promise, requestInterceptors);
              promise = promise.then(serverRequest);
              promise = chainInterceptors2(promise, responseInterceptors);
              return promise;
              function chainInterceptors2(promise2, interceptors) {
                for (let i = 0, ii = interceptors.length; i < ii; ) {
                  const thenFn = interceptors[i++];
                  const rejectFn = interceptors[i++];
                  promise2 = promise2.then(thenFn, rejectFn);
                }
                interceptors.length = 0;
                return promise2;
              }
              function executeHeaderFns(headers, config2) {
                let headerContent;
                const processedHeaders = {};
                Object.entries(headers).forEach(([header, headerFn]) => {
                  if (isFunction(headerFn)) {
                    headerContent = headerFn(config2);
                    if (headerContent != null) {
                      processedHeaders[header] = headerContent;
                    }
                  } else {
                    processedHeaders[header] = headerFn;
                  }
                });
                return processedHeaders;
              }
              function mergeHeaders(config2) {
                let defHeaders = defaults2.headers, reqHeaders = extend({}, config2.headers);
                defHeaders = extend(
                  {},
                  defHeaders.common,
                  defHeaders[lowercase(config2.method)]
                );
                Object.keys(defHeaders).forEach((defHeaderName) => {
                  const lowercaseDefHeaderName = lowercase(defHeaderName);
                  const hasMatchingHeader = Object.keys(reqHeaders).some(
                    (reqHeaderName) => {
                      return lowercase(reqHeaderName) === lowercaseDefHeaderName;
                    }
                  );
                  if (!hasMatchingHeader) {
                    reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                  }
                });
                return executeHeaderFns(reqHeaders, shallowCopy(config2));
              }
              function serverRequest(config2) {
                const { headers } = config2;
                const reqData = transformData(
                  config2.data,
                  headersGetter(headers),
                  void 0,
                  config2.transformRequest
                );
                if (isUndefined(reqData)) {
                  Object.keys(headers).forEach((header) => {
                    if (lowercase(header) === "content-type") {
                      delete headers[header];
                    }
                  });
                }
                if (isUndefined(config2.withCredentials) && !isUndefined(defaults2.withCredentials)) {
                  config2.withCredentials = defaults2.withCredentials;
                }
                return sendReq(config2, reqData).then(
                  transformResponse,
                  transformResponse
                );
              }
              function transformResponse(response) {
                const resp = extend({}, response);
                resp.data = transformData(
                  response.data,
                  response.headers,
                  response.status,
                  config.transformResponse
                );
                return isSuccess(response.status) ? resp : Promise.reject(resp);
              }
            }
            $http.pendingRequests = [];
            createShortMethods("get", "delete", "head");
            createShortMethodsWithData("post", "put", "patch");
            $http.defaults = defaults2;
            return $http;
            function createShortMethods(...names) {
              names.forEach((name2) => {
                $http[name2] = function(url, config) {
                  return $http(
                    extend({}, config || {}, {
                      method: name2,
                      url
                    })
                  );
                };
              });
            }
            function createShortMethodsWithData(...names) {
              names.forEach((name2) => {
                $http[name2] = function(url, data, config) {
                  return $http(
                    extend({}, config || {}, {
                      method: name2,
                      url,
                      data
                    })
                  );
                };
              });
            }
            function sendReq(config, reqData) {
              const { promise, resolve, reject } = Promise.withResolvers();
              let cache2;
              let cachedResp;
              const reqHeaders = config.headers;
              let { url } = config;
              if (!isString(url)) {
                url = $sce.valueOf(url);
              }
              url = buildUrl(url, config.paramSerializer(config.params));
              $http.pendingRequests.push(config);
              promise.then(removePendingReq, removePendingReq);
              if ((config.cache || defaults2.cache) && config.cache !== false && config.method === "GET") {
                cache2 = isObject(config.cache) ? config.cache : isObject(
                  /** @type {?} */
                  defaults2.cache
                ) ? (
                  /** @type {?} */
                  defaults2.cache
                ) : defaultCache;
              }
              if (cache2) {
                cachedResp = cache2.get(url);
                if (isDefined(cachedResp)) {
                  if (isPromiseLike(cachedResp)) {
                    cachedResp.then(
                      resolvePromiseWithResult,
                      resolvePromiseWithResult
                    );
                  } else {
                    if (Array.isArray(cachedResp)) {
                      resolvePromise(
                        cachedResp[1],
                        cachedResp[0],
                        shallowCopy(cachedResp[2]),
                        cachedResp[3],
                        cachedResp[4]
                      );
                    } else {
                      resolvePromise(cachedResp, 200, {}, "OK", "complete");
                    }
                  }
                } else {
                  cache2.set(url, promise);
                }
              }
              if (isUndefined(cachedResp)) {
                const xsrfValue = urlIsAllowedOrigin(config.url) ? getCookies()[config.xsrfCookieName || defaults2.xsrfCookieName] : void 0;
                if (xsrfValue) {
                  reqHeaders[config.xsrfHeaderName || defaults2.xsrfHeaderName] = xsrfValue;
                }
                $httpBackend(
                  config.method,
                  url,
                  reqData,
                  done,
                  reqHeaders,
                  config.timeout,
                  config.withCredentials,
                  config.responseType,
                  createApplyHandlers(config.eventHandlers),
                  createApplyHandlers(config.uploadEventHandlers)
                );
              }
              return promise;
              function createApplyHandlers(eventHandlers) {
                if (eventHandlers) {
                  const applyHandlers = {};
                  Object.entries(eventHandlers).forEach(([key, eventHandler]) => {
                    applyHandlers[key] = function(event) {
                      if (useApplyAsync) {
                        setTimeout(() => callEventHandler());
                      } else {
                        callEventHandler();
                      }
                      function callEventHandler() {
                        eventHandler(event);
                      }
                    };
                  });
                  return applyHandlers;
                }
              }
              function done(status, response, headersString, statusText, xhrStatus) {
                if (cache2) {
                  if (isSuccess(status)) {
                    cache2.set(url, [
                      status,
                      response,
                      parseHeaders(headersString),
                      statusText,
                      xhrStatus
                    ]);
                  } else {
                    cache2.delete(url);
                  }
                }
                function resolveHttpPromise() {
                  resolvePromise(
                    response,
                    status,
                    headersString,
                    statusText,
                    xhrStatus
                  );
                }
                if (useApplyAsync) {
                  setTimeout(resolveHttpPromise);
                } else {
                  resolveHttpPromise();
                }
              }
              function resolvePromise(response, status, headers, statusText, xhrStatus) {
                status = status >= -1 ? status : 0;
                (isSuccess(status) ? resolve : reject)({
                  data: response,
                  status,
                  headers: headersGetter(headers),
                  config,
                  statusText,
                  xhrStatus
                });
              }
              function resolvePromiseWithResult(result) {
                resolvePromise(
                  result.data,
                  result.status,
                  shallowCopy(result.headers()),
                  result.statusText,
                  result.xhrStatus
                );
              }
              function removePendingReq() {
                const idx = $http.pendingRequests.indexOf(config);
                if (idx !== -1) $http.pendingRequests.splice(idx, 1);
              }
            }
            function buildUrl(url, serializedParams) {
              if (serializedParams.length > 0) {
                url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
              }
              return url;
            }
          }
        ];
      }
      class HttpBackendProvider {
        constructor() {
          this.$get = () => createHttpBackend();
        }
      }
      function createHttpBackend() {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
          url = url || trimEmptyHash(window.location.href);
          const xhr = new XMLHttpRequest();
          let abortedByTimeout = false;
          let timeoutId;
          xhr.open(method, url, true);
          if (headers) {
            for (const [key, value] of Object.entries(headers)) {
              if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
              }
            }
          }
          xhr.onload = () => {
            let status = xhr.status || 0;
            const statusText = xhr.statusText || "";
            if (status === 0) {
              status = xhr.response ? 200 : new URL(url).protocol === "file:" ? 404 : 0;
            }
            completeRequest(
              status,
              xhr.response,
              xhr.getAllResponseHeaders(),
              statusText,
              "complete"
            );
          };
          xhr.onerror = () => completeRequest(-1, null, null, "", "error");
          xhr.ontimeout = () => completeRequest(-1, null, null, "", "timeout");
          xhr.onabort = () => {
            completeRequest(
              -1,
              null,
              null,
              "",
              abortedByTimeout ? "timeout" : "abort"
            );
          };
          if (eventHandlers) {
            for (const [key, handler] of Object.entries(eventHandlers)) {
              xhr.addEventListener(key, handler);
            }
          }
          if (uploadEventHandlers) {
            for (const [key, handler] of Object.entries(uploadEventHandlers)) {
              xhr.upload.addEventListener(key, handler);
            }
          }
          if (withCredentials) {
            xhr.withCredentials = true;
          }
          if (responseType) {
            try {
              xhr.responseType = responseType;
            } catch (e) {
              if (responseType !== "json") throw e;
            }
          }
          xhr.send(isUndefined(post) ? null : post);
          if (typeof timeout === "number" && timeout > 0) {
            timeoutId = setTimeout(() => timeoutRequest("timeout"), timeout);
          } else if (isPromiseLike(timeout)) {
            timeout.then(() => {
              timeoutRequest(isDefined(timeout["$$timeoutId"]) ? "timeout" : "abort");
            });
          }
          function timeoutRequest(reason) {
            abortedByTimeout = reason === "timeout";
            if (xhr) xhr.abort();
          }
          function completeRequest(status, response, headersString, statusText, xhrStatus) {
            if (isDefined(timeoutId)) {
              clearTimeout(timeoutId);
            }
            callback(status, response, headersString, statusText, xhrStatus);
          }
        };
      }
      const PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/;
      const $locationMinErr = minErr("$location");
      let urlUpdatedByLocation = false;
      let $$path;
      let $$search;
      let $$hash;
      class Location {
        /**
         * @param {string} appBase application base URL
         * @param {string} appBaseNoFile application base URL stripped of any filename
         * @param {boolean} [html5] Defaults to true
         * @param {string} [prefix] URL path prefix for html5 mode or hash prefix for hashbang mode
         */
        constructor(appBase, appBaseNoFile, html5 = true, prefix) {
          this.appBase = appBase;
          this.appBaseNoFile = appBaseNoFile;
          this.html5 = html5;
          this.basePrefix = html5 ? prefix || "" : void 0;
          this.hashPrefix = html5 ? void 0 : prefix;
          this.absUrl = "";
          this.$$url = void 0;
          this.$$updateBrowser = void 0;
        }
        /**
         * Change path, search and hash, when called with parameter and return `$location`.
         *
         * @param {string} url New URL without base prefix (e.g. `/path?a=b#hash`)
         * @return {Location} url
         */
        setUrl(url) {
          const match = PATH_MATCH.exec(url);
          if (match[1] !== void 0 || url === "") {
            this.setPath(match[1] || "");
          }
          if (match[2] !== void 0 || match[1] !== void 0 || url === "") {
            this.setSearch(match[3] || "");
          }
          this.setHash(match[5] || "");
          return this;
        }
        /**
         * Return URL (e.g. `/path?a=b#hash`) when called without any parameter.
         *
         * @return {string} url
         */
        getUrl() {
          return this.$$url;
        }
        /**
         * Change path parameter and return `$location`.
         *
         * @param {(string|number)} path New path
         * @return {Location}
         */
        setPath(path) {
          let newPath = path !== null ? path.toString() : "";
          $$path = newPath.charAt(0) === "/" ? newPath : `/${newPath}`;
          this.$$compose();
          return this;
        }
        /**
         *
         * Return path of current URL
         *
         * @return {string}
         */
        getPath() {
          return $$path;
        }
        /**
         * Changes the hash fragment when called with a parameter and returns `$location`.
         * @param {(string|number)} hash New hash fragment
         * @return {Location} hash
         */
        setHash(hash) {
          $$hash = hash !== null ? hash.toString() : "";
          this.$$compose();
          return this;
        }
        /**
         * Returns the hash fragment when called without any parameters.
         * @return {string} hash
         */
        getHash() {
          return $$hash;
        }
        /**
         * Sets the search part (as object) of current URL
         *
         * @param {string|Object} search New search params - string or hash object.
         * @param {(string|number|Array<string>|boolean)=} paramValue If search is a string or number, then paramValue will override only a single search property.
         * @returns {Object} Search object or Location object
         */
        setSearch(search, paramValue) {
          switch (arguments.length) {
            case 1:
              if (isString(search) || isNumber(search)) {
                search = search.toString();
                $$search = parseKeyValue(search);
              } else if (isObject(search)) {
                search = structuredClone(search, {});
                Object.entries(search).forEach(([key, value]) => {
                  if (value == null) delete search[key];
                });
                $$search = search;
              } else {
                throw $locationMinErr(
                  "isrcharg",
                  "The first argument of the `$location#search()` call must be a string or an object."
                );
              }
              break;
            default:
              if (isUndefined(paramValue) || paramValue === null) {
                delete $$search[search];
              } else {
                $$search[search] = paramValue;
              }
          }
          this.$$compose();
          return this;
        }
        /**
         * Returns the search part (as object) of current URL
         *
         * @returns {Object} Search object or Location object
         */
        getSearch() {
          return $$search;
        }
        /**
         * @private
         * Compose url and update `url` and `absUrl` property
         */
        $$compose() {
          this.$$url = normalizePath($$path, $$search, $$hash);
          this.absUrl = this.html5 ? this.appBaseNoFile + this.$$url.substring(1) : this.appBase + (this.$$url ? this.hashPrefix + this.$$url : "");
          urlUpdatedByLocation = true;
          setTimeout(() => this.$$updateBrowser && this.$$updateBrowser());
        }
        /**
         * Change the history state object when called with one parameter and return `$location`.
         * The state object is later passed to `pushState` or `replaceState`.
         * See {@link https://developer.mozilla.org/en-US/docs/Web/API/History/pushState#state|History.state}
         *
         * NOTE: This method is supported only in HTML5 mode and only in browsers supporting
         * the HTML5 History API (i.e. methods `pushState` and `replaceState`). If you need to support
         * older browsers (like IE9 or Android < 4.0), don't use this method.
         * @param {any} state
         * @returns {Location}
         */
        setState(state) {
          if (!this.html5) {
            throw $locationMinErr(
              "nostate",
              "History API state support is available only in HTML5 mode"
            );
          }
          this.$$state = isUndefined(state) ? null : state;
          urlUpdatedByLocation = true;
          return this;
        }
        /**
         * Return the history state object
         * @returns {any}
         */
        getState() {
          return this.$$state;
        }
        /**
         * @param {string} url
         * @param {string} relHref
         * @returns {boolean}
         */
        parseLinkUrl(url, relHref) {
          if (this.html5) {
            if (relHref && relHref[0] === "#") {
              this.setHash(relHref.slice(1));
              return true;
            }
            let appUrl;
            let prevAppUrl;
            let rewrittenUrl;
            if (isDefined(appUrl = stripBaseUrl(this.appBase, url))) {
              prevAppUrl = appUrl;
              if (this.basePrefix && isDefined(appUrl = stripBaseUrl(this.basePrefix, appUrl))) {
                rewrittenUrl = this.appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl);
              } else {
                rewrittenUrl = this.appBase + prevAppUrl;
              }
            } else if (isDefined(appUrl = stripBaseUrl(this.appBaseNoFile, url))) {
              rewrittenUrl = this.appBaseNoFile + appUrl;
            } else if (this.appBaseNoFile === `${url}/`) {
              rewrittenUrl = this.appBaseNoFile;
            }
            if (rewrittenUrl) {
              this.parse(rewrittenUrl);
            }
            return !!rewrittenUrl;
          } else {
            if (stripHash(this.appBase) === stripHash(url)) {
              this.parse(url);
              return true;
            }
            return false;
          }
        }
        /**
         * Parse given HTML5 (regular) URL string into properties
         * @param {string} url HTML5 URL
         */
        parse(url) {
          if (this.html5) {
            const pathUrl = stripBaseUrl(this.appBaseNoFile, url);
            if (!isString(pathUrl)) {
              throw $locationMinErr(
                "ipthprfx",
                'Invalid url "{0}", missing path prefix "{1}".',
                url,
                this.appBaseNoFile
              );
            }
            parseAppUrl(pathUrl, true);
            if (!$$path) {
              $$path = "/";
            }
            this.$$compose();
          } else {
            let removeWindowsDriveName = function(path, url2, base) {
              const windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
              let firstPathSegmentMatch;
              if (startsWith(url2, base)) {
                url2 = url2.replace(base, "");
              }
              if (windowsFilePathExp.exec(url2)) {
                return path;
              }
              firstPathSegmentMatch = windowsFilePathExp.exec(path);
              return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
            };
            const withoutBaseUrl = stripBaseUrl(this.appBase, url) || stripBaseUrl(this.appBaseNoFile, url);
            let withoutHashUrl;
            if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === "#") {
              withoutHashUrl = stripBaseUrl(this.hashPrefix, withoutBaseUrl);
              if (isUndefined(withoutHashUrl)) {
                withoutHashUrl = withoutBaseUrl;
              }
            } else {
              if (this.html5) {
                withoutHashUrl = withoutBaseUrl;
              } else {
                withoutHashUrl = "";
                if (isUndefined(withoutBaseUrl)) {
                  this.appBase = url;
                }
              }
            }
            parseAppUrl(withoutHashUrl, false);
            $$path = removeWindowsDriveName($$path, withoutHashUrl, this.appBase);
            this.$$compose();
          }
        }
      }
      class LocationProvider {
        constructor() {
          this.hashPrefixConf = "!";
          this.html5ModeConf = {
            enabled: true,
            requireBase: false,
            rewriteLinks: true
          };
          this.urlChangeListeners = [];
          this.urlChangeInit = false;
          this.cachedState = null;
          this.lastHistoryState = null;
          this.lastBrowserUrl = window.location.href;
          this.cacheState();
        }
        /// ///////////////////////////////////////////////////////////
        // URL API
        /// ///////////////////////////////////////////////////////////
        /**
         * Updates the browser's current URL and history state.
         *
         * @param {string|undefined} url - The target URL to navigate to.
         * @param {*} [state=null] - Optional history state object to associate with the new URL.
         * @returns {LocationProvider}
         */
        setUrl(url, state) {
          if (state === void 0) {
            state = null;
          }
          if (url) {
            url = new URL(url).href;
            if (this.lastBrowserUrl === url && this.lastHistoryState === state) {
              return this;
            }
            this.lastBrowserUrl = url;
            this.lastHistoryState = state;
            history.pushState(state, "", url);
            this.cacheState();
          }
        }
        /**
         * Returns the current URL with any empty hash (`#`) removed.
         * @return {string}
         */
        getBrowserUrl() {
          return trimEmptyHash(window.location.href);
        }
        /**
         * Returns the cached state.
         * @returns {History['state']} The cached state.
         */
        state() {
          return this.cachedState;
        }
        /**
         * Caches the current state.
         *
         * @private
         */
        cacheState() {
          const currentState = history.state ?? null;
          if (!equals$1(currentState, this.lastCachedState)) {
            this.cachedState = currentState;
            this.lastCachedState = currentState;
            this.lastHistoryState = currentState;
          }
        }
        /**
         * Fires the state or URL change event.
         */
        #fireStateOrUrlChange() {
          const prevLastHistoryState = this.lastHistoryState;
          this.cacheState();
          if (this.lastBrowserUrl === this.getBrowserUrl() && prevLastHistoryState === this.cachedState) {
            return;
          }
          this.lastBrowserUrl = this.getBrowserUrl();
          this.lastHistoryState = this.cachedState;
          this.urlChangeListeners.forEach((listener) => {
            listener(trimEmptyHash(window.location.href), this.cachedState);
          });
        }
        /**
         * Registers a callback to be called when the URL changes.
         *
         * @param {import("./interface.js").UrlChangeListener} callback - The callback function to register.
         * @returns void
         */
        #onUrlChange(callback) {
          if (!this.urlChangeInit) {
            window.addEventListener(
              "popstate",
              this.#fireStateOrUrlChange.bind(this)
            );
            window.addEventListener(
              "hashchange",
              this.#fireStateOrUrlChange.bind(this)
            );
            this.urlChangeInit = true;
          }
          this.urlChangeListeners.push(callback);
        }
        $get = [
          $injectTokens.$rootScope,
          $injectTokens.$rootElement,
          /**
           *
           * @param {import('../../core/scope/scope.js').Scope} $rootScope
           * @param {Element} $rootElement
           * @returns {Location}
           */
          ($rootScope, $rootElement) => {
            let $location;
            const baseHref = getBaseHref();
            const initialUrl = trimEmptyHash(window.location.href);
            let appBase;
            if (this.html5ModeConf.enabled) {
              if (!baseHref && this.html5ModeConf.requireBase) {
                throw $locationMinErr(
                  "nobase",
                  "$location in HTML5 mode requires a <base> tag to be present!"
                );
              }
              appBase = serverBase(initialUrl) + (baseHref || "/");
            } else {
              appBase = stripHash(initialUrl);
            }
            const appBaseNoFile = stripFile(appBase);
            $location = new Location(
              appBase,
              appBaseNoFile,
              this.html5ModeConf.enabled,
              `#${this.hashPrefixConf}`
            );
            $location.parseLinkUrl(initialUrl, initialUrl);
            $location.$$state = this.state();
            const IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            const setBrowserUrlWithFallback = (url, state) => {
              const oldUrl = $location.getUrl();
              const oldState = $location.$$state;
              try {
                this.setUrl(url, state);
                $location.$$state = this.state();
              } catch (e) {
                $location.setUrl(
                  /** @type {string} */
                  oldUrl
                );
                $location.$$state = oldState;
                throw e;
              }
            };
            $rootElement.addEventListener(
              "click",
              /** @param {MouseEvent} event */
              (event) => {
                const rewriteLinks = this.html5ModeConf.rewriteLinks;
                if (!rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.button === 2) {
                  return;
                }
                let elm = (
                  /** @type {HTMLAnchorElement} */
                  event.target
                );
                while (elm.nodeName.toLowerCase() !== "a") {
                  if (elm === $rootElement || !(elm = elm.parentElement)) return;
                }
                if (isString(rewriteLinks) && isUndefined(elm.getAttribute(
                  /** @type {string} */
                  rewriteLinks
                ))) {
                  return;
                }
                let absHref = elm.href;
                const relHref = elm.getAttribute("href") || elm.getAttribute("xlink:href");
                if (isObject(absHref) && absHref.toString() === "[object SVGAnimatedString]") {
                  const scvAnimatedString = (
                    /** @type {unknown} */
                    absHref
                  );
                  absHref = new URL(
                    /** @type {SVGAnimatedString } */
                    scvAnimatedString.animVal
                  ).href;
                }
                if (IGNORE_URI_REGEXP.test(absHref)) return;
                if (absHref && !elm.getAttribute("target") && !event.defaultPrevented) {
                  if ($location.parseLinkUrl(absHref, relHref)) {
                    event.preventDefault();
                  }
                }
              }
            );
            if ($location.absUrl !== initialUrl) {
              this.setUrl($location.absUrl, true);
            }
            let initializing = true;
            this.#onUrlChange((newUrl, newState) => {
              if (!startsWith(newUrl, appBaseNoFile)) {
                window.location.href = newUrl;
                return;
              }
              Promise.resolve().then(() => {
                const oldUrl = $location.absUrl;
                const oldState = $location.$$state;
                let defaultPrevented;
                $location.parse(newUrl);
                $location.$$state = newState;
                defaultPrevented = $rootScope.$broadcast(
                  "$locationChangeStart",
                  newUrl,
                  oldUrl,
                  newState,
                  oldState
                ).defaultPrevented;
                if ($location.absUrl !== newUrl) return;
                if (defaultPrevented) {
                  $location.parse(oldUrl);
                  $location.$$state = oldState;
                  setBrowserUrlWithFallback(oldUrl, oldState);
                } else {
                  initializing = false;
                  afterLocationChange(oldUrl, oldState);
                }
              });
            });
            const updateBrowser = () => {
              if (initializing || urlUpdatedByLocation) {
                urlUpdatedByLocation = false;
                const oldUrl = (
                  /** @type {string} */
                  this.getBrowserUrl()
                );
                const newUrl = $location.absUrl;
                const oldState = this.state();
                const urlOrStateChanged = !urlsEqual(oldUrl, newUrl) || $location.html5 && oldState !== $location.$$state;
                if (initializing || urlOrStateChanged) {
                  initializing = false;
                  setTimeout(() => {
                    const newUrl2 = $location.absUrl;
                    const { defaultPrevented } = $rootScope.$broadcast(
                      "$locationChangeStart",
                      newUrl2,
                      oldUrl,
                      $location.$$state,
                      oldState
                    );
                    if ($location.absUrl !== newUrl2) return;
                    if (defaultPrevented) {
                      $location.parse(oldUrl);
                      $location.$$state = oldState;
                    } else {
                      if (urlOrStateChanged) {
                        setBrowserUrlWithFallback(
                          newUrl2,
                          oldState === $location.$$state ? null : $location.$$state
                        );
                      }
                      afterLocationChange(oldUrl, oldState);
                    }
                  });
                }
              }
            };
            $location.$$updateBrowser = updateBrowser;
            updateBrowser();
            $rootScope.$on("$updateBrowser", updateBrowser);
            return $location;
            function afterLocationChange(oldUrl, oldState) {
              $rootScope.$broadcast(
                "$locationChangeSuccess",
                $location.absUrl,
                oldUrl,
                $location.$$state,
                oldState
              );
            }
          }
        ];
      }
      function encodePath(path) {
        const segments = path.split("/");
        let i = segments.length;
        while (i--) {
          const decodedSegment = decodeURIComponent(
            segments[i].replace(/%2F/gi, "/")
          );
          segments[i] = encodeUriSegment(decodedSegment);
        }
        return segments.join("/");
      }
      function decodePath(path, html5Mode) {
        const segments = path.split("/");
        let i = segments.length;
        while (i--) {
          segments[i] = decodeURIComponent(segments[i]);
          if (html5Mode) {
            segments[i] = segments[i].replace(/\//g, "%2F");
          }
        }
        return segments.join("/");
      }
      function normalizePath(pathValue, searchValue, hashValue) {
        const search = toKeyValue(searchValue);
        const hash = hashValue ? `#${encodeUriSegment(hashValue)}` : "";
        const path = encodePath(pathValue);
        return path + (search ? `?${search}` : "") + hash;
      }
      function parseAppUrl(url, html5Mode) {
        if (/^\s*[\\/]{2,}/.test(url)) {
          throw $locationMinErr("badpath", 'Invalid url "{0}".', url);
        }
        const prefixed = url.charAt(0) !== "/";
        if (prefixed) {
          url = `/${url}`;
        }
        const match = urlResolve(url);
        const path = prefixed && match.pathname.charAt(0) === "/" ? match.pathname.substring(1) : match.pathname;
        $$path = decodePath(path, html5Mode);
        $$search = parseKeyValue(match.search);
        $$hash = decodeURIComponent(match.hash);
        if ($$path && $$path.charAt(0) !== "/") {
          $$path = `/${$$path}`;
        }
      }
      function stripBaseUrl(base, url) {
        if (startsWith(url, base)) {
          return url.substring(base.length);
        }
      }
      function stripHash(url) {
        const index = url.indexOf("#");
        return index === -1 ? url : url.substring(0, index);
      }
      function stripFile(url) {
        return url.substring(0, stripHash(url).lastIndexOf("/") + 1);
      }
      function serverBase(url) {
        const start = url.indexOf("//") + 2;
        const slashIndex = url.indexOf("/", start);
        return slashIndex === -1 ? url : url.substring(0, slashIndex);
      }
      function urlsEqual(a, b) {
        return normalizeUrl(a) === normalizeUrl(b);
      }
      function normalizeUrl(url) {
        const anchor = document.createElement("a");
        anchor.href = url;
        let normalized = anchor.href;
        if (normalized.endsWith("/") && !/^https?:\/\/[^/]+\/$/.test(normalized)) {
          normalized = normalized.slice(0, -1);
        }
        if (normalized.endsWith("#")) {
          normalized = normalized.slice(0, -1);
        }
        return normalized;
      }
      class LogProvider {
        /** @private */
        constructor() {
          this.debug = false;
          this._override = null;
        }
        /**
         * Override the default {@link LogService} implemenation
         * @param {import("./interface.ts").LogServiceFactory} fn
         */
        setLogger(fn) {
          this._override = fn;
        }
        /** @private */
        formatError(arg) {
          if (isError(arg)) {
            if (arg.stack) {
              arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? `Error: ${arg.message}
${arg.stack}` : arg.stack;
            } else if (arg.sourceURL) {
              arg = `${arg.message}
${arg.sourceURL}:${arg.line}`;
            }
          }
          return arg;
        }
        /**
         * @private
         * @param {string} type
         */
        consoleLog(type) {
          const console2 = window.console || {};
          const logFn = console2[type] || console2.log || (() => {
          });
          return (...args) => {
            const formattedArgs = args.map((arg) => this.formatError(arg));
            return logFn.apply(console2, formattedArgs);
          };
        }
        /**
         * @returns {import("./interface.ts").LogService}
         */
        $get() {
          if (this._override) {
            return this._override();
          }
          return {
            log: this.consoleLog("log"),
            info: this.consoleLog("info"),
            warn: this.consoleLog("warn"),
            error: this.consoleLog("error"),
            debug: (() => {
              const fn = this.consoleLog("debug");
              return (...args) => {
                if (this.debug) {
                  fn.apply(this, args);
                }
              };
            })()
          };
        }
      }
      let uid = 0;
      function nextId() {
        uid += 1;
        return uid;
      }
      let $parse;
      let $exceptionHandler;
      const $postUpdateQueue = [];
      class RootScopeProvider {
        constructor() {
          this.rootScope = createScope();
        }
        $get = [
          "$exceptionHandler",
          "$parse",
          /**
           * @param {import('../../services/exception/exception-handler.js').ErrorHandler} exceptionHandler
           * @param {import('../parse/interface.ts').ParseService} parse
           */
          (exceptionHandler, parse2) => {
            $exceptionHandler = exceptionHandler;
            $parse = parse2;
            return this.rootScope;
          }
        ];
      }
      function createScope(target = {}, context) {
        if (isNull(target) || target[NONSCOPE] === true || (target.constructor && target.constructor[NONSCOPE]) === true) {
          return target;
        }
        if (typeof target === "object") {
          const proxy = new Proxy(target, context || new Scope());
          for (const key in target) {
            if (hasOwn(target, key)) {
              try {
                if (target.constructor.$nonscope && Array.isArray(target.constructor.$nonscope) && target.constructor.$nonscope.includes(key) || target.$nonscope && Array.isArray(target.$nonscope) && target.$nonscope.includes(key)) {
                } else {
                  target[key] = createScope(target[key], proxy.$handler);
                }
              } catch {
              }
            }
          }
          return proxy;
        } else {
          return target;
        }
      }
      const NONSCOPE = "$nonscope";
      class Scope {
        /**
         * Initializes the handler with the target object and a context.
         *
         * @param {Scope} [context] - The context containing listeners.
         * @param {Scope} [parent] - Custom parent.
         */
        constructor(context, parent) {
          this.context = context ? context.context ? context.context : context : void 0;
          this.watchers = context ? context.watchers : /* @__PURE__ */ new Map();
          this.$$listeners = /* @__PURE__ */ new Map();
          this.foreignListeners = context ? context.foreignListeners : /* @__PURE__ */ new Map();
          this.foreignProxies = context ? context.foreignProxies : /* @__PURE__ */ new Set();
          this.objectListeners = context ? context.objectListeners : /* @__PURE__ */ new WeakMap();
          this.functionListeners = context ? context.functionListeners : /* @__PURE__ */ new Map();
          this.$proxy = null;
          this.$handler = /** @type {Scope} */
          this;
          this.$target = null;
          this.$value = null;
          this.$children = [];
          this.$id = nextId();
          this.$root = context ? context.$root : (
            /** @type {Scope} */
            this
          );
          this.$parent = parent ? parent : (
            /** @type {Scope} */
            this.$root === /** @type {Scope} */
            this ? null : context
          );
          this.$$asyncQueue = [];
          this.filters = [];
          this.$$destroyed = false;
          this.scheduled = [];
        }
        /**
         * Intercepts and handles property assignments on the target object. If a new value is
         * an object, it will be recursively proxied.
         *
         * @param {Object} target - The target object.
         * @param {string} property - The name of the property being set.
         * @param {*} value - The new value being assigned to the property.
         * @param {Proxy} proxy - The proxy intercepting property access
         * @returns {boolean} - Returns true to indicate success of the operation.
         */
        set(target, property, value, proxy) {
          if (property === "undefined") {
            throw new Error("Attempting to set undefined property");
          }
          if (target.constructor?.$nonscope && Array.isArray(target.constructor.$nonscope) && target.constructor.$nonscope.includes(property) || target.$nonscope && Array.isArray(target.$nonscope) && target.$nonscope.includes(property)) {
            target[property] = value;
            return true;
          }
          this.$proxy = proxy;
          this.$target = target;
          const oldValue = target[property];
          if (oldValue !== void 0 && Number.isNaN(oldValue) && Number.isNaN(value)) {
            return true;
          }
          if (oldValue && oldValue[isProxySymbol]) {
            if (Array.isArray(value)) {
              if (oldValue !== value) {
                const listeners = this.watchers.get(property);
                if (listeners) {
                  this.#scheduleListener(listeners);
                }
                const foreignListeners = this.foreignListeners.get(property);
                if (foreignListeners) {
                  this.#scheduleListener(foreignListeners);
                }
              }
              if (this.objectListeners.get(target[property])) {
                this.objectListeners.delete(target[property]);
              }
              target[property] = createScope(value, this);
              this.objectListeners.set(target[property], [property]);
              return true;
            }
            if (isObject(value)) {
              if (hasOwn(target, property)) {
                Object.keys(oldValue).filter((x) => !value[x]).forEach((k) => {
                  delete oldValue[k];
                });
              }
              if (oldValue !== value) {
                const listeners = this.watchers.get(property);
                if (listeners) {
                  this.#scheduleListener(listeners);
                }
                const foreignListeners = this.foreignListeners.get(property);
                if (foreignListeners) {
                  this.#scheduleListener(foreignListeners);
                }
                this.#checkeListenersForAllKeys(value);
              }
              target[property] = createScope(value, this);
              return true;
            }
            if (isUndefined(value)) {
              let called = false;
              Object.keys(oldValue.$target).forEach((k) => {
                if (oldValue.$target[k]?.[isProxySymbol]) {
                  called = true;
                }
                delete oldValue[k];
              });
              target[property] = void 0;
              if (!called) {
                let listeners = this.watchers.get(property);
                if (listeners) {
                  this.#scheduleListener(listeners);
                }
              }
              return true;
            }
            if (isDefined(value)) {
              target[property] = value;
              let listeners = this.watchers.get(property);
              if (listeners) {
                this.#scheduleListener(listeners);
              }
              if (Array.isArray(target)) {
                if (this.objectListeners.has(proxy) && property !== "length") {
                  let keys = this.objectListeners.get(proxy);
                  keys.forEach((key) => {
                    const listeners2 = this.watchers.get(key);
                    if (listeners2) {
                      this.#scheduleListener(listeners2);
                    }
                  });
                }
              }
              return true;
            }
            return true;
          } else {
            if (isUndefined(target[property]) && isProxy(value)) {
              this.foreignProxies.add(value);
              target[property] = value;
              if (!this.watchers.has(property)) {
                return true;
              }
            }
            if (isUndefined(value)) {
              target[property] = value;
            } else {
              target[property] = createScope(value, this);
            }
            if (oldValue !== value) {
              let expectedTarget = this.$target;
              let listeners = [];
              if (isUndefined(oldValue) && isObject(target[property])) {
                if (!this.objectListeners.has(target[property])) {
                  this.objectListeners.set(target[property], [property]);
                }
                for (const k of Object.keys(value)) {
                  this.watchers.get(k)?.forEach((l) => listeners.push(l));
                  expectedTarget = value;
                }
              }
              if (Array.isArray(target)) {
                this.watchers.get("length")?.forEach((l) => listeners.push(l));
              }
              this.watchers.get(property)?.forEach((l) => listeners.push(l));
              if (listeners.length > 0) {
                this.#scheduleListener(listeners, (x) => {
                  return x.filter((x2) => {
                    if (!x2.watchProp) return true;
                    const wrapperExpr = x2.watchProp.split(".").slice(0, -1).join(".");
                    const expectedHandler = $parse(wrapperExpr)(
                      x2.originalTarget
                    )?.$handler;
                    return expectedTarget === expectedHandler?.$target;
                  });
                });
              }
              let foreignListeners = this.foreignListeners.get(property);
              if (!foreignListeners && this.$parent?.foreignListeners) {
                foreignListeners = this.$parent.foreignListeners.get(property);
              }
              if (foreignListeners) {
                if (this.$target.$$hashKey) {
                  foreignListeners = foreignListeners.filter(
                    (x) => x.originalTarget.$$hashKey ? x.originalTarget.$$hashKey == this.$target.$$hashKey : false
                  );
                }
                this.#scheduleListener(foreignListeners);
              }
            }
            if (this.objectListeners.has(proxy) && property !== "length") {
              let keys = this.objectListeners.get(proxy);
              keys.forEach((key) => {
                const listeners = this.watchers.get(key);
                if (listeners) {
                  if (this.scheduled !== listeners) {
                    this.#scheduleListener(listeners);
                  }
                }
              });
            }
            return true;
          }
        }
        /**
         * Intercepts property access on the target object. It checks for specific
         * properties (`watch` and `sync`) and binds their methods. For other properties,
         * it returns the value directly.
         *
         * @param {Object} target - The target object.
         * @param {string|number|symbol} property - The name of the property being accessed.
         * @param {Proxy} proxy - The proxy object being invoked
         * @returns {*} - The value of the property or a method if accessing `watch` or `sync`.
         */
        get(target, property, proxy) {
          if (property === "$$watchersCount") return calculateWatcherCount(this);
          if (property === isProxySymbol) return true;
          if (target[property] && isProxy(target[property])) {
            this.$proxy = target[property];
          } else {
            this.$proxy = proxy;
          }
          this.propertyMap = {
            $watch: this.$watch.bind(this),
            $new: this.$new.bind(this),
            $newIsolate: this.$newIsolate.bind(this),
            $destroy: this.$destroy.bind(this),
            $eval: this.$eval.bind(this),
            $apply: this.$apply.bind(this),
            $postUpdate: this.$postUpdate.bind(this),
            $isRoot: this.#isRoot.bind(this),
            $target: target,
            $proxy: this.$proxy,
            $on: this.$on.bind(this),
            $emit: this.$emit.bind(this),
            $broadcast: this.$broadcast.bind(this),
            $transcluded: this.$transcluded.bind(this),
            $handler: (
              /** @type {Scope} */
              this
            ),
            $parent: this.$parent,
            $root: this.$root,
            $children: this.$children,
            $id: this.$id,
            $merge: this.$merge.bind(this),
            $getById: this.$getById.bind(this)
          };
          if (Array.isArray(target) && ["pop", "shift", "unshift"].includes(
            /** @type { string } */
            property
          )) {
            if (this.objectListeners.has(proxy)) {
              let keys = this.objectListeners.get(this.$proxy);
              keys.forEach((key) => {
                const listeners = this.watchers.get(key);
                if (listeners) {
                  this.scheduled = listeners;
                }
              });
            }
            if (property === "unshift") {
              this.#scheduleListener(this.scheduled);
            }
          }
          if (hasOwn(this.propertyMap, property)) {
            this.$target = target;
            return this.propertyMap[property];
          } else {
            return target[property];
          }
        }
        deleteProperty(target, property) {
          if (target[property] && target[property][isProxySymbol]) {
            target[property] = void 0;
            let listeners = this.watchers.get(property);
            if (listeners) {
              this.#scheduleListener(listeners);
            }
            if (this.objectListeners.has(this.$proxy)) {
              let keys = this.objectListeners.get(this.$proxy);
              keys.forEach((key) => {
                listeners = this.watchers.get(key);
                if (listeners) {
                  this.#scheduleListener(listeners);
                }
              });
            }
            if (this.scheduled) {
              this.#scheduleListener(this.scheduled);
              this.scheduled = [];
            }
            return true;
          }
          delete target[property];
          if (this.objectListeners.has(this.$proxy)) {
            let keys = this.objectListeners.get(this.$proxy);
            keys.forEach((key) => {
              const listeners = this.watchers.get(key);
              if (listeners) {
                this.#scheduleListener(listeners);
              }
            });
          } else {
            const listeners = this.watchers.get(property);
            if (listeners) {
              this.#scheduleListener(listeners, target[property]);
            }
          }
          return true;
        }
        /** @internal **/
        #checkeListenersForAllKeys(value) {
          if (isUndefined(value)) {
            return;
          }
          Object.keys(value).forEach((k) => {
            const listeners = this.watchers.get(k);
            if (listeners) {
              this.#scheduleListener(listeners);
            }
            if (isObject(value[k])) {
              this.#checkeListenersForAllKeys(value[k]);
            }
          });
        }
        /**
         * @param {Listener[]} listeners
         * @param {Function} filter
         */
        #scheduleListener(listeners, filter2 = (val2) => val2) {
          Promise.resolve().then(() => {
            let index = 0;
            let filteredListeners = filter2(listeners);
            while (index < filteredListeners.length) {
              const listener = filteredListeners[index];
              if (listener.foreignListener) {
                listener.foreignListener.#notifyListener(listener, this.$target);
              } else {
                this.#notifyListener(listener, this.$target);
              }
              index++;
            }
          });
        }
        /**
         * Registers a watcher for a property along with a listener function. The listener
         * function is invoked when changes to that property are detected.
         *
         * @param {string} watchProp - An expression to be watched in the context of this model.
         * @param {ListenerFunction} [listenerFn] - A function to execute when changes are detected on watched context.
         * @param {boolean} [lazy] - A flag to indicate if the listener should be invoked immediately. Defaults to false.
         */
        $watch(watchProp, listenerFn, lazy = false) {
          assert(isString(watchProp), "Watched property required");
          watchProp = watchProp.trim();
          const get = $parse(watchProp);
          if (get.constant) {
            if (listenerFn) {
              Promise.resolve().then(() => {
                let res = get();
                while (isFunction(res)) {
                  res = res();
                }
                listenerFn(res, this.$target);
              });
            }
            return () => {
            };
          }
          const listener = {
            originalTarget: this.$target,
            listenerFn,
            watchFn: get,
            scopeId: this.$id,
            id: nextUid(),
            property: []
          };
          let key = get.decoratedNode.body[0].expression.name;
          let keySet = [];
          let type = get.decoratedNode.body[0].expression.type;
          switch (type) {
            // 1
            case ASTType.Program: {
              throw new Error("Unsupported type " + type);
            }
            // 2
            case ASTType.ExpressionStatement: {
              throw new Error("Unsupported type " + type);
            }
            // 3
            case ASTType.AssignmentExpression:
              if (!listenerFn) {
                let res = get(this.$target);
                while (isFunction(res)) {
                  res = res(this.$target);
                }
                Promise.resolve().then(res);
                return () => {
                };
              }
              key = get.decoratedNode.body[0].expression.left.name;
              break;
            // 4
            case ASTType.ConditionalExpression: {
              key = get.decoratedNode.body[0].expression.toWatch[0]?.test?.name;
              listener.property.push(key);
              break;
            }
            // 5
            case ASTType.LogicalExpression: {
              let keys = [];
              keys.push(get.decoratedNode.body[0].expression.left.toWatch[0]?.name);
              keys.push(get.decoratedNode.body[0].expression.right.toWatch[0]?.name);
              keys.forEach((key2) => {
                this.#registerKey(key2, listener);
              });
              return () => {
                keys.forEach((key2) => {
                  this.#deregisterKey(key2, listener.id);
                });
              };
            }
            // 6
            case ASTType.BinaryExpression: {
              let expr = get.decoratedNode.body[0].expression.toWatch[0];
              key = expr.property ? expr.property.name : expr.name;
              if (!key) {
                throw new Error("Unable to determine key");
              }
              listener.property.push(key);
              break;
            }
            // 7
            case ASTType.UnaryExpression: {
              let expr = get.decoratedNode.body[0].expression.toWatch[0];
              key = expr.property ? expr.property.name : expr.name;
              if (!key) {
                throw new Error("Unable to determine key");
              }
              listener.property.push(key);
              break;
            }
            // 8 function
            case ASTType.CallExpression: {
              let keys = [];
              get.decoratedNode.body[0].expression.toWatch.forEach((x) => {
                if (isDefined(x)) {
                  keys.push(x.name);
                }
              });
              keys.forEach((key2) => {
                this.#registerKey(key2, listener);
                this.#scheduleListener([listener]);
              });
              return () => {
                keys.forEach((key2) => {
                  this.#deregisterKey(key2, listener.id);
                });
              };
            }
            // 9
            case ASTType.MemberExpression: {
              key = get.decoratedNode.body[0].expression.property.name;
              if (!key) {
                key = get.decoratedNode.body[0].expression.object.name;
              }
              listener.property.push(key);
              if (watchProp !== key) {
                listener.watchProp = watchProp;
                let potentialProxy = $parse(
                  watchProp.split(".").slice(0, -1).join(".")
                )(listener.originalTarget);
                if (potentialProxy && this.foreignProxies.has(potentialProxy)) {
                  potentialProxy.$handler.#registerForeignKey(key, listener);
                  potentialProxy.$handler.#scheduleListener([listener]);
                  return () => {
                    return potentialProxy.$handler.#deregisterKey(key, listener.id);
                  };
                }
              }
              break;
            }
            // 10
            case ASTType.Identifier: {
              listener.property.push(get.decoratedNode.body[0].expression.name);
              break;
            }
            // 11
            case ASTType.Literal: {
              throw new Error("Unsupported type " + type);
            }
            // 12
            case ASTType.ArrayExpression: {
              let keys = get.decoratedNode.body[0].expression.elements.map((x) => {
                switch (x.type) {
                  case 11:
                    return x.value;
                  default:
                    return x.toWatch[0].name;
                }
              }).filter((x) => !!x);
              keys.forEach((key2) => {
                this.#registerKey(key2, listener);
                this.#scheduleListener([listener]);
              });
              return () => {
                keys.forEach((key2) => {
                  this.#deregisterKey(key2, listener.id);
                });
              };
            }
            // 13
            case ASTType.Property: {
              throw new Error("Unsupported type " + type);
            }
            // 14
            case ASTType.ObjectExpression: {
              get.decoratedNode.body[0].expression.properties.forEach((prop) => {
                if (prop.key.isPure === false) {
                  keySet.push(prop.key.name);
                  listener.property.push(key);
                } else {
                  if (prop.value.name) {
                    keySet.push(prop.value.name);
                    listener.property.push(key);
                  } else {
                    const target = get.decoratedNode.body[0].expression.toWatch[0];
                    key = target.property ? target.property.name : target.name;
                    listener.property.push(key);
                  }
                }
              });
              break;
            }
            // 15
            case ASTType.ThisExpression: {
              throw new Error("Unsupported type " + type);
            }
            // 16
            case ASTType.LocalsExpression: {
              throw new Error("Unsupported type " + type);
            }
            // 17
            case ASTType.NGValueParameter: {
              throw new Error("Unsupported type " + type);
            }
          }
          let listenerObject = listener.watchFn(this.$target);
          if (isObject(listenerObject)) {
            this.objectListeners.set(listenerObject, [key]);
          }
          if (keySet.length > 0) {
            keySet.forEach((key2) => {
              this.#registerKey(key2, listener);
            });
          } else {
            this.#registerKey(key, listener);
          }
          if (!lazy) {
            this.#scheduleListener([listener]);
          }
          return () => {
            if (keySet.length > 0) {
              let res = true;
              keySet.forEach((key2) => {
                let success = this.#deregisterKey(key2, listener.id);
                if (!success) {
                  res = false;
                }
              });
              return res;
            } else {
              return this.#deregisterKey(key, listener.id);
            }
          };
        }
        $new(childInstance) {
          let child;
          if (childInstance) {
            if (Object.getPrototypeOf(childInstance) === Object.prototype) {
              Object.setPrototypeOf(childInstance, this.$target);
            } else {
              if (Object.getPrototypeOf(childInstance) == this.$target) {
                Object.setPrototypeOf(childInstance, this.$target);
              } else {
                Object.setPrototypeOf(
                  Object.getPrototypeOf(childInstance) || childInstance,
                  this.$target
                );
              }
            }
            child = childInstance;
          } else {
            child = Object.create(this.$target);
          }
          const proxy = new Proxy(child, new Scope(this));
          this.$children.push(proxy);
          return proxy;
        }
        $newIsolate(instance) {
          let child = instance ? Object.create(instance) : /* @__PURE__ */ Object.create(null);
          const proxy = new Proxy(child, new Scope(this, this.$root));
          this.$children.push(proxy);
          return proxy;
        }
        $transcluded(parentInstance) {
          let child = Object.create(this.$target);
          const proxy = new Proxy(child, new Scope(this, parentInstance));
          this.$children.push(proxy);
          return proxy;
        }
        /** @internal **/
        #registerKey(key, listener) {
          if (this.watchers.has(key)) {
            this.watchers.get(key).push(listener);
          } else {
            this.watchers.set(key, [listener]);
          }
        }
        /** @internal **/
        #registerForeignKey(key, listener) {
          if (this.foreignListeners.has(key)) {
            this.foreignListeners.get(key).push(listener);
          } else {
            this.foreignListeners.set(key, [listener]);
          }
        }
        #deregisterKey(key, id2) {
          const listenerList = this.watchers.get(key);
          if (!listenerList) return false;
          const index = listenerList.findIndex((x) => x.id === id2);
          if (index === -1) return false;
          listenerList.splice(index, 1);
          if (listenerList.length) {
            this.watchers.set(key, listenerList);
          } else {
            this.watchers.delete(key);
          }
          return true;
        }
        // deregisterForeignKey(key, id) {
        //   const listenerList = this.foreignListeners.get(key);
        //   if (!listenerList) return false;
        //   const index = listenerList.findIndex((x) => x.id === id);
        //   if (index === -1) return false;
        //   listenerList.splice(index, 1);
        //   if (listenerList.length) {
        //     this.foreignListeners.set(key, listenerList);
        //   } else {
        //     this.foreignListeners.delete(key);
        //   }
        //   return true;
        // }
        $eval(expr, locals) {
          const fn = $parse(expr);
          const res = fn(this, locals);
          if (isUndefined(res) || res === null) {
            return res;
          }
          if (res["name"] === Object.hasOwnProperty["name"]) {
            return res;
          }
          if (isFunction(res)) {
            return res();
          }
          if (Number.isNaN(res)) {
            return 0;
          }
          return res;
        }
        /**
         * @param {Object} newTarget
         */
        $merge(newTarget) {
          Object.entries(newTarget).forEach(([key, value]) => {
            this.set(this.$target, key, value, this.$proxy);
          });
        }
        /**
         * @param {import('../../interface.js').Expression} expr
         * @returns {any}
         */
        $apply(expr) {
          try {
            return $parse(expr)(this.$proxy);
          } catch (e) {
            $exceptionHandler(e);
          }
        }
        /**
         * @param {string} name
         * @param {Function} listener
         * @returns {(function(): void)|*}
         */
        $on(name2, listener) {
          let namedListeners = this.$$listeners.get(name2);
          if (!namedListeners) {
            namedListeners = [];
            this.$$listeners.set(name2, namedListeners);
          }
          namedListeners.push(listener);
          return () => {
            const indexOfListener = namedListeners.indexOf(listener);
            if (indexOfListener !== -1) {
              namedListeners.splice(indexOfListener, 1);
              if (namedListeners.length == 0) {
                this.$$listeners.delete(name2);
              }
            }
          };
        }
        /**
         * @param {string} name
         * @param  {...any} args
         * @returns {void}
         */
        $emit(name2, ...args) {
          return this.#eventHelper(
            { name: name2, event: void 0, broadcast: false },
            ...args
          );
        }
        /**
         * @param {string} name
         * @param  {...any} args
         * @returns {any}
         */
        $broadcast(name2, ...args) {
          return this.#eventHelper(
            { name: name2, event: void 0, broadcast: true },
            ...args
          );
        }
        /**
         * @internal
         * @returns {any}
         */
        #eventHelper({ name: name2, event, broadcast }, ...args) {
          if (!broadcast) {
            if (!this.$$listeners.has(name2)) {
              if (this.$parent) {
                return this.$parent.$handler.#eventHelper(
                  { name: name2, event, broadcast },
                  ...args
                );
              }
              return;
            }
          }
          if (event) {
            event.currentScope = this.$target;
          } else {
            event = event || {
              name: name2,
              targetScope: this.$target,
              currentScope: this.$target,
              stopped: false,
              stopPropagation() {
                event.stopped = true;
              },
              preventDefault() {
                event.defaultPrevented = true;
              },
              defaultPrevented: false
            };
          }
          const listenerArgs = concat([event], [event].concat(args), 1);
          let listeners = this.$$listeners.get(name2);
          if (listeners) {
            let length = listeners.length;
            for (let i = 0; i < length; i++) {
              try {
                let cb = listeners[i];
                cb.apply(null, listenerArgs);
                if (listeners.length !== length) {
                  if (listeners.length < length) {
                    i--;
                  }
                  length = listeners.length;
                }
              } catch (e) {
                $exceptionHandler(e);
              }
            }
          }
          event.currentScope = null;
          if (event.stopped) {
            return event;
          }
          if (broadcast) {
            if (this.$children.length > 0) {
              this.$children.forEach((child) => {
                event = child["$handler"].#eventHelper(
                  { name: name2, event, broadcast },
                  ...args
                );
              });
            }
            return event;
          } else {
            if (this.$parent) {
              return this.$parent.#eventHelper(
                { name: name2, event, broadcast },
                ...args
              );
            } else {
              return event;
            }
          }
        }
        /**
         * @internal
         * @returns {boolean}
         */
        #isRoot() {
          return this.$root == /** @type {Scope} */
          this;
        }
        $postUpdate(fn) {
          $postUpdateQueue.push(fn);
        }
        $destroy() {
          if (this.$$destroyed) return;
          this.$broadcast("$destroy");
          Array.from(this.watchers.entries()).forEach(([key, val2]) => {
            this.watchers.set(
              key,
              val2.filter((x) => x.scopeId !== this.$id)
            );
          });
          if (this.#isRoot()) {
            this.watchers.clear();
          } else {
            let i = this.$parent.$children.filter((x) => x.$id == this.$id)[0];
            this.$parent.$children.splice(this.$parent.$children.indexOf(i), 1);
          }
          this.$$listeners.clear();
          this.$$destroyed = true;
        }
        /**
         * @internal
         * @param {Listener} listener - The property path that was changed.
         */
        #notifyListener(listener, target) {
          const { originalTarget, listenerFn, watchFn } = listener;
          try {
            let newVal = watchFn(originalTarget);
            if (isUndefined(newVal)) {
              newVal = watchFn(target);
            }
            if (isFunction(newVal)) {
              newVal = newVal(originalTarget);
            }
            if (Array.isArray(newVal)) {
              newVal.forEach((x, index) => {
                if (isFunction(x)) {
                  newVal[index] = x(originalTarget);
                }
              });
            }
            listenerFn(newVal, originalTarget);
            this.$$asyncQueue.forEach((x) => {
              if (x.handler.$id == this.$id) {
                Promise.resolve().then(x.fn(x.handler, x.locals));
              }
            });
            while ($postUpdateQueue.length) {
              $postUpdateQueue.shift()();
            }
          } catch (e) {
            $exceptionHandler(e);
          }
        }
        /**
         * Searches the scope instance
         *
         * @param {string|number}id
         * @returns {Scope|undefined}
         */
        $getById(id2) {
          if (isString(id2)) {
            id2 = parseInt(
              /** @type {string} */
              id2,
              10
            );
          }
          if (this.$id === id2) {
            return this;
          } else {
            let res = void 0;
            for (const child of this.$children) {
              let found = child.$getById(id2);
              if (found) {
                res = found;
                break;
              }
            }
            return res;
          }
        }
      }
      function calculateWatcherCount(model) {
        const childIds = collectChildIds(model).add(model.$id);
        return Array.from(model.watchers.values()).reduce(
          (count, watcherArray) => count + watcherArray.reduce(
            (subCount, watcher) => subCount + (childIds.has(watcher.scopeId) ? 1 : 0),
            0
          ),
          0
        );
      }
      function collectChildIds(child) {
        const ids = /* @__PURE__ */ new Set([child.$id]);
        child.$children?.forEach((c) => {
          collectChildIds(c).forEach((id2) => ids.add(id2));
        });
        return ids;
      }
      const $templateRequestMinErr = minErr("$templateRequest");
      function TemplateRequestProvider() {
        let httpOptions;
        this.httpOptions = function(val2) {
          if (val2) {
            httpOptions = val2;
            return this;
          }
          return httpOptions;
        };
        this.$get = [
          "$exceptionHandler",
          "$templateCache",
          "$http",
          "$sce",
          /**
           *
           * @param {import('./exception/exception-handler.js').ErrorHandler} $exceptionHandler
           * @param {import('../services/template-cache/interface.ts').TemplateCache} $templateCache
           * @param {import("interface.ts").HttpService} $http
           * @param {*} $sce
           * @returns
           */
          function($exceptionHandler2, $templateCache, $http, $sce) {
            function handleRequestFn(tpl, ignoreRequestError) {
              handleRequestFn.totalPendingRequests++;
              if (!isString(tpl) || !$templateCache.has(tpl)) {
                try {
                  tpl = $sce.getTrustedResourceUrl(tpl);
                  if (!tpl) {
                    return Promise.reject("Template not found");
                  }
                } catch (e) {
                  return Promise.reject(e.message);
                }
              }
              let transformResponse = $http.defaults && $http.defaults.transformResponse;
              if (Array.isArray(transformResponse)) {
                transformResponse = transformResponse.filter(function(transformer) {
                  return transformer !== defaultHttpResponseTransform;
                });
              } else if (transformResponse === defaultHttpResponseTransform) {
                transformResponse = null;
              }
              return $http.get(
                tpl,
                extend(
                  {
                    cache: $templateCache,
                    transformResponse
                  },
                  httpOptions
                )
              ).finally(function() {
                handleRequestFn.totalPendingRequests--;
              }).then(function(response) {
                $templateCache.set(tpl, response.data);
                return response.data;
              }, handleError);
              function handleError(resp) {
                if (!ignoreRequestError) {
                  resp = $templateRequestMinErr(
                    "tpload",
                    "Failed to load template: {0} (HTTP status: {1} {2})",
                    tpl,
                    resp.status,
                    resp.statusText
                  );
                  $exceptionHandler2(resp);
                }
                return Promise.reject(resp);
              }
            }
            handleRequestFn.totalPendingRequests = 0;
            return handleRequestFn;
          }
        ];
      }
      class SanitizeUriProvider {
        constructor() {
          this._aHrefSanitizationTrustedUrlList = /^\s*(https?|s?ftp|mailto|tel|file):/;
          this._imgSrcSanitizationTrustedUrlList = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        }
        /**
         * Retrieves or overrides the regexp used to trust URLs for a[href] sanitization.
         *
         * @param {RegExp=} regexp New regexp to trust URLs with.
         * @returns {RegExp|SanitizeUriProvider} Current regexp if no param, or self for chaining.
         */
        aHrefSanitizationTrustedUrlList(regexp) {
          if (isDefined(regexp)) {
            this._aHrefSanitizationTrustedUrlList = regexp;
            return this;
          }
          return this._aHrefSanitizationTrustedUrlList;
        }
        /**
         * Retrieves or overrides the regexp used to trust URLs for img[src] sanitization.
         *
         * @param {RegExp=} regexp New regexp to trust URLs with.
         * @returns {RegExp|SanitizeUriProvider} Current regexp if no param, or self for chaining.
         */
        imgSrcSanitizationTrustedUrlList(regexp) {
          if (isDefined(regexp)) {
            this._imgSrcSanitizationTrustedUrlList = regexp;
            return this;
          }
          return this._imgSrcSanitizationTrustedUrlList;
        }
        /**
         * @returns {import("./interface").SanitizerFn}
         */
        $get() {
          return (uri, isMediaUrl) => {
            if (!uri) return uri;
            const regex = isMediaUrl ? this._imgSrcSanitizationTrustedUrlList : this._aHrefSanitizationTrustedUrlList;
            const normalizedVal = urlResolve(uri.trim()).href;
            if (normalizedVal !== "" && !normalizedVal.match(regex)) {
              return `unsafe:${normalizedVal}`;
            }
            return uri;
          };
        }
      }
      const ACTIVE_CLASS = "ng-active";
      const INACTIVE_CLASS = "ng-inactive";
      class NgMessageCtrl {
        /**
         * @param {Element} $element
         * @param {import('../../core/scope/scope.js').Scope} $scope
         * @param {import('../../core/compile/attributes').Attributes} $attrs
         * @param {*} $animate
         */
        constructor($element, $scope, $attrs, $animate) {
          this.$element = $element;
          this.$scope = $scope;
          this.$attrs = $attrs;
          this.$animate = $animate;
          this.latestKey = 0;
          this.nextAttachId = 0;
          this.messages = {};
          this.renderLater = false;
          this.cachedCollection = null;
          this.head = void 0;
          this.default = void 0;
          this.$scope.$watch(
            this.$attrs["ngMessages"] || this.$attrs["for"],
            this.render.bind(this)
          );
        }
        getAttachId() {
          return this.nextAttachId++;
        }
        render(collection = {}) {
          this.renderLater = false;
          this.cachedCollection = collection;
          const multiple = isAttrTruthy(this.$scope, this.$attrs["ngMessagesMultiple"]) || isAttrTruthy(this.$scope, this.$attrs["multiple"]);
          const unmatchedMessages = [];
          const matchedKeys = {};
          let truthyKeys = 0;
          let messageItem = this.head;
          let messageFound = false;
          let totalMessages = 0;
          while (messageItem) {
            totalMessages++;
            const messageCtrl = messageItem.message;
            let messageUsed = false;
            if (!messageFound) {
              Object.entries(collection).forEach(([key, value]) => {
                if (truthy(value) && !messageUsed) {
                  truthyKeys++;
                  if (messageCtrl.test(key)) {
                    if (matchedKeys[key]) return;
                    matchedKeys[key] = true;
                    messageUsed = true;
                    messageCtrl.attach();
                  }
                }
              });
            }
            if (messageUsed) {
              messageFound = !multiple;
            } else {
              unmatchedMessages.push(messageCtrl);
            }
            messageItem = messageItem.next;
          }
          unmatchedMessages.forEach((messageCtrl) => {
            messageCtrl.detach();
          });
          const messageMatched = unmatchedMessages.length !== totalMessages;
          const attachDefault = this.default && !messageMatched && truthyKeys > 0;
          if (attachDefault) {
            this.default.attach();
          } else if (this.default) {
            this.default.detach();
          }
          if (messageMatched || attachDefault) {
            this.$animate.setClass(this.$element, ACTIVE_CLASS, INACTIVE_CLASS);
          } else {
            this.$animate.setClass(this.$element, INACTIVE_CLASS, ACTIVE_CLASS);
          }
        }
        reRender() {
          if (!this.renderLater) {
            this.renderLater = true;
            Promise.resolve().then(() => {
              if (this.renderLater && this.cachedCollection) {
                this.render(this.cachedCollection);
              }
            });
          }
        }
        register(comment, messageCtrl, isDefault) {
          if (isDefault) {
            this.default = messageCtrl;
          } else {
            const nextKey = this.latestKey.toString();
            this.messages[nextKey] = {
              message: messageCtrl
            };
            this.insertMessageNode(this.$element, comment, nextKey);
            comment.$$ngMessageNode = nextKey;
            this.latestKey++;
          }
          this.reRender();
        }
        deregister(comment, isDefault) {
          if (isDefault) {
            delete this.default;
          } else {
            const key = comment.$$ngMessageNode;
            delete comment.$$ngMessageNode;
            this.removeMessageNode(this.$element, comment, key);
            delete this.messages[key];
          }
          this.reRender();
        }
        findPreviousMessage(parent, comment) {
          let prevNode = comment;
          const parentLookup = [];
          while (prevNode && prevNode !== parent) {
            const prevKey = prevNode.$$ngMessageNode;
            if (prevKey && prevKey.length) {
              return this.messages[prevKey];
            }
            if (prevNode.childNodes.length && parentLookup.indexOf(prevNode) === -1) {
              parentLookup.push(prevNode);
              prevNode = prevNode.childNodes[prevNode.childNodes.length - 1];
            } else if (prevNode.previousSibling) {
              prevNode = prevNode.previousSibling;
            } else {
              prevNode = prevNode.parentNode;
              parentLookup.push(prevNode);
            }
          }
        }
        insertMessageNode(parent, comment, key) {
          const messageNode = this.messages[key];
          if (!this.head) {
            this.head = messageNode;
          } else {
            const match = this.findPreviousMessage(parent, comment);
            if (match) {
              messageNode.next = match.next;
              match.next = messageNode;
            } else {
              messageNode.next = this.head;
              this.head = messageNode;
            }
          }
        }
        removeMessageNode(parent, comment, key) {
          const messageNode = this.messages[key];
          if (!messageNode) return;
          const match = this.findPreviousMessage(parent, comment);
          if (match) {
            match.next = messageNode.next;
          } else {
            this.head = messageNode.next;
          }
        }
      }
      ngMessagesDirective.$inject = ["$animate"];
      function ngMessagesDirective($animate) {
        return {
          require: "ngMessages",
          restrict: "AE",
          controller: ($element, $scope, $attrs) => new NgMessageCtrl($element, $scope, $attrs, $animate)
        };
      }
      function isAttrTruthy(scope, attr) {
        return isString(attr) && attr.length === 0 || // empty attribute
        truthy(scope.$eval(attr));
      }
      function truthy(val2) {
        return isString(val2) ? val2.length : !!val2;
      }
      ngMessagesIncludeDirective.$inject = ["$templateRequest", "$compile"];
      function ngMessagesIncludeDirective($templateRequest, $compile) {
        return {
          restrict: "AE",
          require: "^^ngMessages",
          // we only require this for validation sake
          link($scope, element, attrs) {
            const src = attrs.ngMessagesInclude || attrs.src;
            $templateRequest(src).then((html) => {
              if ($scope.$$destroyed) return;
              if (isString(html) && !html.trim()) ;
              else {
                $compile(html)($scope, (contents) => {
                  element.after(contents);
                });
              }
            });
          }
        };
      }
      const ngMessageDirective = ngMessageDirectiveFactory(false);
      const ngMessageExpDirective = ngMessageDirectiveFactory(false);
      const ngMessageDefaultDirective = ngMessageDirectiveFactory(true);
      function ngMessageDirectiveFactory(isDefault) {
        ngMessageDirective2.$inject = ["$animate"];
        function ngMessageDirective2($animate) {
          return {
            restrict: "AE",
            transclude: "element",
            priority: 1,
            // must run before ngBind, otherwise the text is set on the comment
            terminal: true,
            require: "^^ngMessages",
            link(scope, element, attrs, ngMessagesCtrl, $transclude) {
              let commentNode;
              let records;
              let staticExp;
              let dynamicExp;
              if (!isDefault) {
                commentNode = element;
                staticExp = attrs.ngMessage || attrs.when;
                dynamicExp = attrs.ngMessageExp || attrs.whenExp;
                const assignRecords = function(items) {
                  records = items ? Array.isArray(items) ? items : items.split(/[\s,]+/) : null;
                  ngMessagesCtrl.reRender();
                };
                if (dynamicExp) {
                  assignRecords(scope.$eval(dynamicExp));
                  scope.$watch(dynamicExp, assignRecords);
                } else {
                  assignRecords(staticExp);
                }
              }
              let currentElement;
              let messageCtrl;
              ngMessagesCtrl.register(
                commentNode,
                messageCtrl = {
                  test(name2) {
                    return contains(records, name2);
                  },
                  attach() {
                    if (!currentElement) {
                      $transclude((elm, newScope) => {
                        $animate.enter(elm, null, element);
                        currentElement = elm;
                        const $$attachId = currentElement.$$attachId = ngMessagesCtrl.getAttachId();
                        currentElement.addEventListener("$destroy", () => {
                          if (currentElement && currentElement.$$attachId === $$attachId) {
                            ngMessagesCtrl.deregister(commentNode, isDefault);
                            messageCtrl.detach();
                          }
                          newScope.$destroy();
                        });
                      });
                    }
                  },
                  detach() {
                    if (currentElement) {
                      const elm = currentElement;
                      currentElement = null;
                      $animate.leave(elm);
                    }
                  }
                },
                isDefault
              );
              scope.$on("$destroy", () => {
                ngMessagesCtrl.deregister(commentNode, isDefault);
              });
            }
          };
        }
        return ngMessageDirective2;
      }
      function contains(collection, key) {
        if (collection) {
          return Array.isArray(collection) ? collection.indexOf(key) >= 0 : hasOwn(collection, key);
        }
      }
      const ARIA_DISABLE_ATTR = "ngAriaDisable";
      const nativeAriaNodeNames = [
        "BUTTON",
        "A",
        "INPUT",
        "TEXTAREA",
        "SELECT",
        "DETAILS",
        "SUMMARY"
      ];
      const isNodeOneOf = function(elem, nodeTypeArray) {
        if (nodeTypeArray.indexOf(elem.nodeName) !== -1) {
          return true;
        }
      };
      function AriaProvider() {
        let config = {
          ariaHidden: true,
          ariaChecked: true,
          ariaReadonly: true,
          ariaDisabled: true,
          ariaRequired: true,
          ariaInvalid: true,
          ariaValue: true,
          tabindex: true,
          bindKeydown: true,
          bindRoleForClick: true
        };
        this.config = function(newConfig) {
          config = extend(config, newConfig);
        };
        function watchExpr(attrName, ariaAttr, nativeAriaNodeNames2, negate) {
          return function(scope, elem, attr) {
            if (hasOwn(attr, ARIA_DISABLE_ATTR)) return;
            const ariaCamelName = attr.$normalize(ariaAttr);
            if (config[ariaCamelName] && !isNodeOneOf(elem, nativeAriaNodeNames2) && !attr[ariaCamelName]) {
              scope.$watch(attr[attrName], (boolVal) => {
                boolVal = negate ? !boolVal : !!boolVal;
                elem.setAttribute(ariaAttr, boolVal);
              });
            }
          };
        }
        this.$get = function() {
          return {
            config(key) {
              return config[key];
            },
            $$watchExpr: watchExpr
          };
        };
      }
      ngDisabledAriaDirective.$inject = [$injectTokens.$aria];
      function ngDisabledAriaDirective($aria) {
        return $aria.$$watchExpr(
          "ngDisabled",
          "aria-disabled",
          nativeAriaNodeNames,
          false
        );
      }
      ngShowAriaDirective.$inject = [$injectTokens.$aria];
      function ngShowAriaDirective($aria) {
        return $aria.$$watchExpr("ngShow", "aria-hidden", [], true);
      }
      function ngMessagesAriaDirective() {
        return {
          restrict: "A",
          require: "?ngMessages",
          link(_scope, elem, attr) {
            if (hasOwn(attr, ARIA_DISABLE_ATTR)) return;
            if (!elem.hasAttribute("aria-live")) {
              elem.setAttribute("aria-live", "assertive");
            }
          }
        };
      }
      ngClickAriaDirective.$inject = [$injectTokens.$aria, $injectTokens.$parse];
      function ngClickAriaDirective($aria, $parse2) {
        return {
          restrict: "A",
          compile(_elem, attr) {
            if (hasOwn(attr, ARIA_DISABLE_ATTR)) return;
            const fn = $parse2(attr.ngClick);
            return function(scope, elem, attr2) {
              if (!isNodeOneOf(elem, nativeAriaNodeNames)) {
                if ($aria.config("bindRoleForClick") && !elem.hasAttribute("role")) {
                  elem.setAttribute("role", "button");
                }
                if ($aria.config("tabindex") && !elem.hasAttribute("tabindex")) {
                  elem.setAttribute("tabindex", "0");
                }
                if ($aria.config("bindKeydown") && !attr2.ngKeydown && !attr2.ngKeypress && !attr2.ngKeyup) {
                  elem.addEventListener(
                    "keydown",
                    /** @param {KeyboardEvent} event */
                    (event) => {
                      const keyCode = parseInt(event.key, 10);
                      if (keyCode === 13 || keyCode === 32) {
                        if (nativeAriaNodeNames.indexOf(
                          /** @type {Node} */
                          event.target.nodeName
                        ) === -1 && !/** @type {HTMLElement} */
                        event.target.isContentEditable) {
                          event.preventDefault();
                        }
                        scope.$apply(callback);
                      }
                      function callback() {
                        fn(scope, { $event: event });
                      }
                    }
                  );
                }
              }
            };
          }
        };
      }
      ngRequiredAriaDirective.$inject = [$injectTokens.$aria];
      function ngRequiredAriaDirective($aria) {
        return $aria.$$watchExpr(
          "ngRequired",
          "aria-required",
          nativeAriaNodeNames,
          false
        );
      }
      ngCheckedAriaDirective.$inject = ["$aria"];
      function ngCheckedAriaDirective($aria) {
        return $aria.$$watchExpr(
          "ngChecked",
          "aria-checked",
          nativeAriaNodeNames,
          false
        );
      }
      ngValueAriaDirective.$inject = [$injectTokens.$aria];
      function ngValueAriaDirective($aria) {
        return $aria.$$watchExpr(
          "ngValue",
          "aria-checked",
          nativeAriaNodeNames,
          false
        );
      }
      ngHideAriaDirective.$inject = [$injectTokens.$aria];
      function ngHideAriaDirective($aria) {
        return $aria.$$watchExpr("ngHide", "aria-hidden", [], false);
      }
      ngReadonlyAriaDirective.$inject = [$injectTokens.$aria];
      function ngReadonlyAriaDirective($aria) {
        return $aria.$$watchExpr(
          "ngReadonly",
          "aria-readonly",
          nativeAriaNodeNames,
          false
        );
      }
      ngModelAriaDirective.$inject = [$injectTokens.$aria];
      function ngModelAriaDirective($aria) {
        function shouldAttachAttr(attr, normalizedAttr, elem, allowNonAriaNodes) {
          return $aria.config(normalizedAttr) && !elem.getAttribute(attr) && (allowNonAriaNodes || !isNodeOneOf(elem, nativeAriaNodeNames)) && (elem.getAttribute("type") !== "hidden" || elem.nodeName !== "INPUT");
        }
        function shouldAttachRole(role, elem) {
          return !elem.getAttribute("role") && elem.getAttribute("type") === role && !isNodeOneOf(elem, nativeAriaNodeNames);
        }
        function getShape(attr) {
          const { type } = attr;
          const { role } = attr;
          return (type || role) === "checkbox" || role === "menuitemcheckbox" ? "checkbox" : (type || role) === "radio" || role === "menuitemradio" ? "radio" : type === "range" || role === "progressbar" || role === "slider" ? "range" : "";
        }
        return {
          restrict: "A",
          require: "ngModel",
          priority: 200,
          // Make sure watches are fired after any other directives that affect the ngModel value
          compile(elem, attr) {
            if (hasOwn(attr, ARIA_DISABLE_ATTR)) return;
            const shape = getShape(attr);
            return {
              post(scope, elem2, attr2, ngModel) {
                const needsTabIndex = shouldAttachAttr(
                  "tabindex",
                  "tabindex",
                  elem2,
                  false
                );
                function getRadioReaction() {
                  elem2.setAttribute(
                    "aria-checked",
                    (attr2.value == ngModel.$viewValue).toString()
                  );
                }
                function getCheckboxReaction() {
                  elem2.setAttribute(
                    "aria-checked",
                    (!ngModel.$isEmpty(ngModel.$viewValue)).toString()
                  );
                }
                switch (shape) {
                  case "radio":
                  case "checkbox":
                    if (shouldAttachRole(shape, elem2)) {
                      elem2.setAttribute("role", shape);
                    }
                    if (shouldAttachAttr("aria-checked", "ariaChecked", elem2, false)) {
                      ngModel.$watch(
                        "$modelValue",
                        shape === "radio" ? getRadioReaction : getCheckboxReaction
                      );
                    }
                    if (needsTabIndex) {
                      elem2.setAttribute("tabindex", 0);
                    }
                    break;
                  case "range":
                    if (shouldAttachRole(shape, elem2)) {
                      elem2.setAttribute("role", "slider");
                    }
                    if ($aria.config("ariaValue")) {
                      const needsAriaValuemin = !elem2.hasAttribute("aria-valuemin") && (hasOwn(attr2, "min") || hasOwn(attr2, "ngMin"));
                      const needsAriaValuemax = !elem2.hasAttribute("aria-valuemax") && (hasOwn(attr2, "max") || hasOwn(attr2, "ngMax"));
                      const needsAriaValuenow = !elem2.hasAttribute("aria-valuenow");
                      if (needsAriaValuemin) {
                        attr2.$observe("min", (newVal) => {
                          elem2.setAttribute("aria-valuemin", newVal);
                        });
                      }
                      if (needsAriaValuemax) {
                        attr2.$observe("max", (newVal) => {
                          elem2.setAttribute("aria-valuemax", newVal);
                        });
                      }
                      if (needsAriaValuenow) {
                        ngModel.$watch("$modelValue", (newVal) => {
                          elem2.setAttribute("aria-valuenow", newVal);
                        });
                      }
                    }
                    if (needsTabIndex) {
                      elem2.setAttribute("tabindex", 0);
                    }
                    break;
                }
                if (!hasOwn(attr2, "ngRequired") && ngModel.$validators.required && shouldAttachAttr("aria-required", "ariaRequired", elem2, false)) {
                  attr2.$observe("required", () => {
                    elem2.setAttribute("aria-required", (!!attr2.required).toString());
                  });
                }
                if (shouldAttachAttr("aria-invalid", "ariaInvalid", elem2, true)) {
                  ngModel.$watch("$invalid", (newVal) => {
                    elem2.setAttribute("aria-invalid", (!!newVal).toString());
                  });
                }
              }
            };
          }
        };
      }
      ngDblclickAriaDirective.$inject = [$injectTokens.$aria];
      function ngDblclickAriaDirective($aria) {
        return function(scope, elem, attr) {
          if (hasOwn(attr, ARIA_DISABLE_ATTR)) return;
          if ($aria.config("tabindex") && !elem.hasAttribute("tabindex") && !isNodeOneOf(elem, nativeAriaNodeNames)) {
            elem.setAttribute("tabindex", 0);
          }
        };
      }
      const ANIMATE_TIMER_KEY = "$$animateCss";
      const ONE_SECOND = 1e3;
      const ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
      const CLOSING_TIME_BUFFER = 1.5;
      const DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
      };
      const DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
      };
      function getCssKeyframeDurationStyle(duration) {
        return [ANIMATION_DURATION_PROP, `${duration}s`];
      }
      function getCssDelayStyle(delay, isKeyframeAnimation) {
        const prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [prop, `${delay}s`];
      }
      function computeCssStyles(element, properties) {
        const styles = /* @__PURE__ */ Object.create(null);
        const detectedStyles = window.getComputedStyle(element) || {};
        Object.entries(properties).forEach(([actualStyleName, formalStyleName]) => {
          let val2 = detectedStyles[formalStyleName];
          if (val2) {
            const c = val2.charAt(0);
            if (c === "-" || c === "+" || c >= 0) {
              val2 = parseMaxTime(val2);
            }
            if (val2 === 0) {
              val2 = null;
            }
            styles[actualStyleName] = val2;
          }
        });
        return styles;
      }
      function parseMaxTime(str) {
        let maxValue = 0;
        str.split(/\s*,\s*/).forEach((value) => {
          if (value.charAt(value.length - 1) === "s") {
            value = value.substring(0, value.length - 1);
          }
          value = parseFloat(value) || 0;
          maxValue = maxValue ? Math.max(value, maxValue) : value;
        });
        return maxValue;
      }
      function truthyTimingValue(val2) {
        return val2 === 0 || val2 != null;
      }
      function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        let style = TRANSITION_PROP;
        let value = `${duration}s`;
        if (applyOnlyDuration) {
          style += DURATION_KEY;
        } else {
          value += " linear all";
        }
        return [style, value];
      }
      function registerRestorableStyles(backup, node, properties) {
        properties.forEach((prop) => {
          backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
        });
      }
      function AnimateCssProvider() {
        this.$get = [
          "$$AnimateRunner",
          "$$animateCache",
          "$$rAFScheduler",
          /**
           *
           * @param {*} $$AnimateRunner
           * @param {*} $$animateCache
           * @param {import("./raf-scheduler").RafScheduler} $$rAFScheduler
           * @returns
           */
          function($$AnimateRunner, $$animateCache, $$rAFScheduler) {
            const applyAnimationClasses = applyAnimationClassesFactory();
            function computeCachedCssStyles(node, cacheKey, allowNoDuration, properties) {
              let timings = $$animateCache.get(cacheKey);
              if (!timings) {
                timings = computeCssStyles(node, properties);
                if (timings.animationIterationCount === "infinite") {
                  timings.animationIterationCount = 1;
                }
              }
              const hasDuration = allowNoDuration || timings.transitionDuration > 0 || timings.animationDuration > 0;
              $$animateCache.put(cacheKey, timings, hasDuration);
              return timings;
            }
            function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
              let stagger;
              const staggerCacheKey = `stagger-${cacheKey}`;
              if ($$animateCache.count(cacheKey) > 0) {
                stagger = $$animateCache.get(staggerCacheKey);
                if (!stagger) {
                  const staggerClassName = pendClasses(className, "-stagger");
                  node.className += ` ${staggerClassName}`;
                  stagger = computeCssStyles(node, properties);
                  stagger.animationDuration = Math.max(stagger.animationDuration, 0);
                  stagger.transitionDuration = Math.max(
                    stagger.transitionDuration,
                    0
                  );
                  node.classList.remove(staggerClassName);
                  $$animateCache.put(staggerCacheKey, stagger, true);
                }
              }
              return stagger || {};
            }
            const rafWaitQueue = [];
            function waitUntilQuiet(callback) {
              rafWaitQueue.push(callback);
              $$rAFScheduler.waitUntilQuiet(() => {
                $$animateCache.flush();
                const pageWidth = document.body.offsetWidth + 1;
                for (let i = 0; i < rafWaitQueue.length; i++) {
                  rafWaitQueue[i](pageWidth);
                }
                rafWaitQueue.length = 0;
              });
            }
            function computeTimings(node, cacheKey, allowNoDuration) {
              const timings = computeCachedCssStyles(
                node,
                cacheKey,
                allowNoDuration,
                DETECT_CSS_PROPERTIES
              );
              const aD = timings.animationDelay;
              const tD = timings.transitionDelay;
              timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD;
              timings.maxDuration = Math.max(
                timings.animationDuration * timings.animationIterationCount,
                timings.transitionDuration
              );
              return timings;
            }
            return function init(element, initialOptions) {
              let delayStyle;
              let options = initialOptions || {};
              if (!options.$$prepared) {
                options = prepareAnimationOptions(structuredClone(options));
              }
              const restoreStyles = {};
              const node = (
                /** @type {HTMLElement} */
                element
              );
              if (!node || !node.parentNode) {
                return closeAndReturnNoopAnimator();
              }
              const temporaryStyles = [];
              const styles = packageStyles(options);
              let animationClosed;
              let animationPaused;
              let animationCompleted;
              let runner;
              let runnerHost;
              let maxDelay;
              let maxDelayTime;
              let maxDuration;
              let maxDurationTime;
              let startTime;
              const events = [];
              if (options.duration === 0) {
                return closeAndReturnNoopAnimator();
              }
              const method = options.event && Array.isArray(options.event) ? options.event.join(" ") : options.event;
              const isStructural = method && options.structural;
              let structuralClassName = "";
              let addRemoveClassName = "";
              if (isStructural) {
                structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
              } else if (method) {
                structuralClassName = method;
              }
              if (options.addClass) {
                addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
              }
              if (options.removeClass) {
                if (addRemoveClassName.length) {
                  addRemoveClassName += " ";
                }
                addRemoveClassName += pendClasses(
                  options.removeClass,
                  REMOVE_CLASS_SUFFIX
                );
              }
              if (options.applyClassesEarly && addRemoveClassName.length) {
                applyAnimationClasses(element, options);
              }
              let preparationClasses = [structuralClassName, addRemoveClassName].join(" ").trim();
              const hasToStyles = styles.to && Object.keys(styles.to).length > 0;
              const containsKeyframeAnimation = (options.keyframeStyle || "").length > 0;
              if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
                return closeAndReturnNoopAnimator();
              }
              let stagger;
              let cacheKey = $$animateCache.cacheKey(
                node,
                method,
                options.addClass,
                options.removeClass
              );
              if ($$animateCache.containsCachedAnimationWithoutDuration(cacheKey)) {
                preparationClasses = null;
                return closeAndReturnNoopAnimator();
              }
              if (options.stagger > 0) {
                const staggerVal = parseFloat(options.stagger);
                stagger = {
                  transitionDelay: staggerVal,
                  animationDelay: staggerVal,
                  transitionDuration: 0,
                  animationDuration: 0
                };
              } else {
                stagger = computeCachedCssStaggerStyles(
                  node,
                  preparationClasses,
                  cacheKey,
                  DETECT_STAGGER_CSS_PROPERTIES
                );
              }
              if (!options.$$skipPreparationClasses) {
                element.classList.add(
                  ...preparationClasses.split(" ").filter((x) => x !== "")
                );
              }
              let applyOnlyDuration;
              if (options.transitionStyle) {
                const transitionStyle = [TRANSITION_PROP, options.transitionStyle];
                applyInlineStyle(node, transitionStyle);
                temporaryStyles.push(transitionStyle);
              }
              if (options.duration >= 0) {
                applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
                const durationStyle = getCssTransitionDurationStyle(
                  options.duration,
                  applyOnlyDuration
                );
                applyInlineStyle(node, durationStyle);
                temporaryStyles.push(durationStyle);
              }
              if (options.keyframeStyle) {
                const keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
                applyInlineStyle(node, keyframeStyle);
                temporaryStyles.push(keyframeStyle);
              }
              const itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : $$animateCache.count(cacheKey) : 0;
              const isFirst = itemIndex === 0;
              if (isFirst && !options.skipBlocking) {
                blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
              }
              let timings = computeTimings(node, cacheKey, !isStructural);
              let relativeDelay = timings.maxDelay;
              maxDelay = Math.max(relativeDelay, 0);
              maxDuration = timings.maxDuration;
              const flags = {};
              flags.hasTransitions = timings.transitionDuration > 0;
              flags.hasAnimations = timings.animationDuration > 0;
              flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty === "all";
              flags.applyTransitionDuration = hasToStyles && (flags.hasTransitions && !flags.hasTransitionAll || flags.hasAnimations && !flags.hasTransitions);
              flags.applyAnimationDuration = options.duration && flags.hasAnimations;
              flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
              flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
              flags.recalculateTimingStyles = addRemoveClassName.length > 0;
              if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
                maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
                if (flags.applyTransitionDuration) {
                  flags.hasTransitions = true;
                  timings.transitionDuration = maxDuration;
                  applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                  temporaryStyles.push(
                    getCssTransitionDurationStyle(maxDuration, applyOnlyDuration)
                  );
                }
                if (flags.applyAnimationDuration) {
                  flags.hasAnimations = true;
                  timings.animationDuration = maxDuration;
                  temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
                }
              }
              if (maxDuration === 0 && !flags.recalculateTimingStyles) {
                return closeAndReturnNoopAnimator();
              }
              let activeClasses = pendClasses(
                preparationClasses,
                ACTIVE_CLASS_SUFFIX
              );
              if (options.delay != null) {
                if (typeof options.delay !== "boolean") {
                  delayStyle = parseFloat(options.delay);
                  maxDelay = Math.max(delayStyle, 0);
                }
                if (flags.applyTransitionDelay) {
                  temporaryStyles.push(getCssDelayStyle(delayStyle));
                }
                if (flags.applyAnimationDelay) {
                  temporaryStyles.push(getCssDelayStyle(delayStyle, true));
                }
              }
              if (options.duration == null && timings.transitionDuration > 0) {
                flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
              }
              maxDelayTime = maxDelay * ONE_SECOND;
              maxDurationTime = maxDuration * ONE_SECOND;
              if (!options.skipBlocking) {
                flags.blockTransition = timings.transitionDuration > 0;
                flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
              }
              if (options.from) {
                if (options.cleanupStyles) {
                  registerRestorableStyles(
                    restoreStyles,
                    node,
                    Object.keys(options.from)
                  );
                }
                applyAnimationFromStyles(element, options);
              }
              if (flags.blockTransition || flags.blockKeyframeAnimation) {
                applyBlocking(maxDuration);
              } else if (!options.skipBlocking) {
                blockTransitions(node, false);
              }
              return {
                $$willAnimate: true,
                end: endFn,
                start() {
                  if (animationClosed) return;
                  runnerHost = {
                    end: endFn,
                    cancel: cancelFn,
                    resume: null,
                    // this will be set during the start() phase
                    pause: null
                  };
                  runner = new $$AnimateRunner(runnerHost);
                  waitUntilQuiet(start);
                  return runner;
                }
              };
              function endFn() {
                close();
              }
              function cancelFn() {
                close(true);
              }
              function close(rejected) {
                if (animationClosed || animationCompleted && animationPaused)
                  return;
                animationClosed = true;
                animationPaused = false;
                if (preparationClasses && !options.$$skipPreparationClasses) {
                  element.classList.remove(...preparationClasses.split(" "));
                }
                activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
                if (activeClasses) {
                  element.classList.remove(...activeClasses.split(" "));
                }
                blockKeyframeAnimations(node, false);
                blockTransitions(node, false);
                temporaryStyles.forEach((entry) => {
                  node.style[entry[0]] = "";
                });
                applyAnimationClasses(element, options);
                applyAnimationStyles(element, options);
                if (Object.keys(restoreStyles).length) {
                  Object.entries(restoreStyles).forEach(([prop, value]) => {
                    if (value) {
                      node.style.setProperty(prop, value);
                    } else {
                      node.style.removeProperty(prop);
                    }
                  });
                }
                if (options.onDone) {
                  options.onDone();
                }
                if (events && events.length) {
                  element.off(events.join(" "), onAnimationProgress);
                }
                const animationTimerData = getCacheData(element, ANIMATE_TIMER_KEY);
                if (animationTimerData) {
                  clearTimeout(animationTimerData[0].timer);
                  removeElementData(element, ANIMATE_TIMER_KEY);
                }
                if (runner) {
                  runner.complete(!rejected);
                }
              }
              function applyBlocking(duration) {
                if (flags.blockTransition) {
                  blockTransitions(node, duration);
                }
                if (flags.blockKeyframeAnimation) {
                  blockKeyframeAnimations(node, !!duration);
                }
              }
              function closeAndReturnNoopAnimator() {
                runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: cancelFn
                });
                waitUntilQuiet(() => {
                });
                close();
                return {
                  $$willAnimate: false,
                  start() {
                    return runner;
                  },
                  end: endFn
                };
              }
              function onAnimationProgress(event) {
                event.stopPropagation();
                const ev = event.originalEvent || event;
                if (ev.target !== node) {
                  return;
                }
                const timeStamp = ev.$manualTimeStamp || Date.now();
                const elapsedTime = parseFloat(
                  ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES)
                );
                if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                  animationCompleted = true;
                  close();
                }
              }
              function start() {
                if (animationClosed) return;
                if (!node.parentNode) {
                  close();
                  return;
                }
                const playPause = function(playAnimation) {
                  if (!animationCompleted) {
                    animationPaused = !playAnimation;
                    if (timings.animationDuration) {
                      const value = blockKeyframeAnimations(node, animationPaused);
                      if (animationPaused) {
                        temporaryStyles.push(value);
                      } else {
                        removeFromArray(temporaryStyles, value);
                      }
                    }
                  } else if (animationPaused && playAnimation) {
                    animationPaused = false;
                    close();
                  }
                };
                const maxStagger = itemIndex > 0 && (timings.transitionDuration && stagger.transitionDuration === 0 || timings.animationDuration && stagger.animationDuration === 0) && Math.max(stagger.animationDelay, stagger.transitionDelay);
                if (maxStagger) {
                  setTimeout(
                    triggerAnimationStart,
                    Math.floor(maxStagger * itemIndex * ONE_SECOND),
                    false
                  );
                } else {
                  triggerAnimationStart();
                }
                runnerHost.resume = function() {
                  playPause(true);
                };
                runnerHost.pause = function() {
                  playPause(false);
                };
                function triggerAnimationStart() {
                  if (animationClosed) return;
                  applyBlocking(false);
                  temporaryStyles.forEach((entry) => {
                    const key = entry[0];
                    node.style[key] = entry[1];
                  });
                  applyAnimationClasses(element, options);
                  element.classList.add(
                    ...activeClasses.split(" ").filter((x) => x !== "")
                  );
                  if (flags.recalculateTimingStyles) {
                    cacheKey = $$animateCache.cacheKey(
                      node,
                      method,
                      options.addClass,
                      options.removeClass
                    );
                    timings = computeTimings(node, cacheKey, false);
                    relativeDelay = timings.maxDelay;
                    maxDelay = Math.max(relativeDelay, 0);
                    maxDuration = timings.maxDuration;
                    if (maxDuration === 0) {
                      close();
                      return;
                    }
                    flags.hasTransitions = timings.transitionDuration > 0;
                    flags.hasAnimations = timings.animationDuration > 0;
                  }
                  if (flags.applyAnimationDelay) {
                    relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                    maxDelay = Math.max(relativeDelay, 0);
                    timings.animationDelay = relativeDelay;
                    delayStyle = getCssDelayStyle(relativeDelay, true);
                    temporaryStyles.push(delayStyle);
                    node.style[delayStyle[0]] = delayStyle[1];
                  }
                  maxDelayTime = maxDelay * ONE_SECOND;
                  maxDurationTime = maxDuration * ONE_SECOND;
                  if (options.easing) {
                    let easeProp;
                    const easeVal = options.easing;
                    if (flags.hasTransitions) {
                      easeProp = TRANSITION_PROP + TIMING_KEY;
                      temporaryStyles.push([easeProp, easeVal]);
                      node.style[easeProp] = easeVal;
                    }
                    if (flags.hasAnimations) {
                      easeProp = ANIMATION_PROP + TIMING_KEY;
                      temporaryStyles.push([easeProp, easeVal]);
                      node.style[easeProp] = easeVal;
                    }
                  }
                  if (timings.transitionDuration) {
                    events.push(TRANSITIONEND_EVENT);
                  }
                  if (timings.animationDuration) {
                    events.push(ANIMATIONEND_EVENT);
                  }
                  startTime = Date.now();
                  const timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
                  const endTime = startTime + timerTime;
                  const animationsData = getCacheData(element, ANIMATE_TIMER_KEY) || [];
                  let setupFallbackTimer = true;
                  if (animationsData.length) {
                    const currentTimerData = animationsData[0];
                    setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
                    if (setupFallbackTimer) {
                      clearTimeout(currentTimerData.timer);
                    } else {
                      animationsData.push(close);
                    }
                  }
                  if (setupFallbackTimer) {
                    const timer = setTimeout(onAnimationExpired, timerTime, false);
                    animationsData[0] = {
                      timer,
                      expectedEndTime: endTime
                    };
                    animationsData.push(close);
                    setCacheData(element, ANIMATE_TIMER_KEY, animationsData);
                  }
                  if (events.length) {
                    events.forEach((x) => {
                      element.addEventListener(x, onAnimationProgress);
                    });
                  }
                  if (options.to) {
                    if (options.cleanupStyles) {
                      registerRestorableStyles(
                        restoreStyles,
                        node,
                        Object.keys(options.to)
                      );
                    }
                    applyAnimationToStyles(element, options);
                  }
                }
                function onAnimationExpired() {
                  const animationsData = getCacheData(element, ANIMATE_TIMER_KEY);
                  if (animationsData) {
                    for (let i = 1; i < animationsData.length; i++) {
                      animationsData[i]();
                    }
                    removeElementData(element, ANIMATE_TIMER_KEY);
                  }
                }
              }
            };
          }
        ];
      }
      function blockTransitions(node, duration) {
        const value = duration ? `-${duration}s` : "";
        applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
        return [TRANSITION_DELAY_PROP, value];
      }
      const NG_ANIMATE_ATTR_NAME = "data-ng-animate";
      const NG_ANIMATE_PIN_DATA = "$ngAnimatePin";
      AnimateQueueProvider.$inject = ["$animateProvider"];
      function AnimateQueueProvider($animateProvider) {
        const PRE_DIGEST_STATE = 1;
        const RUNNING_STATE = 2;
        const ONE_SPACE = " ";
        const rules = this.rules = {
          skip: [],
          cancel: [],
          join: []
        };
        function getEventData(options) {
          return {
            addClass: options.addClass,
            removeClass: options.removeClass,
            from: options.from,
            to: options.to
          };
        }
        function makeTruthyCssClassMap(classString) {
          if (!classString) {
            return null;
          }
          const keys = classString.split(ONE_SPACE);
          const map2 = /* @__PURE__ */ Object.create(null);
          keys.forEach((key) => {
            map2[key] = true;
          });
          return map2;
        }
        function hasMatchingClasses(newClassString, currentClassString) {
          if (newClassString && currentClassString) {
            const currentClassMap = makeTruthyCssClassMap(currentClassString);
            return newClassString.split(ONE_SPACE).some((className) => currentClassMap[className]);
          }
        }
        function isAllowed(ruleType, currentAnimation, previousAnimation) {
          return rules[ruleType].some(
            (fn) => fn(currentAnimation, previousAnimation)
          );
        }
        function hasAnimationClasses(animation, and) {
          const a = (animation.addClass || "").length > 0;
          const b = (animation.removeClass || "").length > 0;
          return and ? a && b : a || b;
        }
        rules.join.push(
          (newAnimation) => (
            // if the new animation is class-based then we can just tack that on
            !newAnimation.structural && hasAnimationClasses(newAnimation)
          )
        );
        rules.skip.push(
          (newAnimation) => (
            // there is no need to animate anything if no classes are being added and
            // there is no structural animation that will be triggered
            !newAnimation.structural && !hasAnimationClasses(newAnimation)
          )
        );
        rules.skip.push(
          (newAnimation, currentAnimation) => (
            // why should we trigger a new structural animation if the element will
            // be removed from the DOM anyway?
            currentAnimation.event === "leave" && newAnimation.structural
          )
        );
        rules.skip.push(
          (newAnimation, currentAnimation) => (
            // if there is an ongoing current animation then don't even bother running the class-based animation
            currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural
          )
        );
        rules.cancel.push(
          (newAnimation, currentAnimation) => (
            // there can never be two structural animations running at the same time
            currentAnimation.structural && newAnimation.structural
          )
        );
        rules.cancel.push(
          (newAnimation, currentAnimation) => (
            // if the previous animation is already running, but the new animation will
            // be triggered, but the new animation is structural
            currentAnimation.state === RUNNING_STATE && newAnimation.structural
          )
        );
        rules.cancel.push((newAnimation, currentAnimation) => {
          if (currentAnimation.structural) return false;
          const nA = newAnimation.addClass;
          const nR = newAnimation.removeClass;
          const cA = currentAnimation.addClass;
          const cR = currentAnimation.removeClass;
          if (isUndefined(nA) && isUndefined(nR) || isUndefined(cA) && isUndefined(cR)) {
            return false;
          }
          return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
        });
        this.$get = [
          $injectTokens.$rootScope,
          $injectTokens.$injector,
          $injectTokens.$$animation,
          $injectTokens.$$AnimateRunner,
          $injectTokens.$templateRequest,
          /**
           *
           * @param {import('../core/scope/scope.js').Scope} $rootScope
           * @param {import('../core/di/internal-injector.js').InjectorService} $injector
           * @param {*} $$animation
           * @param {*} $$AnimateRunner
           * @param {*} $templateRequest
           * @returns
           */
          function($rootScope, $injector, $$animation, $$AnimateRunner, $templateRequest) {
            const activeAnimationsLookup = /* @__PURE__ */ new Map();
            const disabledElementsLookup = /* @__PURE__ */ new Map();
            let animationsEnabled = null;
            function removeFromDisabledElementsLookup(evt) {
              disabledElementsLookup.delete(evt.target);
            }
            function postDigestTaskFactory() {
              let postDigestCalled = false;
              return function(fn) {
                if (postDigestCalled) {
                  fn();
                } else {
                  $rootScope.$postUpdate(() => {
                    postDigestCalled = true;
                    fn();
                  });
                }
              };
            }
            $rootScope["templateRequest"] = $templateRequest;
            const deregisterWatch = $rootScope.$watch(
              "$templateRequest.totalPendingRequests",
              (val2) => {
                if (val2 === 0) {
                  deregisterWatch();
                  $rootScope["$templateRequest"] = void 0;
                  $rootScope.$postUpdate(() => {
                    $rootScope.$postUpdate(() => {
                      if (animationsEnabled === null) {
                        animationsEnabled = true;
                      }
                    });
                  });
                }
              },
              true
            );
            const callbackRegistry = /* @__PURE__ */ Object.create(null);
            const customFilter = $animateProvider.customFilter();
            const classNameFilter = $animateProvider.classNameFilter();
            const returnTrue = function() {
              return true;
            };
            const isAnimatableByFilter = customFilter || returnTrue;
            const isAnimatableClassName = !classNameFilter ? returnTrue : function(node, options) {
              const className = [
                node.getAttribute("class"),
                options.addClass,
                options.removeClass
              ].join(" ");
              return classNameFilter.test(className);
            };
            const applyAnimationClasses = applyAnimationClassesFactory();
            function normalizeAnimationDetails(element, animation) {
              return mergeAnimationDetails(element, animation, {});
            }
            const contains2 = window.Node.prototype.contains || function(arg) {
              return this === arg || !!(this.compareDocumentPosition(arg) & 16);
            };
            function findCallbacks(targetParentNode, targetNode, event) {
              const matches = [];
              const entries = callbackRegistry[event];
              if (entries) {
                entries.forEach((entry) => {
                  if (contains2.call(entry.node, targetNode)) {
                    matches.push(entry.callback);
                  } else if (event === "leave" && contains2.call(entry.node, targetParentNode)) {
                    matches.push(entry.callback);
                  }
                });
              }
              return matches;
            }
            function filterFromRegistry(list, matchContainer, matchCallback) {
              const containerNode = extractElementNode(matchContainer);
              return list.filter((entry) => {
                const isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                return !isMatch;
              });
            }
            function cleanupEventListeners(phase, node) {
              if (phase === "close" && !node.parentNode) {
                $animate.off(node);
              }
            }
            let $animate = {
              on(event, container, callback) {
                const node = extractElementNode(container);
                callbackRegistry[event] = callbackRegistry[event] || [];
                callbackRegistry[event].push({
                  node,
                  callback
                });
                container.addEventListener("$destroy", () => {
                  const animationDetails = activeAnimationsLookup.get(node);
                  if (!animationDetails) {
                    $animate.off(event, container, callback);
                  }
                });
              },
              off(event, container, callback) {
                if (arguments.length === 1 && !isString(arguments[0])) {
                  container = arguments[0];
                  for (const eventType in callbackRegistry) {
                    callbackRegistry[eventType] = filterFromRegistry(
                      callbackRegistry[eventType],
                      container
                    );
                  }
                  return;
                }
                const entries = callbackRegistry[event];
                if (!entries) return;
                callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
              },
              pin(element, parentElement) {
                assertArg(isElement(element), "element", "not an element");
                assertArg(
                  isElement(parentElement),
                  "parentElement",
                  "not an element"
                );
                setCacheData(element, NG_ANIMATE_PIN_DATA, parentElement);
              },
              push(element, event, options, domOperation) {
                options = options || {};
                options.domOperation = domOperation;
                return queueAnimation(element, event, options);
              },
              // this method has four signatures:
              //  () - global getter
              //  (bool) - global setter
              //  (element) - element getter
              //  (element, bool) - element setter<F37>
              enabled(element, bool) {
                const argCount = arguments.length;
                if (argCount === 0) {
                  bool = !!animationsEnabled;
                } else {
                  const hasElement = isElement(element);
                  if (!hasElement) {
                    bool = animationsEnabled = !!element;
                  } else {
                    const node = element;
                    if (argCount === 1) {
                      bool = !disabledElementsLookup.get(node);
                    } else {
                      if (!disabledElementsLookup.has(node)) {
                        element.addEventListener(
                          "$destroy",
                          removeFromDisabledElementsLookup
                        );
                      }
                      disabledElementsLookup.set(node, !bool);
                    }
                  }
                }
                return bool;
              }
            };
            return $animate;
            function queueAnimation(originalElement, event, initialOptions) {
              let options = initialOptions;
              let element = Array.isArray(originalElement) ? originalElement.filter((x) => x.nodeName !== "#comment")[0] : originalElement;
              const node = element;
              const parentNode = node && node.parentNode;
              options = prepareAnimationOptions(options);
              const runner = new $$AnimateRunner();
              const runInNextPostDigestOrNow = postDigestTaskFactory();
              if (Array.isArray(options.addClass)) {
                options.addClass = options.addClass.join(" ");
              }
              if (options.addClass && !isString(options.addClass)) {
                options.addClass = null;
              }
              if (Array.isArray(options.removeClass)) {
                options.removeClass = options.removeClass.join(" ");
              }
              if (options.removeClass && !isString(options.removeClass)) {
                options.removeClass = null;
              }
              if (options.from && !isObject(options.from)) {
                options.from = null;
              }
              if (options.to && !isObject(options.to)) {
                options.to = null;
              }
              if (
                // !animationsEnabled ||
                !node || !isAnimatableByFilter(node, event, initialOptions) || !isAnimatableClassName(node, options)
              ) {
                close();
                return runner;
              }
              const isStructural = ["enter", "move", "leave"].indexOf(event) >= 0;
              let skipAnimations = document.hidden || disabledElementsLookup.get(node);
              const existingAnimation = !skipAnimations && activeAnimationsLookup.get(node) || {};
              const hasExistingAnimation = !!existingAnimation.state;
              if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state !== PRE_DIGEST_STATE)) {
                skipAnimations = !areAnimationsAllowed(node, parentNode);
              }
              if (skipAnimations) {
                if (document.hidden)
                  notifyProgress(runner, event, "start", getEventData(options));
                close();
                if (document.hidden)
                  notifyProgress(runner, event, "close", getEventData(options));
                return runner;
              }
              if (isStructural) {
                closeChildAnimations(node);
              }
              const newAnimation = {
                structural: isStructural,
                element,
                event,
                addClass: options.addClass,
                removeClass: options.removeClass,
                close,
                options,
                runner
              };
              if (hasExistingAnimation) {
                const skipAnimationFlag = isAllowed(
                  "skip",
                  newAnimation,
                  existingAnimation
                );
                if (skipAnimationFlag) {
                  if (existingAnimation.state === RUNNING_STATE) {
                    close();
                    return runner;
                  }
                  mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
                const cancelAnimationFlag = isAllowed(
                  "cancel",
                  newAnimation,
                  existingAnimation
                );
                if (cancelAnimationFlag) {
                  if (existingAnimation.state === RUNNING_STATE) {
                    existingAnimation.runner.end();
                  } else if (existingAnimation.structural) {
                    existingAnimation.close();
                  } else {
                    mergeAnimationDetails(element, existingAnimation, newAnimation);
                    return existingAnimation.runner;
                  }
                } else {
                  const joinAnimationFlag = isAllowed(
                    "join",
                    newAnimation,
                    existingAnimation
                  );
                  if (joinAnimationFlag) {
                    if (existingAnimation.state === RUNNING_STATE) {
                      normalizeAnimationDetails(element, newAnimation);
                    } else {
                      applyGeneratedPreparationClasses(
                        element,
                        isStructural ? event : null,
                        options
                      );
                      event = newAnimation.event = existingAnimation.event;
                      options = mergeAnimationDetails(
                        element,
                        existingAnimation,
                        newAnimation
                      );
                      return existingAnimation.runner;
                    }
                  }
                }
              } else {
                normalizeAnimationDetails(element, newAnimation);
              }
              let isValidAnimation = newAnimation.structural;
              if (!isValidAnimation) {
                isValidAnimation = newAnimation.event === "animate" && Object.keys(newAnimation.options.to || {}).length > 0 || hasAnimationClasses(newAnimation);
              }
              if (!isValidAnimation) {
                close();
                clearElementAnimationState(node);
                return runner;
              }
              const counter = (existingAnimation.counter || 0) + 1;
              newAnimation.counter = counter;
              markElementAnimationState(node, PRE_DIGEST_STATE, newAnimation);
              $rootScope.$postUpdate(() => {
                element = stripCommentsFromElement(originalElement);
                let animationDetails = activeAnimationsLookup.get(node);
                const animationCancelled = !animationDetails;
                animationDetails = animationDetails || {};
                const parentElement = element.parentElement || [];
                const isValidAnimation2 = parentElement && (animationDetails.event === "animate" || animationDetails.structural || hasAnimationClasses(animationDetails));
                if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation2) {
                  if (animationCancelled) {
                    applyAnimationClasses(element, options);
                    applyAnimationStyles(element, options);
                  }
                  if (animationCancelled || isStructural && animationDetails.event !== event) {
                    options.domOperation();
                    runner.end();
                  }
                  if (!isValidAnimation2) {
                    clearElementAnimationState(node);
                  }
                  return;
                }
                event = !animationDetails.structural && hasAnimationClasses(animationDetails, true) ? "setClass" : animationDetails.event;
                markElementAnimationState(node, RUNNING_STATE);
                const realRunner = $$animation(
                  element,
                  event,
                  animationDetails.options
                );
                runner.setHost(realRunner);
                notifyProgress(runner, event, "start", getEventData(options));
                realRunner.done((status) => {
                  close(!status);
                  const animationDetails2 = activeAnimationsLookup.get(node);
                  if (animationDetails2 && animationDetails2.counter === counter) {
                    clearElementAnimationState(node);
                  }
                  notifyProgress(runner, event, "close", getEventData(options));
                });
              });
              return runner;
              function notifyProgress(runner2, event2, phase, data) {
                runInNextPostDigestOrNow(() => {
                  const callbacks = findCallbacks(parentNode, node, event2);
                  if (callbacks.length) {
                    callbacks.forEach((callback) => {
                      callback(element, phase, data);
                    });
                    cleanupEventListeners(phase, node);
                  } else {
                    cleanupEventListeners(phase, node);
                  }
                });
                runner2.progress(event2, phase, data);
              }
              function close(reject) {
                clearGeneratedClasses(element, options);
                applyAnimationClasses(element, options);
                applyAnimationStyles(element, options);
                options.domOperation();
                runner.complete(!reject);
              }
            }
            function closeChildAnimations(node) {
              const children = node.querySelectorAll(`[${NG_ANIMATE_ATTR_NAME}]`);
              children.forEach((child) => {
                const state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10);
                const animationDetails = activeAnimationsLookup.get(child);
                if (animationDetails) {
                  switch (state) {
                    case RUNNING_STATE:
                      animationDetails.runner.end();
                    /* falls through */
                    case PRE_DIGEST_STATE:
                      activeAnimationsLookup.delete(child);
                      break;
                  }
                }
              });
            }
            function clearElementAnimationState(node) {
              node.removeAttribute(NG_ANIMATE_ATTR_NAME);
              activeAnimationsLookup.delete(node);
            }
            function areAnimationsAllowed(node, parentNode) {
              const bodyNode = document.body;
              const rootNode = $injector.get("$rootElement");
              let bodyNodeDetected = node === bodyNode || node.nodeName === "HTML";
              let rootNodeDetected = node === rootNode;
              let parentAnimationDetected = false;
              let elementDisabled = disabledElementsLookup.get(node);
              let animateChildren;
              let parentHost = getOrSetCacheData(node, NG_ANIMATE_PIN_DATA);
              if (parentHost) {
                parentNode = parentHost;
              }
              while (parentNode) {
                if (!rootNodeDetected) {
                  rootNodeDetected = parentNode === rootNode;
                }
                if (parentNode.nodeType !== Node.ELEMENT_NODE) {
                  break;
                }
                const details = activeAnimationsLookup.get(parentNode) || {};
                if (!parentAnimationDetected) {
                  const parentNodeDisabled = disabledElementsLookup.get(parentNode);
                  if (parentNodeDisabled === true && elementDisabled !== false) {
                    elementDisabled = true;
                    break;
                  } else if (parentNodeDisabled === false) {
                    elementDisabled = false;
                  }
                  parentAnimationDetected = details.structural;
                }
                if (isUndefined(animateChildren) || animateChildren === true) {
                  const value = getOrSetCacheData(
                    parentNode,
                    NG_ANIMATE_CHILDREN_DATA
                  );
                  if (isDefined(value)) {
                    animateChildren = value;
                  }
                }
                if (parentAnimationDetected && animateChildren === false) break;
                if (!bodyNodeDetected) {
                  bodyNodeDetected = parentNode === bodyNode;
                }
                if (bodyNodeDetected && rootNodeDetected) {
                  break;
                }
                if (!rootNodeDetected) {
                  parentHost = getOrSetCacheData(parentNode, NG_ANIMATE_PIN_DATA);
                  if (parentHost) {
                    parentNode = parentHost;
                    continue;
                  }
                }
                parentNode = parentNode.parentNode;
              }
              const allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
              return allowAnimation && rootNodeDetected && bodyNodeDetected;
            }
            function markElementAnimationState(node, state, details) {
              details = details || {};
              details.state = state;
              node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
              const oldValue = activeAnimationsLookup.get(node);
              const newValue = oldValue ? extend(oldValue, details) : details;
              activeAnimationsLookup.set(node, newValue);
            }
          }
        ];
      }
      AnimateJsProvider.$inject = ["$animateProvider"];
      function AnimateJsProvider($animateProvider) {
        this.$get = [
          $injectTokens.$injector,
          "$$AnimateRunner",
          /**
           *
           * @param {import("../core/di/internal-injector").InjectorService} $injector
           * @param {*} $$AnimateRunner
           * @returns
           */
          function($injector, $$AnimateRunner) {
            const applyAnimationClasses = applyAnimationClassesFactory();
            return function(element, event, classes, options) {
              let animationClosed = false;
              if (arguments.length === 3 && isObject(classes)) {
                options = classes;
                classes = null;
              }
              options = prepareAnimationOptions(options);
              if (!classes) {
                classes = element.getAttribute("class") || "";
                if (options.addClass) {
                  classes += ` ${options.addClass}`;
                }
                if (options.removeClass) {
                  classes += ` ${options.removeClass}`;
                }
              }
              const classesToAdd = options.addClass;
              const classesToRemove = options.removeClass;
              const animations = lookupAnimations(classes);
              let before;
              let after;
              if (animations.length) {
                let afterFn;
                let beforeFn;
                if (event === "leave") {
                  beforeFn = "leave";
                  afterFn = "afterLeave";
                } else {
                  beforeFn = `before${event.charAt(0).toUpperCase()}${event.substring(1)}`;
                  afterFn = event;
                }
                if (event !== "enter" && event !== "move") {
                  before = packageAnimations(
                    element,
                    event,
                    options,
                    animations,
                    beforeFn
                  );
                }
                after = packageAnimations(
                  element,
                  event,
                  options,
                  animations,
                  afterFn
                );
              }
              if (!before && !after) return;
              function applyOptions() {
                options.domOperation();
                applyAnimationClasses(element, options);
              }
              function close() {
                animationClosed = true;
                applyOptions();
                applyAnimationStyles(element, options);
              }
              let runner;
              return {
                $$willAnimate: true,
                end() {
                  if (runner) {
                    runner.end();
                  } else {
                    close();
                    runner = new $$AnimateRunner();
                    runner.complete(true);
                  }
                  return runner;
                },
                start() {
                  if (runner) {
                    return runner;
                  }
                  runner = new $$AnimateRunner();
                  let closeActiveAnimations;
                  const chain = [];
                  if (before) {
                    chain.push((fn) => {
                      closeActiveAnimations = before(fn);
                    });
                  }
                  if (chain.length) {
                    chain.push((fn) => {
                      applyOptions();
                      fn(true);
                    });
                  } else {
                    applyOptions();
                  }
                  if (after) {
                    chain.push((fn) => {
                      closeActiveAnimations = after(fn);
                    });
                  }
                  runner.setHost({
                    end() {
                      endAnimations();
                    },
                    cancel() {
                      endAnimations(true);
                    }
                  });
                  $$AnimateRunner.chain(chain, onComplete);
                  return runner;
                  function onComplete(success) {
                    close();
                    runner.complete(success);
                  }
                  function endAnimations(cancelled) {
                    if (!animationClosed) {
                      (closeActiveAnimations || (() => {
                      }))(cancelled);
                      onComplete(cancelled);
                    }
                  }
                }
              };
              function executeAnimationFn(fn, element2, event2, options2, onDone) {
                let args;
                switch (event2) {
                  case "animate":
                    args = [element2, options2.from, options2.to, onDone];
                    break;
                  case "setClass":
                    args = [element2, classesToAdd, classesToRemove, onDone];
                    break;
                  case "addClass":
                    args = [element2, classesToAdd, onDone];
                    break;
                  case "removeClass":
                    args = [element2, classesToRemove, onDone];
                    break;
                  default:
                    args = [element2, onDone];
                    break;
                }
                args.push(options2);
                let value = fn.apply(fn, args);
                if (value) {
                  if (isFunction(value.start)) {
                    value = value.start();
                  }
                  if (value instanceof $$AnimateRunner) {
                    value.done(onDone);
                  } else if (isFunction(value)) {
                    return value;
                  }
                }
                return () => {
                };
              }
              function groupEventedAnimations(element2, event2, options2, animations2, fnName) {
                const operations = [];
                animations2.forEach((ani) => {
                  const animation = ani[fnName];
                  if (!animation) return;
                  operations.push(() => {
                    let runner2;
                    let endProgressCb;
                    let resolved = false;
                    const onAnimationComplete = function(rejected) {
                      if (!resolved) {
                        resolved = true;
                        (endProgressCb || (() => {
                        }))(rejected);
                        runner2.complete(!rejected);
                      }
                    };
                    runner2 = new $$AnimateRunner({
                      end() {
                        onAnimationComplete();
                      },
                      cancel() {
                        onAnimationComplete(true);
                      }
                    });
                    endProgressCb = executeAnimationFn(
                      animation,
                      element2,
                      event2,
                      options2,
                      (result) => {
                        const cancelled = result === false;
                        onAnimationComplete(cancelled);
                      }
                    );
                    return runner2;
                  });
                });
                return operations;
              }
              function packageAnimations(element2, event2, options2, animations2, fnName) {
                let operations = groupEventedAnimations(
                  element2,
                  event2,
                  options2,
                  animations2,
                  fnName
                );
                if (operations.length === 0) {
                  let a;
                  let b;
                  if (fnName === "beforeSetClass") {
                    a = groupEventedAnimations(
                      element2,
                      "removeClass",
                      options2,
                      animations2,
                      "beforeRemoveClass"
                    );
                    b = groupEventedAnimations(
                      element2,
                      "addClass",
                      options2,
                      animations2,
                      "beforeAddClass"
                    );
                  } else if (fnName === "setClass") {
                    a = groupEventedAnimations(
                      element2,
                      "removeClass",
                      options2,
                      animations2,
                      "removeClass"
                    );
                    b = groupEventedAnimations(
                      element2,
                      "addClass",
                      options2,
                      animations2,
                      "addClass"
                    );
                  }
                  if (a) {
                    operations = operations.concat(a);
                  }
                  if (b) {
                    operations = operations.concat(b);
                  }
                }
                if (operations.length === 0) return;
                return function startAnimation(callback) {
                  const runners = [];
                  if (operations.length) {
                    operations.forEach((animateFn) => {
                      runners.push(animateFn());
                    });
                  }
                  if (runners.length) {
                    $$AnimateRunner.all(runners, callback);
                  } else {
                    callback();
                  }
                  return function endFn(reject) {
                    runners.forEach((runner2) => {
                      if (reject) {
                        runner2.cancel();
                      } else {
                        runner2.end();
                      }
                    });
                  };
                };
              }
            };
            function lookupAnimations(classes) {
              classes = Array.isArray(classes) ? classes : classes.split(" ");
              const matches = [];
              const flagMap = {};
              for (let i = 0; i < classes.length; i++) {
                const klass = classes[i];
                const animationFactory = $animateProvider.$$registeredAnimations[klass];
                if (animationFactory && !flagMap[klass]) {
                  matches.push($injector.get(animationFactory));
                  flagMap[klass] = true;
                }
              }
              return matches;
            }
          }
        ];
      }
      const RUNNER_STORAGE_KEY = "$$animationRunner";
      const PREPARE_CLASSES_KEY = "$$animatePrepareClasses";
      function AnimationProvider() {
        const NG_ANIMATE_REF_ATTR = "ng-animate-ref";
        const drivers = this.drivers = [];
        function setRunner(element, runner) {
          setCacheData(element, RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
          deleteCacheData(element, RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
          return getCacheData(element, RUNNER_STORAGE_KEY);
        }
        this.$get = [
          "$rootScope",
          "$injector",
          "$$AnimateRunner",
          "$$rAFScheduler",
          "$$animateCache",
          /**
           *
           * @param {*} $rootScope
           * @param {import("../core/di/internal-injector").InjectorService} $injector
           * @param {*} $$AnimateRunner
           * @param {import("./raf-scheduler").RafScheduler} $$rAFScheduler
           * @param {*} $$animateCache
           * @returns
           */
          function($rootScope, $injector, $$AnimateRunner, $$rAFScheduler, $$animateCache) {
            const animationQueue = [];
            const applyAnimationClasses = applyAnimationClassesFactory();
            function sortAnimations(animations) {
              const tree = { children: [] };
              let i;
              const lookup = /* @__PURE__ */ new Map();
              for (i = 0; i < animations.length; i++) {
                const animation = animations[i];
                lookup.set(
                  animation.domNode,
                  animations[i] = {
                    domNode: animation.domNode,
                    element: animation.element,
                    fn: animation.fn,
                    children: []
                  }
                );
              }
              for (i = 0; i < animations.length; i++) {
                processNode(animations[i]);
              }
              return flatten(tree);
              function processNode(entry) {
                if (entry.processed) return entry;
                entry.processed = true;
                const elementNode = entry.domNode;
                let { parentNode } = elementNode;
                lookup.set(elementNode, entry);
                let parentEntry;
                while (parentNode) {
                  parentEntry = lookup.get(parentNode);
                  if (parentEntry) {
                    if (!parentEntry.processed) {
                      parentEntry = processNode(parentEntry);
                    }
                    break;
                  }
                  parentNode = parentNode.parentNode;
                }
                (parentEntry || tree).children.push(entry);
                return entry;
              }
              function flatten(tree2) {
                const result = [];
                const queue = [];
                let i2;
                for (i2 = 0; i2 < tree2.children.length; i2++) {
                  queue.push(tree2.children[i2]);
                }
                let remainingLevelEntries = queue.length;
                let nextLevelEntries = 0;
                let row = [];
                for (i2 = 0; i2 < queue.length; i2++) {
                  const entry = queue[i2];
                  if (remainingLevelEntries <= 0) {
                    remainingLevelEntries = nextLevelEntries;
                    nextLevelEntries = 0;
                    result.push(row);
                    row = [];
                  }
                  row.push(entry);
                  entry.children.forEach((childEntry) => {
                    nextLevelEntries++;
                    queue.push(childEntry);
                  });
                  remainingLevelEntries--;
                }
                if (row.length) {
                  result.push(row);
                }
                return result;
              }
            }
            return function(element, event, options) {
              options = prepareAnimationOptions(options);
              const isStructural = ["enter", "move", "leave"].indexOf(event) >= 0;
              const runner = new $$AnimateRunner({
                end() {
                  close();
                },
                cancel() {
                  close(true);
                }
              });
              if (!drivers.length) {
                close();
                return runner;
              }
              let classes = mergeClasses$1(
                element.getAttribute("class"),
                mergeClasses$1(options.addClass, options.removeClass)
              );
              let { tempClasses } = options;
              if (tempClasses) {
                classes += ` ${tempClasses}`;
                options.tempClasses = null;
              }
              if (isStructural) {
                setCacheData(
                  element,
                  PREPARE_CLASSES_KEY,
                  `ng-${event}${PREPARE_CLASS_SUFFIX}`
                );
              }
              setRunner(element, runner);
              animationQueue.push({
                // this data is used by the postDigest code and passed into
                // the driver step function
                element,
                classes,
                event,
                structural: isStructural,
                options,
                beforeStart,
                close
              });
              element.addEventListener("$destroy", handleDestroyedElement);
              if (animationQueue.length > 1) return runner;
              $rootScope.$postUpdate(() => {
                const animations = [];
                animationQueue.forEach((entry) => {
                  if (getRunner(entry.element)) {
                    animations.push(entry);
                  } else {
                    entry.close();
                  }
                });
                animationQueue.length = 0;
                const groupedAnimations = groupAnimations(animations);
                const toBeSortedAnimations = [];
                groupedAnimations.forEach((animationEntry) => {
                  const element2 = animationEntry.from ? animationEntry.from.element : animationEntry.element;
                  let extraClasses = options.addClass;
                  extraClasses = (extraClasses ? `${extraClasses} ` : "") + NG_ANIMATE_CLASSNAME;
                  const cacheKey = $$animateCache.cacheKey(
                    element2,
                    animationEntry.event,
                    extraClasses,
                    options.removeClass
                  );
                  toBeSortedAnimations.push({
                    element: element2,
                    domNode: element2,
                    fn: function triggerAnimationStart() {
                      let startAnimationFn;
                      const closeFn = animationEntry.close;
                      if ($$animateCache.containsCachedAnimationWithoutDuration(
                        cacheKey
                      )) {
                        closeFn();
                        return;
                      }
                      animationEntry.beforeStart();
                      const targetElement = animationEntry.anchors ? animationEntry.from.element || animationEntry.to.element : animationEntry.element;
                      if (getRunner(targetElement)) {
                        const operation = invokeFirstDriver(animationEntry);
                        if (operation) {
                          startAnimationFn = operation.start;
                        }
                      }
                      if (!startAnimationFn) {
                        closeFn();
                      } else {
                        const animationRunner = startAnimationFn();
                        animationRunner.done((status) => {
                          closeFn(!status);
                        });
                        updateAnimationRunners(animationEntry, animationRunner);
                      }
                    }
                  });
                });
                const finalAnimations = sortAnimations(toBeSortedAnimations);
                for (let i = 0; i < finalAnimations.length; i++) {
                  const innerArray = finalAnimations[i];
                  for (let j = 0; j < innerArray.length; j++) {
                    const entry = innerArray[j];
                    const { element: element2 } = entry;
                    finalAnimations[i][j] = entry.fn;
                    if (i === 0) {
                      removeElementData(element2, PREPARE_CLASSES_KEY);
                      continue;
                    }
                    const prepareClassName = getCacheData(
                      element2,
                      PREPARE_CLASSES_KEY
                    );
                    if (prepareClassName) {
                      element2.classList.add(prepareClassName);
                    }
                  }
                }
                $$rAFScheduler(finalAnimations);
              });
              return runner;
              function getAnchorNodes(node) {
                const SELECTOR = `[${NG_ANIMATE_REF_ATTR}]`;
                const items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR);
                const anchors = [];
                items.forEach((node2) => {
                  const attr = node2.getAttribute(NG_ANIMATE_REF_ATTR);
                  if (attr && attr.length) {
                    anchors.push(node2);
                  }
                });
                return anchors;
              }
              function groupAnimations(animations) {
                const preparedAnimations = [];
                const refLookup = {};
                animations.forEach((animation, index) => {
                  const { element: element2 } = animation;
                  const node = element2;
                  const { event: event2 } = animation;
                  const enterOrMove = ["enter", "move"].indexOf(event2) >= 0;
                  const anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                  if (anchorNodes.length) {
                    const direction = enterOrMove ? "to" : "from";
                    anchorNodes.forEach((anchor) => {
                      const key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                      refLookup[key] = refLookup[key] || {};
                      refLookup[key][direction] = {
                        animationID: index,
                        element: anchor
                      };
                    });
                  } else {
                    preparedAnimations.push(animation);
                  }
                });
                const usedIndicesLookup = {};
                const anchorGroups = {};
                Object.values(refLookup).forEach((operations) => {
                  const { from } = operations;
                  const { to } = operations;
                  if (!from || !to) {
                    const index = from ? from.animationID : to.animationID;
                    const indexKey = index.toString();
                    if (!usedIndicesLookup[indexKey]) {
                      usedIndicesLookup[indexKey] = true;
                      preparedAnimations.push(animations[index]);
                    }
                    return;
                  }
                  const fromAnimation = animations[from.animationID];
                  const toAnimation = animations[to.animationID];
                  const lookupKey = from.animationID.toString();
                  if (!anchorGroups[lookupKey]) {
                    const group = anchorGroups[lookupKey] = {
                      structural: true,
                      beforeStart() {
                        fromAnimation.beforeStart();
                        toAnimation.beforeStart();
                      },
                      close() {
                        fromAnimation.close();
                        toAnimation.close();
                      },
                      classes: cssClassesIntersection(
                        fromAnimation.classes,
                        toAnimation.classes
                      ),
                      from: fromAnimation,
                      to: toAnimation,
                      anchors: []
                      // TODO(matsko): change to reference nodes
                    };
                    if (group.classes.length) {
                      preparedAnimations.push(group);
                    } else {
                      preparedAnimations.push(fromAnimation);
                      preparedAnimations.push(toAnimation);
                    }
                  }
                  anchorGroups[lookupKey].anchors.push({
                    out: from.element,
                    in: to.element
                  });
                });
                return preparedAnimations;
              }
              function cssClassesIntersection(a, b) {
                a = a.split(" ");
                b = b.split(" ");
                const matches = [];
                for (let i = 0; i < a.length; i++) {
                  const aa = a[i];
                  if (aa.substring(0, 3) === "ng-") continue;
                  for (let j = 0; j < b.length; j++) {
                    if (aa === b[j]) {
                      matches.push(aa);
                      break;
                    }
                  }
                }
                return matches.join(" ");
              }
              function invokeFirstDriver(animationDetails) {
                for (let i = drivers.length - 1; i >= 0; i--) {
                  const driverName = drivers[i];
                  const factory = $injector.get(driverName);
                  const driver = factory(animationDetails);
                  if (driver) {
                    return driver;
                  }
                }
              }
              function beforeStart() {
                tempClasses = (tempClasses ? `${tempClasses} ` : "") + NG_ANIMATE_CLASSNAME;
                element.className += ` ${tempClasses}`;
                let prepareClassName = getCacheData(element, PREPARE_CLASSES_KEY);
                if (prepareClassName) {
                  element.classList.remove(prepareClassName);
                  prepareClassName = null;
                }
              }
              function updateAnimationRunners(animation, newRunner) {
                if (animation.from && animation.to) {
                  update(animation.from.element);
                  update(animation.to.element);
                } else {
                  update(animation.element);
                }
                function update(element2) {
                  const runner2 = getRunner(element2);
                  if (runner2) runner2.setHost(newRunner);
                }
              }
              function handleDestroyedElement() {
                const runner2 = getRunner(element);
                if (runner2 && (event !== "leave" || !options.$$domOperationFired)) {
                  runner2.end();
                }
              }
              function close(rejected) {
                removeRunner(element);
                applyAnimationClasses(element, options);
                applyAnimationStyles(element, options);
                options.domOperation();
                if (tempClasses) {
                  tempClasses.split(" ").forEach((cls) => element.classList.remove(cls));
                }
                runner.complete(!rejected);
              }
            };
          }
        ];
      }
      class RafSchedulerProvider {
        constructor() {
          this.queue = [];
          this.cancelFn = null;
        }
        /**
         * Processes the next batch of tasks in the animation frame.
         * Executes the first group of functions in the queue, then
         * schedules the next frame if needed.
         */
        nextTick() {
          if (!this.queue.length) return;
          const items = this.queue.shift();
          items.forEach((fn) => fn());
          if (!this.cancelFn) {
            this.cancelFn = window.requestAnimationFrame(() => {
              this.cancelFn = null;
              this.nextTick();
            });
          }
        }
        /**
         * Returns the scheduler function.
         * This function allows tasks to be queued for execution on future animation frames.
         * It also has helper methods and state attached.
         *
         * @returns {RafScheduler} The scheduler function with `queue` and `waitUntilQuiet`.
         */
        $get() {
          const scheduler = (tasks) => {
            this.queue = this.queue.concat(tasks);
            this.nextTick();
          };
          scheduler.queue = this.queue;
          scheduler.waitUntilQuiet = (fn) => {
            if (this.cancelFn !== null) {
              window.cancelAnimationFrame(this.cancelFn);
              this.cancelFn = null;
            }
            this.cancelFn = window.requestAnimationFrame(() => {
              this.cancelFn = null;
              fn();
              this.nextTick();
            });
          };
          return scheduler;
        }
      }
      const KEY = "$animId";
      let parentCounter = 0;
      const cache = /* @__PURE__ */ new Map();
      function animateCache() {
        return {
          /**
           * Generates a unique cache key based on the node's parent and other parameters.
           * @param {HTMLElement} node - The DOM node to generate the cache key for.
           * @param {string} method - The animation method being applied.
           * @param {string} [addClass] - Class to add during the animation.
           * @param {string} [removeClass] - Class to remove during the animation.
           * @returns {string} - The generated cache key.
           */
          cacheKey(node, method, addClass, removeClass) {
            const { parentNode } = node;
            const parentID = parentNode[KEY] ?? (parentNode[KEY] = ++parentCounter);
            const parts = [parentID, method, node.getAttribute("class")];
            if (addClass) parts.push(addClass);
            if (removeClass) parts.push(removeClass);
            return parts.join(" ");
          },
          /**
           * Checks if a cached animation without a duration exists.
           * @param {string} key - The cache key to check.
           * @returns {boolean} - True if an invalid animation is cached, false otherwise.
           */
          containsCachedAnimationWithoutDuration(key) {
            const entry = cache.get(key);
            return entry ? !entry.isValid : false;
          },
          /**
           * Clears the cache.
           * @returns {void}
           */
          flush() {
            cache.clear();
          },
          /**
           * Gets the count of a specific cache entry.
           * @param {string} key - The cache key to count.
           * @returns {number} - The count of the cache entry.
           */
          count(key) {
            return cache.get(key)?.total ?? 0;
          },
          /**
           * Retrieves a value associated with a specific cache key.
           * @param {string} key - The cache key to retrieve.
           * @returns {any} - The value associated with the cache key.
           */
          get(key) {
            return cache.get(key)?.value;
          },
          /**
           * Adds or updates a cache entry.
           * @param {string} key - The cache key to add or update.
           * @param {any} value - The value to store.
           * @param {boolean} isValid - Whether the cache entry is valid.
           */
          put(key, value, isValid) {
            const entry = cache.get(key);
            if (entry) {
              entry.total++;
              entry.value = value;
            } else {
              cache.set(key, { total: 1, value, isValid });
            }
          }
        };
      }
      function AnimateCacheProvider() {
        this.$get = [animateCache];
      }
      const NG_ANIMATE_SHIM_CLASS_NAME = "ng-animate-shim";
      const NG_ANIMATE_ANCHOR_CLASS_NAME = "ng-anchor";
      const NG_OUT_ANCHOR_CLASS_NAME = "ng-anchor-out";
      const NG_IN_ANCHOR_CLASS_NAME = "ng-anchor-in";
      AnimateCssDriverProvider.$inject = ["$$animationProvider"];
      function AnimateCssDriverProvider($$animationProvider) {
        $$animationProvider.drivers.push("$$animateCssDriver");
        function isDocumentFragment(node) {
          return node.parentNode && node.parentNode.nodeType === 11;
        }
        this.$get = [
          "$animateCss",
          "$$AnimateRunner",
          "$rootElement",
          /**
           *
           * @param {*} $animateCss
           * @param {typeof import('./animate-runner.js').AnimateRunner} $$AnimateRunner
           * @param {Element} $rootElement
           * @returns
           */
          function($animateCss, $$AnimateRunner, $rootElement) {
            const bodyNode = document.body;
            const rootNode = $rootElement;
            const rootBodyElement = (
              // this is to avoid using something that exists outside of the body
              // we also special case the doc fragment case because our unit test code
              // appends the $rootElement to the body after the app has been bootstrapped
              isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode
            );
            return function initDriverFn(animationDetails) {
              return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(
                animationDetails.from,
                animationDetails.to,
                animationDetails.anchors
              ) : prepareRegularAnimation(animationDetails);
            };
            function prepareAnchoredAnimation(outAnchor, inAnchor) {
              const clone = outAnchor.cloneNode(true);
              const startingClasses = filterCssClasses(getClassVal(clone));
              outAnchor[0].classList.add(NG_ANIMATE_SHIM_CLASS_NAME);
              inAnchor[0].classList.add(NG_ANIMATE_SHIM_CLASS_NAME);
              clone.classList.add(NG_ANIMATE_ANCHOR_CLASS_NAME);
              rootBodyElement.append(clone);
              let animatorIn;
              const animatorOut = prepareOutAnimation();
              if (!animatorOut) {
                animatorIn = prepareInAnimation();
                if (!animatorIn) {
                  return end();
                }
              }
              const startingAnimator = animatorOut || animatorIn;
              return {
                start() {
                  let runner;
                  let currentAnimation = startingAnimator.start();
                  currentAnimation.done(() => {
                    currentAnimation = null;
                    if (!animatorIn) {
                      animatorIn = prepareInAnimation();
                      if (animatorIn) {
                        currentAnimation = animatorIn.start();
                        currentAnimation.done(() => {
                          currentAnimation = null;
                          end();
                          runner.complete();
                        });
                        return currentAnimation;
                      }
                    }
                    end();
                    runner.complete();
                  });
                  runner = new $$AnimateRunner({
                    end: endFn,
                    cancel: endFn
                  });
                  return runner;
                  function endFn() {
                    if (currentAnimation) {
                      currentAnimation.end();
                    }
                  }
                }
              };
              function calculateAnchorStyles(anchor) {
                const styles = {};
                const coords = anchor.getBoundingClientRect();
                ["width", "height", "top", "left"].forEach((key) => {
                  let value = coords[key];
                  switch (key) {
                    case "top":
                      value += bodyNode.scrollTop;
                      break;
                    case "left":
                      value += bodyNode.scrollLeft;
                      break;
                  }
                  styles[key] = `${Math.floor(value)}px`;
                });
                return styles;
              }
              function prepareOutAnimation() {
                const animator = $animateCss(clone, {
                  addClass: NG_OUT_ANCHOR_CLASS_NAME,
                  delay: true,
                  from: calculateAnchorStyles(outAnchor)
                });
                return animator.$$willAnimate ? animator : null;
              }
              function getClassVal(element) {
                return element.getAttribute("class") || "";
              }
              function prepareInAnimation() {
                const endingClasses = filterCssClasses(getClassVal(inAnchor));
                const toAdd = getUniqueValues(endingClasses, startingClasses);
                const toRemove = getUniqueValues(startingClasses, endingClasses);
                const animator = $animateCss(clone, {
                  to: calculateAnchorStyles(inAnchor),
                  addClass: `${NG_IN_ANCHOR_CLASS_NAME} ${toAdd}`,
                  removeClass: `${NG_OUT_ANCHOR_CLASS_NAME} ${toRemove}`,
                  delay: true
                });
                return animator.$$willAnimate ? animator : null;
              }
              function end() {
                clone.remove();
                outAnchor[0].classList.remove(NG_ANIMATE_SHIM_CLASS_NAME);
                inAnchor[0].classList.remove(NG_ANIMATE_SHIM_CLASS_NAME);
              }
            }
            function prepareFromToAnchorAnimation(from, to, anchors) {
              const fromAnimation = prepareRegularAnimation(from);
              const toAnimation = prepareRegularAnimation(to);
              const anchorAnimations = [];
              anchors.forEach((anchor) => {
                const outElement = anchor.out;
                const inElement = anchor.in;
                const animator = prepareAnchoredAnimation(outElement, inElement);
                if (animator) {
                  anchorAnimations.push(animator);
                }
              });
              if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
                return;
              return {
                start() {
                  const animationRunners = [];
                  if (fromAnimation) {
                    animationRunners.push(fromAnimation.start());
                  }
                  if (toAnimation) {
                    animationRunners.push(toAnimation.start());
                  }
                  anchorAnimations.forEach((animation) => {
                    animationRunners.push(animation.start());
                  });
                  const runner = new $$AnimateRunner({
                    end: endFn,
                    cancel: endFn
                    // CSS-driven animations cannot be cancelled, only ended
                  });
                  $$AnimateRunner.all(animationRunners, (status) => {
                    runner.complete(status);
                  });
                  return runner;
                  function endFn() {
                    animationRunners.forEach((runner2) => {
                      runner2.end();
                    });
                  }
                }
              };
            }
            function prepareRegularAnimation(animationDetails) {
              const options = animationDetails.options || {};
              if (animationDetails.structural) {
                options.event = animationDetails.event;
                options.structural = true;
                options.applyClassesEarly = true;
                if (animationDetails.event === "leave") {
                  options.onDone = options.domOperation;
                }
              }
              if (options.preparationClasses) {
                options.event = concatWithSpace(
                  options.event,
                  options.preparationClasses
                );
              }
              const animator = $animateCss(animationDetails.element, options);
              return animator.$$willAnimate ? animator : null;
            }
          }
        ];
      }
      function filterCssClasses(classes) {
        return classes.replace(/\bng-\S+\b/g, "");
      }
      function getUniqueValues(a, b) {
        if (isString(a)) a = a.split(" ");
        if (isString(b)) b = b.split(" ");
        return a.filter((val2) => b.indexOf(val2) === -1).join(" ");
      }
      AnimateJsDriverProvider.$inject = ["$$animationProvider"];
      function AnimateJsDriverProvider($$animationProvider) {
        $$animationProvider.drivers.push("$$animateJsDriver");
        this.$get = [
          "$$animateJs",
          "$$AnimateRunner",
          function($$animateJs, $$AnimateRunner) {
            return function initDriverFn(animationDetails) {
              if (animationDetails.from && animationDetails.to) {
                const fromAnimation = prepareAnimation(animationDetails.from);
                const toAnimation = prepareAnimation(animationDetails.to);
                if (!fromAnimation && !toAnimation) return;
                return {
                  start() {
                    const animationRunners = [];
                    if (fromAnimation) {
                      animationRunners.push(fromAnimation.start());
                    }
                    if (toAnimation) {
                      animationRunners.push(toAnimation.start());
                    }
                    $$AnimateRunner.all(animationRunners, done);
                    const runner = new $$AnimateRunner({
                      end: endFnFactory(),
                      cancel: endFnFactory()
                    });
                    return runner;
                    function endFnFactory() {
                      return function() {
                        animationRunners.forEach((runner2) => {
                          runner2.end();
                        });
                      };
                    }
                    function done(status) {
                      runner.complete(status);
                    }
                  }
                };
              }
              return prepareAnimation(animationDetails);
            };
            function prepareAnimation(animationDetails) {
              const { element, event, options, classes } = animationDetails;
              return $$animateJs(element, event, classes, options);
            }
          }
        ];
      }
      ngAnimateSwapDirective.$inject = ["$animate"];
      function ngAnimateSwapDirective($animate) {
        return {
          restrict: "A",
          transclude: "element",
          terminal: true,
          priority: 550,
          // We use 550 here to ensure that the directive is caught before others,
          // but after `ngIf` (at priority 600).
          link(scope, $element, attrs, ctrl, $transclude) {
            let previousElement;
            let previousScope;
            scope.$watch(attrs["ngAnimateSwap"] || attrs["for"], (value) => {
              if (previousElement) {
                $animate.leave(previousElement);
              }
              if (previousScope) {
                previousScope.$destroy();
                previousScope = null;
              }
              if (value) {
                $transclude((clone, childScope) => {
                  previousElement = clone;
                  previousScope = childScope;
                  $animate.enter(clone, null, $element);
                });
              }
            });
          }
        };
      }
      $$AnimateChildrenDirective.$inject = [$injectTokens.$interpolate];
      function $$AnimateChildrenDirective($interpolate) {
        return {
          link(scope, element, attrs) {
            const val2 = attrs["ngAnimateChildren"];
            if (isString(val2) && val2.length === 0) {
              setCacheData(element, NG_ANIMATE_CHILDREN_DATA, true);
            } else {
              setData($interpolate(val2)(scope));
              attrs.$observe("ngAnimateChildren", setData);
            }
            function setData(value) {
              value = value === "on" || value === "true";
              setCacheData(element, NG_ANIMATE_CHILDREN_DATA, value);
            }
          }
        };
      }
      function curry(fn) {
        return function curried() {
          if (arguments.length >= fn.length) {
            return fn.apply(this, arguments);
          }
          const args = Array.prototype.slice.call(arguments);
          return curried.bind(this, ...args);
        };
      }
      function compose() {
        const args = arguments;
        const start = args.length - 1;
        return function() {
          let i = start, result = args[start].apply(this, arguments);
          while (i--) result = args[i].call(this, result);
          return result;
        };
      }
      function pipe() {
        return compose.apply(null, [].slice.call(arguments).reverse());
      }
      const propEq = curry((name2, _val, obj) => obj && obj[name2] === _val);
      const parse = (name2) => pipe.apply(
        null,
        name2.split(".").map((name3) => (obj) => obj && obj[name3])
      );
      const is = (ctor) => (obj) => obj != null && obj.constructor === ctor || obj instanceof ctor;
      const val = (v) => () => v;
      function pattern(struct) {
        return function(x) {
          for (let i = 0; i < struct.length; i++) {
            if (struct[i][0](x)) return struct[i][1](x);
          }
        };
      }
      function equals(o1, o2) {
        if (o1 === o2) return true;
        if (o1 === null || o2 === null) return false;
        if (o1 !== o1 && o2 !== o2) return true;
        const t1 = typeof o1, t2 = typeof o2;
        if (t1 !== t2 || t1 !== "object") return false;
        const tup = [o1, o2];
        if (tup.every(Array.isArray)) return _arraysEq(o1, o2);
        if (tup.every(isDate)) return o1.getTime() === o2.getTime();
        if (tup.every(isRegExp)) return o1.toString() === o2.toString();
        if (tup.every(isFunction)) return true;
        if ([isFunction, Array.isArray, isDate, isRegExp].some((fn) => !!fn(tup))) {
          return false;
        }
        const keys = {};
        for (const key in o1) {
          if (!equals(o1[key], o2[key])) return false;
          keys[key] = true;
        }
        for (const key in o2) {
          if (!keys[key]) return false;
        }
        return true;
      }
      function createProxyFunctions(source, target, bind2, fnNames, latebind = false) {
        const bindFunction = (fnName) => source()[fnName].bind(bind2());
        const makeLateRebindFn = (fnName) => function lateRebindFunction() {
          target[fnName] = bindFunction(fnName);
          return target[fnName].apply(null, arguments);
        };
        fnNames = fnNames || Object.keys(source());
        return fnNames.reduce((acc, name2) => {
          acc[name2] = latebind ? makeLateRebindFn(name2) : bindFunction(name2);
          return acc;
        }, target);
      }
      function inherit(parent, extra) {
        const newObj = Object.create(parent);
        if (extra) {
          Object.assign(newObj, extra);
        }
        return newObj;
      }
      const removeFrom = curry(_removeFrom);
      function _removeFrom(array, obj) {
        const idx = array.indexOf(obj);
        if (idx >= 0) array.splice(idx, 1);
        return array;
      }
      function defaults(opts, ...defaultsList) {
        const defaultVals = Object.assign({}, ...defaultsList.reverse());
        return Object.assign(defaultVals, pick(opts || {}, Object.keys(defaultVals)));
      }
      function ancestors(first, second) {
        const path = [];
        for (const n in first.path) {
          if (first.path[n] !== second.path[n]) break;
          path.push(first.path[n]);
        }
        return path;
      }
      function pick(obj, propNames) {
        const objCopy = {};
        for (const _prop in obj) {
          if (propNames.indexOf(_prop) !== -1) {
            objCopy[_prop] = obj[_prop];
          }
        }
        return objCopy;
      }
      function omit(obj, propNames) {
        return Object.keys(obj).filter((x) => !propNames.includes(x)).reduce((acc, key) => (acc[key] = obj[key], acc), {});
      }
      function filter(collection, callback) {
        const arr = Array.isArray(collection), result = arr ? [] : {};
        const accept = arr ? (x) => result.push(x) : (x, key) => result[key] = x;
        Object.entries(collection).forEach(([i, item]) => {
          if (callback(item, i)) accept(item, i);
        });
        return result;
      }
      function find(collection, callback) {
        let result;
        Object.entries(collection).forEach(([i, item]) => {
          if (result) return;
          if (callback(item, i)) result = item;
        });
        return result;
      }
      function map(collection, callback, target) {
        target = target || (Array.isArray(collection) ? [] : {});
        Object.entries(collection).forEach(
          ([i, item]) => target[i] = callback(item, i)
        );
        return target;
      }
      const allTrueR = (memo, elem) => memo && elem;
      const anyTrueR = (memo, elem) => memo || elem;
      const unnestR = (memo, elem) => memo.concat(elem);
      function pushR(arr, obj) {
        arr.push(obj);
        return arr;
      }
      const uniqR = (acc, token) => acc.includes(token) ? acc : pushR(acc, token);
      const unnest = (arr) => arr.reduce(unnestR, []);
      const assertPredicate = assertFn;
      function assertFn(predicateOrMap, errMsg = "assert failure") {
        return (obj) => {
          const result = predicateOrMap(obj);
          if (!result) {
            throw new Error(errMsg);
          }
          return result;
        };
      }
      function arrayTuples(...args) {
        if (args.length === 0) return [];
        const maxArrayLen = args.reduce(
          (min, arr) => Math.min(arr.length, min),
          9007199254740991
        );
        const result = [];
        for (let i = 0; i < maxArrayLen; i++) {
          switch (args.length) {
            case 1:
              result.push([args[0][i]]);
              break;
            case 2:
              result.push([args[0][i], args[1][i]]);
              break;
            case 3:
              result.push([args[0][i], args[1][i], args[2][i]]);
              break;
            case 4:
              result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);
              break;
            default:
              result.push(args.map((array) => array[i]));
              break;
          }
        }
        return result;
      }
      function applyPairs(memo, keyValTuple) {
        let key, value;
        if (Array.isArray(keyValTuple)) [key, value] = keyValTuple;
        if (!isString(key)) throw new Error("invalid parameters to applyPairs");
        memo[key] = value;
        return memo;
      }
      function tail(arr) {
        return arr.length > 0 ? arr[arr.length - 1] : void 0;
      }
      function copy(src, dest) {
        if (dest) Object.keys(dest).forEach((key) => delete dest[key]);
        if (!dest) dest = {};
        return Object.assign(dest, src);
      }
      function _arraysEq(a1, a2) {
        if (a1.length !== a2.length) return false;
        return arrayTuples(a1, a2).reduce((b, t) => b && equals(t[0], t[1]), true);
      }
      const silenceUncaughtInPromise = (promise) => promise.catch(() => 0) && promise;
      const silentRejection = (error) => silenceUncaughtInPromise(Promise.reject(error));
      class ParamType {
        /**
         * @param def  A configuration object which contains the custom type definition.  The object's
         *        properties will override the default methods and/or pattern in `ParamType`'s public interface.
         */
        constructor(def) {
          this.pattern = /.*/;
          this.inherit = true;
          Object.assign(this, def);
          this.name = void 0;
        }
        // consider these four methods to be "abstract methods" that should be overridden
        is(val2) {
          return !!val2;
        }
        encode(val2) {
          return val2;
        }
        decode(val2) {
          return val2;
        }
        equals(a, b) {
          return a == b;
        }
        $subPattern() {
          const sub = this.pattern.toString();
          return sub.substring(1, sub.length - 2);
        }
        toString() {
          return `{ParamType:${this.name}}`;
        }
        /** Given an encoded string, or a decoded object, returns a decoded object */
        $normalize(val2) {
          return this.is(val2) ? val2 : this.decode(val2);
        }
        /**
         * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.
         * e.g.:
         * - urlmatcher pattern "/path?{queryParam[]:int}"
         * - url: "/path?queryParam=1&queryParam=2
         * - $stateParams.queryParam will be [1, 2]
         * if `mode` is "auto", then
         * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1
         * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]
         */
        $asArray(mode, isSearch) {
          if (!mode) return this;
          if (mode === "auto" && !isSearch)
            throw new Error("'auto' array mode is for query parameters only");
          return new ArrayType(this, mode);
        }
      }
      function ArrayType(type, mode) {
        function arrayWrap(val2) {
          return Array.isArray(val2) ? val2 : isDefined(val2) ? [val2] : [];
        }
        function arrayUnwrap(val2) {
          switch (val2.length) {
            case 0:
              return void 0;
            case 1:
              return mode === "auto" ? val2[0] : val2;
            default:
              return val2;
          }
        }
        function arrayHandler(callback, allTruthyMode) {
          return function handleArray(val2) {
            if (Array.isArray(val2) && val2.length === 0) return val2;
            const arr = arrayWrap(val2);
            const result = map(arr, callback);
            return allTruthyMode === true ? filter(result, (x) => !x).length === 0 : arrayUnwrap(result);
          };
        }
        function arrayEqualsHandler(callback) {
          return function handleArray(val1, val2) {
            const left = arrayWrap(val1), right = arrayWrap(val2);
            if (left.length !== right.length) return false;
            for (let i = 0; i < left.length; i++) {
              if (!callback(left[i], right[i])) return false;
            }
            return true;
          };
        }
        ["encode", "decode", "equals", "$normalize"].forEach((name2) => {
          const paramTypeFn = type[name2].bind(type);
          const wrapperFn = name2 === "equals" ? arrayEqualsHandler : arrayHandler;
          this[name2] = wrapperFn(paramTypeFn);
        });
        Object.assign(this, {
          dynamic: type.dynamic,
          name: type.name,
          pattern: type.pattern,
          inherit: type.inherit,
          raw: type.raw,
          is: arrayHandler(type.is.bind(type), true),
          $arrayMode: mode
        });
      }
      class ParamTypes {
        constructor() {
          this.enqueue = true;
          this.typeQueue = [];
          this.defaultTypes = pick(ParamTypes.prototype, [
            "hash",
            "string",
            "query",
            "path",
            "int",
            "bool",
            "date",
            "json",
            "any"
          ]);
          const makeType = (definition, name2) => new ParamType(Object.assign({ name: name2 }, definition));
          this.types = inherit(map(this.defaultTypes, makeType), {});
        }
        /**
         * Registers a parameter type
         *
         * End users should call [[UrlMatcherFactory.type]], which delegates to this method.
         */
        type(name2, definition, definitionFn) {
          if (!isDefined(definition)) return this.types[name2];
          if (hasOwn(this.types, name2))
            throw new Error(`A type named '${name2}' has already been defined.`);
          this.types[name2] = new ParamType(Object.assign({ name: name2 }, definition));
          if (definitionFn) {
            this.typeQueue.push({ name: name2, def: definitionFn });
            if (!this.enqueue) this._flushTypeQueue();
          }
          return this;
        }
        _flushTypeQueue() {
          while (this.typeQueue.length) {
            const type = this.typeQueue.shift();
            if (type.pattern)
              throw new Error("You cannot override a type's .pattern at runtime.");
            Object.assign(
              this.types[type.name],
              window["angular"].$injector.invoke(type.def)
            );
          }
        }
      }
      function initDefaultTypes() {
        const makeDefaultType = (def) => {
          const valToString = (val2) => val2 != null ? val2.toString() : val2;
          const defaultTypeBase = {
            encode: valToString,
            decode: valToString,
            is: is(String),
            pattern: /.*/,
            equals: (a, b) => a == b
            // allow coersion for null/undefined/""
          };
          return Object.assign({}, defaultTypeBase, def);
        };
        Object.assign(ParamTypes.prototype, {
          string: makeDefaultType({}),
          path: makeDefaultType({
            pattern: /[^/]*/
          }),
          query: makeDefaultType({}),
          hash: makeDefaultType({
            inherit: false
          }),
          int: makeDefaultType({
            decode: (val2) => parseInt(val2, 10),
            is: function(val2) {
              return !isNullOrUndefined(val2) && this.decode(val2.toString()) === val2;
            },
            pattern: /-?\d+/
          }),
          bool: makeDefaultType({
            encode: (val2) => val2 && 1 || 0,
            decode: (val2) => parseInt(val2, 10) !== 0,
            is: is(Boolean),
            pattern: /[01]/
          }),
          date: makeDefaultType({
            encode: function(val2) {
              return !this.is(val2) ? void 0 : [
                val2.getFullYear(),
                ("0" + (val2.getMonth() + 1)).slice(-2),
                ("0" + val2.getDate()).slice(-2)
              ].join("-");
            },
            decode: function(val2) {
              if (this.is(val2)) return val2;
              const match = this.capture.exec(val2);
              return match ? new Date(match[1], match[2] - 1, match[3]) : void 0;
            },
            is: (val2) => val2 instanceof Date && !isNaN(val2.valueOf()),
            equals(l, r) {
              return ["getFullYear", "getMonth", "getDate"].reduce(
                (acc, fn) => acc && l[fn]() === r[fn](),
                true
              );
            },
            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
          }),
          json: makeDefaultType({
            encode: JSON.stringify,
            decode: JSON.parse,
            is: is(Object),
            equals,
            pattern: /[^/]*/
          }),
          // does not encode/decode
          any: makeDefaultType({
            encode: (x) => x,
            decode: (x) => x,
            is: () => true,
            equals
          })
        });
      }
      initDefaultTypes();
      class UrlConfigProvider {
        constructor() {
          this.paramTypes = new ParamTypes();
          this._isCaseInsensitive = false;
          this._isStrictMode = true;
          this._defaultSquashPolicy = false;
          const pathType = this.type("path");
          pathType.encode = (x) => x != null ? x.toString().replace(/([~/])/g, (m) => ({ "~": "~~", "/": "~2F" })[m]) : x;
          pathType.decode = (x) => x != null ? x.toString().replace(/(~~|~2F)/g, (m) => ({ "~~": "~", "~2F": "/" })[m]) : x;
          this.paramTypes.enqueue = false;
          this.paramTypes._flushTypeQueue();
        }
        $get = [
          function() {
            return this;
          }
        ];
        /**
         * Defines whether URL matching should be case sensitive (the default behavior), or not.
         *
         * #### Example:
         * ```js
         * // Allow case insensitive url matches
         * urlService.config.caseInsensitive(true);
         * ```
         *
         * @param value `false` to match URL in a case sensitive manner; otherwise `true`;
         * @returns the current value of caseInsensitive
         */
        caseInsensitive(value) {
          return this._isCaseInsensitive = isDefined(value) ? value : this._isCaseInsensitive;
        }
        /**
         * Sets the default behavior when generating or matching URLs with default parameter values.
         *
         * #### Example:
         * ```js
         * // Remove default parameter values from the url
         * urlService.config.defaultSquashPolicy(true);
         * ```
         *
         * @param value A string that defines the default parameter URL squashing behavior.
         *    - `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL
         *    - `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the
         *      parameter is surrounded by slashes, squash (remove) one slash from the URL
         *    - any other string, e.g. "~": When generating an href with a default parameter value, squash (remove)
         *      the parameter value from the URL and replace it with this string.
         * @returns the current value of defaultSquashPolicy
         */
        defaultSquashPolicy(value) {
          if (isDefined(value) && value !== true && value !== false && !isString(value))
            throw new Error(
              `Invalid squash policy: ${value}. Valid policies: false, true, arbitrary-string`
            );
          return this._defaultSquashPolicy = isDefined(value) ? value : this._defaultSquashPolicy;
        }
        /**
         * Defines whether URLs should match trailing slashes, or not (the default behavior).
         *
         * #### Example:
         * ```js
         * // Allow optional trailing slashes
         * urlService.config.strictMode(false);
         * ```
         *
         * @param value `false` to match trailing slashes in URLs, otherwise `true`.
         * @returns the current value of strictMode
         */
        strictMode(value) {
          return this._isStrictMode = isDefined(value) ? value : this._isStrictMode;
        }
        /**
         * Creates and registers a custom [[ParamType]] object
         *
         * A custom parameter type can be used to generate URLs with typed parameters or custom encoding/decoding.
         *
         * #### Note: Register custom types *before using them* in a state definition.
         *
         * #### Example:
         * ```js
         * // Encode object parameter as JSON string
         * urlService.config.type('myjson', {
         *   encode: (obj) => JSON.stringify(obj),
         *   decode: (str) => JSON.parse(str),
         *   is: (val) => typeof(val) === 'object',
         *   pattern: /[^/]+/,
         *   equals: (a, b) => _.isEqual(a, b),
         * });
         * ```
         *
         * See [[ParamTypeDefinition]] for more examples
         *
         * @param name The type name.
         * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.
         * @param definitionFn A function that is injected before the app runtime starts.
         *        The result of this function should be a [[ParamTypeDefinition]].
         *        The result is merged into the existing `definition`.
         *        See [[ParamType]] for information on the values accepted.
         *
         * @returns if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined
         */
        type(name2, definition, definitionFn) {
          const type = this.paramTypes.type(name2, definition, definitionFn);
          return !isDefined(definition) ? type : this;
        }
      }
      class StateParams {
        constructor(params = {}) {
          Object.assign(this, params);
        }
        /**
         * Merges a set of parameters with all parameters inherited between the common parents of the
         * current state and a given destination state.
         *
         * @param {Object} newParams The set of parameters which will be composited with inherited params.
         * @param {Object} $current Internal definition of object representing the current state.
         * @param {Object} $to Internal definition of object representing state to transition to.
         */
        $inherit(newParams, $current, $to) {
          const parents = ancestors($current, $to), inherited = {}, inheritList = [];
          for (const i in parents) {
            if (!parents[i] || !parents[i].params) continue;
            const parentParams = parents[i].params;
            const parentParamsKeys = Object.keys(parentParams);
            if (!parentParamsKeys.length) continue;
            for (const j in parentParamsKeys) {
              if (parentParams[parentParamsKeys[j]].inherit == false || inheritList.indexOf(parentParamsKeys[j]) >= 0)
                continue;
              inheritList.push(parentParamsKeys[j]);
              inherited[parentParamsKeys[j]] = this[parentParamsKeys[j]];
            }
          }
          return Object.assign({}, inherited, newParams);
        }
      }
      class Queue {
        /**
         * @param {T[]} [items=[]] - Initial queue items.
         * @param {number|null} [limit=null] - Maximum allowed items before eviction (null = unlimited).
         */
        constructor(items = [], limit = null) {
          this._items = Array.isArray(items) ? [...items] : [];
          this._limit = Number.isInteger(limit) && limit > 0 ? limit : null;
          this._evictListeners = [];
        }
        /**
         * Register a listener that will be called with the evicted item.
         * @param {(item: T) => void} listener
         */
        onEvict(listener) {
          this._evictListeners.push(listener);
        }
        /**
         * Adds an item to the end of the queue, evicting the head if over limit.
         * @param {T} item
         * @returns {T}
         */
        enqueue(item) {
          this._items.push(item);
          if (this._limit !== null && this._items.length > this._limit) {
            this.evict();
          }
          return item;
        }
        /**
         * Removes the head item and notifies eviction listeners.
         * @returns {T|undefined}
         */
        evict() {
          const item = this._items.shift();
          if (item !== void 0) {
            this._evictListeners.forEach((fn) => fn(item));
          }
          return item;
        }
        /**
         * Removes and returns the first item in the queue.
         * @returns {T|undefined}
         */
        dequeue() {
          return this._items.length > 0 ? this._items.shift() : void 0;
        }
        /**
         * Clears all items from the queue.
         * @returns {T[]} The previously stored items.
         */
        clear() {
          const cleared = [...this._items];
          this._items.length = 0;
          return cleared;
        }
        /**
         * Returns the current number of items.
         * @returns {number}
         */
        size() {
          return this._items.length;
        }
        /**
         * Removes a specific item from the queue.
         * @param {T} item
         * @returns {T|false} The removed item, or false if not found.
         */
        remove(item) {
          const index = this._items.indexOf(item);
          return index !== -1 ? this._items.splice(index, 1)[0] : false;
        }
        /**
         * Returns the item at the tail (last).
         * @returns {T|undefined}
         */
        peekTail() {
          return this._items[this._items.length - 1];
        }
        /**
         * Returns the item at the head (first).
         * @returns {T|undefined}
         */
        peekHead() {
          return this._items[0];
        }
      }
      class Router {
        constructor() {
          this.params = new StateParams();
          this.lastStartedTransitionId = -1;
          this.transitionHistory = new Queue([], 1);
          this.successfulTransitions = new Queue([], 1);
          this.current = void 0;
          this.$current = void 0;
          this.transition = void 0;
        }
        $get = () => this;
      }
      function isInjectable(val2) {
        if (Array.isArray(val2) && val2.length) {
          const head = val2.slice(0, -1), tail2 = val2.slice(-1);
          return !(head.filter((x) => !isString(x)).length || tail2.filter((x) => !isFunction(x)).length);
        }
        return isFunction(val2);
      }
      function isPromise(obj) {
        return obj !== null && typeof obj === "object" && typeof obj.then === "function";
      }
      function maxLength(max, str) {
        if (str.length <= max) return str;
        return str.substring(0, max - 3) + "...";
      }
      function padString(length, str) {
        while (str.length < length) str += " ";
        return str;
      }
      function kebobString(camelCase) {
        return camelCase.replace(/^([A-Z])/, ($1) => $1.toLowerCase()).replace(/([A-Z])/g, ($1) => "-" + $1.toLowerCase());
      }
      function functionToString(fn) {
        const fnStr = fnToString(fn);
        const namedFunctionMatch = fnStr.match(/^(function [^ ]+\([^)]*\))/);
        const toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;
        const fnName = fn["name"] || "";
        if (fnName && toStr.match(/function \(/)) {
          return "function " + fnName + toStr.substring(9);
        }
        return toStr;
      }
      function fnToString(fn) {
        const _fn = Array.isArray(fn) ? fn.slice(-1)[0] : fn;
        return _fn && _fn.toString() || "undefined";
      }
      function stringify(o) {
        const seen = [];
        const isRejection = (obj) => {
          return obj && typeof obj.then === "function" && obj.constructor.name == "Rejection";
        };
        const hasToString = (obj) => isObject(obj) && !Array.isArray(obj) && obj.constructor !== Object && isFunction(obj.toString);
        const stringifyPattern = pattern([
          [isUndefined, val("undefined")],
          [isNull, val("null")],
          [isPromise, val("[Promise]")],
          [isRejection, (x) => x._transitionRejection.toString()],
          [hasToString, (x) => x.toString()],
          [isInjectable, functionToString],
          [val(true), (x) => x]
        ]);
        function format(value) {
          if (isObject(value)) {
            if (seen.indexOf(value) !== -1) return "[circular ref]";
            seen.push(value);
          }
          return stringifyPattern(value);
        }
        if (isUndefined(o)) {
          return format(o);
        }
        return JSON.stringify(o, (key, value) => format(value)).replace(/\\"/g, '"');
      }
      const stripLastPathElement = (str) => str.replace(/\/[^/]*$/, "");
      function splitOnDelim(delim) {
        const re = new RegExp("(" + delim + ")", "g");
        return (str) => str.split(re).filter(Boolean);
      }
      function joinNeighborsR(acc, x) {
        if (isString(tail(acc)) && isString(x))
          return acc.slice(0, -1).concat(tail(acc) + x);
        return pushR(acc, x);
      }
      function ngViewString(ngView2) {
        if (!ngView2) return "ng-view (defunct)";
        const state = ngView2.creationContext ? ngView2.creationContext.name || "(root)" : "(none)";
        return `[ng-view#${ngView2.id}:${ngView2.fqn} (${ngView2.name}@${state})]`;
      }
      const viewConfigString = (viewConfig) => {
        const view = viewConfig.viewDecl;
        const state = view.$context.name || "(root)";
        return `[View#${viewConfig.$id} from '${state}' state]: target ng-view: '${view.$ngViewName}@${view.$ngViewContextAnchor}'`;
      };
      function normalizedCat(input) {
        return isNumber(input) ? Category[input] : Category[Category[input]];
      }
      const Category = {
        RESOLVE: 0,
        TRANSITION: 1,
        HOOK: 2,
        UIVIEW: 3,
        VIEWCONFIG: 4
      };
      const _tid = parse("$id");
      const _rid = parse("router.$id");
      const transLbl = (trans) => `Transition #${_tid(trans)}-${_rid(trans)}`;
      class Trace {
        constructor() {
          this._enabled = {};
          this.approximateDigests = 0;
        }
        _set(enabled, categories) {
          if (!categories.length) {
            categories = Object.keys(Category).map((k) => parseInt(k, 10)).filter((k) => !isNaN(k)).map((key) => Category[key]);
          }
          categories.map(normalizedCat).forEach((category) => this._enabled[category] = enabled);
        }
        enable(...categories) {
          this._set(true, categories);
        }
        disable(...categories) {
          this._set(false, categories);
        }
        /**
         * Retrieves the enabled stateus of a [[Category]]
         *
         * ```js
         * trace.enabled("VIEWCONFIG"); // true or false
         * ```
         *
         * @returns boolean true if the category is enabled
         */
        enabled(category) {
          return !!this._enabled[normalizedCat(category)];
        }
        /** @internal called by ng-router code */
        traceTransitionStart(trans) {
          if (!this.enabled(Category.TRANSITION)) return;
          console.log(`${transLbl(trans)}: Started  -> ${stringify(trans)}`);
        }
        /** @internal called by ng-router code */
        traceTransitionIgnored(trans) {
          if (!this.enabled(Category.TRANSITION)) return;
          console.log(`${transLbl(trans)}: Ignored  <> ${stringify(trans)}`);
        }
        /** @internal called by ng-router code */
        traceHookInvocation(step, trans, options) {
          if (!this.enabled(Category.HOOK)) return;
          const event = parse("traceData.hookType")(options) || "internal", context = parse("traceData.context.state.name")(options) || parse("traceData.context")(options) || "unknown", name2 = functionToString(step.registeredHook.callback);
          console.log(
            `${transLbl(trans)}:   Hook -> ${event} context: ${context}, ${maxLength(200, name2)}`
          );
        }
        /** @internal called by ng-router code */
        traceHookResult(hookResult, trans) {
          if (!this.enabled(Category.HOOK)) return;
          console.log(
            `${transLbl(trans)}:   <- Hook returned: ${maxLength(200, stringify(hookResult))}`
          );
        }
        /** @internal called by ng-router code */
        traceResolvePath(path, when, trans) {
          if (!this.enabled(Category.RESOLVE)) return;
          console.log(`${transLbl(trans)}:         Resolving ${path} (${when})`);
        }
        /** @internal called by ng-router code */
        traceResolvableResolved(resolvable, trans) {
          if (!this.enabled(Category.RESOLVE)) return;
          console.log(
            `${transLbl(trans)}:               <- Resolved  ${resolvable} to: ${maxLength(200, stringify(resolvable.data))}`
          );
        }
        /** @internal called by ng-router code */
        traceError(reason, trans) {
          if (!this.enabled(Category.TRANSITION)) return;
          console.log(
            `${transLbl(trans)}: <- Rejected ${stringify(trans)}, reason: ${reason}`
          );
        }
        /** @internal called by ng-router code */
        traceSuccess(finalState, trans) {
          if (!this.enabled(Category.TRANSITION)) return;
          console.log(
            `${transLbl(trans)}: <- Success  ${stringify(trans)}, final state: ${finalState.name}`
          );
        }
        /** @internal called by ng-router code */
        traceUIViewEvent(event, viewData, extra = "") {
          if (!this.enabled(Category.UIVIEW)) return;
          console.log(
            `ng-view: ${padString(30, event)} ${ngViewString(viewData)}${extra}`
          );
        }
        /** @internal called by ng-router code */
        traceUIViewConfigUpdated(viewData, context) {
          if (!this.enabled(Category.UIVIEW)) return;
          this.traceUIViewEvent(
            "Updating",
            viewData,
            ` with ViewConfig from context='${context}'`
          );
        }
        /** @internal called by ng-router code */
        traceUIViewFill(viewData, html) {
          if (!this.enabled(Category.UIVIEW)) return;
          this.traceUIViewEvent("Fill", viewData, ` with: ${maxLength(200, html)}`);
        }
        /** @internal called by ng-router code */
        traceViewSync(pairs) {
          if (!this.enabled(Category.VIEWCONFIG)) return;
          const uivheader = "uiview component fqn";
          const cfgheader = "view config state (view name)";
          const mapping = pairs.map(({ ngView: ngView2, viewConfig }) => {
            const uiv = ngView2 && ngView2.fqn;
            const cfg = viewConfig && `${viewConfig.viewDecl.$context.name}: (${viewConfig.viewDecl.$name})`;
            return { [uivheader]: uiv, [cfgheader]: cfg };
          }).sort((a, b) => (a[uivheader] || "").localeCompare(b[uivheader] || ""));
          console.table(mapping);
        }
        /** @internal called by ng-router code */
        traceViewServiceEvent(event, viewConfig) {
          if (!this.enabled(Category.VIEWCONFIG)) return;
          console.log(`VIEWCONFIG: ${event} ${viewConfigString(viewConfig)}`);
        }
        /** @internal called by ng-router code */
        traceViewServiceUIViewEvent(event, viewData) {
          if (!this.enabled(Category.VIEWCONFIG)) return;
          console.log(`VIEWCONFIG: ${event} ${ngViewString(viewData)}`);
        }
      }
      const trace = new Trace();
      let defaultResolvePolicy = {
        when: "LAZY",
        async: "WAIT"
      };
      class Resolvable {
        constructor(arg1, resolveFn, deps, policy, data) {
          this.resolved = false;
          this.promise = void 0;
          if (arg1 instanceof Resolvable) {
            Object.assign(this, arg1);
          } else if (isFunction(resolveFn)) {
            assert(!isNullOrUndefined(arg1), "token argument is required");
            this.token = arg1;
            this.policy = policy;
            this.resolveFn = resolveFn;
            this.deps = deps || [];
            this.data = data;
            this.resolved = data !== void 0;
            this.promise = this.resolved ? Promise.resolve(this.data) : void 0;
          } else if (isObject(arg1) && arg1.token && (hasOwn(arg1, "resolveFn") || hasOwn(arg1, "data"))) {
            this.token = arg1.token;
            this.resolveFn = arg1.resolveFn;
            this.deps = arg1.deps;
            this.policy = arg1.policy;
            this.data = arg1.data;
          }
        }
        getPolicy(state) {
          const thisPolicy = this.policy || {};
          const statePolicy = state && state.resolvePolicy || {};
          return {
            when: thisPolicy.when || statePolicy.when || defaultResolvePolicy.when,
            async: thisPolicy.async || statePolicy.async || defaultResolvePolicy.async
          };
        }
        /**
         * Asynchronously resolve this Resolvable's data
         *
         * Given a ResolveContext that this Resolvable is found in:
         * Wait for this Resolvable's dependencies, then invoke this Resolvable's function
         * and update the Resolvable's state
         */
        resolve(resolveContext, trans) {
          const getResolvableDependencies = () => Promise.all(
            resolveContext.getDependencies(this).map((resolvable) => resolvable.get(resolveContext, trans))
          );
          const invokeResolveFn = (resolvedDeps) => this.resolveFn.apply(null, resolvedDeps);
          const node = resolveContext.findNode(this);
          const state = node && node.state;
          const asyncPolicy = this.getPolicy(state).async;
          const customAsyncPolicy = isFunction(asyncPolicy) ? asyncPolicy : (x) => x;
          const applyResolvedValue = (resolvedValue) => {
            this.data = resolvedValue;
            this.resolved = true;
            this.resolveFn = null;
            trace.traceResolvableResolved(this, trans);
            return this.data;
          };
          this.promise = Promise.resolve().then(getResolvableDependencies).then(invokeResolveFn).then(customAsyncPolicy).then(applyResolvedValue);
          return this.promise;
        }
        /**
         * Gets a promise for this Resolvable's data.
         *
         * Fetches the data and returns a promise.
         * Returns the existing promise if it has already been fetched once.
         */
        get(resolveContext, trans) {
          return this.promise || this.resolve(resolveContext, trans);
        }
        toString() {
          return `Resolvable(token: ${stringify(this.token)}, requires: [${this.deps.map(stringify)}])`;
        }
        clone() {
          return new Resolvable(this);
        }
      }
      Resolvable.fromData = (token, data) => new Resolvable(token, () => data, null, null, data);
      class TargetState {
        /**
         * The TargetState constructor
         *
         * Note: Do not construct a `TargetState` manually.
         * To create a `TargetState`, use the [[StateService.target]] factory method.
         *
         * @param _stateRegistry The StateRegistry to use to look up the _definition
         * @param _identifier An identifier for a state.
         *    Either a fully-qualified state name, or the object used to define the state.
         * @param _params Parameters for the target state
         * @param _options Transition options.
         *
         * @internal
         */
        constructor(_stateRegistry, _identifier, _params, _options) {
          this._stateRegistry = _stateRegistry;
          this._identifier = _identifier;
          this._identifier = _identifier;
          this._params = Object.assign({}, _params || {});
          this._options = Object.assign({}, _options || {});
          this._definition = _stateRegistry.matcher.find(
            _identifier,
            this._options.relative
          );
        }
        /** The name of the state this object targets */
        name() {
          return this._definition && this._definition.name || this._identifier;
        }
        /** The identifier used when creating this TargetState */
        identifier() {
          return this._identifier;
        }
        /** The target parameter values */
        params() {
          return this._params;
        }
        /** The internal state object (if it was found) */
        $state() {
          return this._definition;
        }
        /** The internal state declaration (if it was found) */
        state() {
          return this._definition && this._definition.self;
        }
        /** The target options */
        options() {
          return this._options;
        }
        /** True if the target state was found */
        exists() {
          return !!(this._definition && this._definition.self);
        }
        /** True if the object is valid */
        valid() {
          return !this.error();
        }
        /** If the object is invalid, returns the reason why */
        error() {
          const base = this.options().relative;
          if (!this._definition && !!base) {
            const stateName = base.name ? base.name : base;
            return `Could not resolve '${this.name()}' from state '${stateName}'`;
          }
          if (!this._definition) return `No such state '${this.name()}'`;
          if (!this._definition.self)
            return `State '${this.name()}' has an invalid definition`;
        }
        toString() {
          return `'${this.name()}'${stringify(this.params())}`;
        }
        /**
         * Returns a copy of this TargetState which targets a different state.
         * The new TargetState has the same parameter values and transition options.
         *
         * @param state The new state that should be targeted
         */
        withState(state) {
          return new TargetState(
            this._stateRegistry,
            state,
            this._params,
            this._options
          );
        }
        /**
         * Returns a copy of this TargetState, using the specified parameter values.
         *
         * @param params the new parameter values to use
         * @param replace When false (default) the new parameter values will be merged with the current values.
         *                When true the parameter values will be used instead of the current values.
         */
        withParams(params, replace = false) {
          const newParams = replace ? params : Object.assign({}, this._params, params);
          return new TargetState(
            this._stateRegistry,
            this._identifier,
            newParams,
            this._options
          );
        }
        /**
         * Returns a copy of this TargetState, using the specified Transition Options.
         *
         * @param options the new options to use
         * @param replace When false (default) the new options will be merged with the current options.
         *                When true the options will be used instead of the current options.
         */
        withOptions(options, replace = false) {
          const newOpts = replace ? options : Object.assign({}, this._options, options);
          return new TargetState(
            this._stateRegistry,
            this._identifier,
            this._params,
            newOpts
          );
        }
      }
      TargetState.isDef = (obj) => {
        return obj && obj.state && (isString(obj.state) || isObject(obj.state) && isString(obj.state.name));
      };
      const isShorthand = (cfg) => ["value", "type", "squash", "array", "dynamic"].filter(
        Object.prototype.hasOwnProperty.bind(cfg || {})
      ).length === 0;
      const DefType = {
        PATH: 0,
        SEARCH: 1,
        CONFIG: 2
      };
      function getParamDeclaration(paramName, location, state) {
        const noReloadOnSearch = state.reloadOnSearch === false && location === DefType.SEARCH || void 0;
        const dynamic = find([state.dynamic, noReloadOnSearch], isDefined);
        const defaultConfig2 = isDefined(dynamic) ? { dynamic } : {};
        const paramConfig = unwrapShorthand(
          state && state.params && state.params[paramName]
        );
        return Object.assign(defaultConfig2, paramConfig);
      }
      function unwrapShorthand(cfg) {
        cfg = isShorthand(cfg) ? { value: cfg } : cfg;
        getStaticDefaultValue["__cacheable"] = true;
        function getStaticDefaultValue() {
          return cfg.value;
        }
        const $$fn = isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue;
        return Object.assign(cfg, { $$fn });
      }
      function getType(cfg, urlType, location, id2, paramTypes) {
        if (cfg.type && urlType && urlType.name !== "string")
          throw new Error(`Param '${id2}' has two type configurations.`);
        if (cfg.type && urlType && urlType.name === "string" && paramTypes.type(cfg.type))
          return paramTypes.type(cfg.type);
        if (urlType) return urlType;
        if (!cfg.type) {
          const type = location === DefType.CONFIG ? "any" : location === DefType.PATH ? "path" : location === DefType.SEARCH ? "query" : "string";
          return paramTypes.type(type);
        }
        return cfg.type instanceof ParamType ? cfg.type : paramTypes.type(cfg.type);
      }
      function getSquashPolicy(config, isOptional, defaultPolicy) {
        const squash = config.squash;
        if (!isOptional || squash === false) return false;
        if (!isDefined(squash) || squash == null) return defaultPolicy;
        if (squash === true || isString(squash)) return squash;
        throw new Error(
          `Invalid squash policy: '${squash}'. Valid policies: false, true, or arbitrary string`
        );
      }
      function getReplace(config, arrayMode, isOptional, squash) {
        const defaultPolicy = [
          { from: "", to: isOptional || arrayMode ? void 0 : "" },
          { from: null, to: isOptional || arrayMode ? void 0 : "" }
        ];
        const replace = Array.isArray(config.replace) ? config.replace : [];
        if (isString(squash)) replace.push({ from: squash, to: void 0 });
        const configuredKeys = map(replace, (x) => x.from);
        return filter(
          defaultPolicy,
          (item) => configuredKeys.indexOf(item.from) === -1
        ).concat(replace);
      }
      class Param {
        /**
         *
         * @param {*} id
         * @param {*} type
         * @param {DefType} location
         * @param {import("../url/url-config.js").UrlConfigProvider} urlConfig
         * @param {*} state
         */
        constructor(id2, type, location, urlConfig, state) {
          const config = getParamDeclaration(id2, location, state);
          type = getType(config, type, location, id2, urlConfig.paramTypes);
          const arrayMode = getArrayMode();
          type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;
          const isOptional = config.value !== void 0 || location === DefType.SEARCH;
          const dynamic = isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;
          const raw = isDefined(config.raw) ? !!config.raw : !!type.raw;
          const squash = getSquashPolicy(
            config,
            isOptional,
            urlConfig.defaultSquashPolicy()
          );
          const replace = getReplace(config, arrayMode, isOptional, squash);
          const inherit2 = isDefined(config.inherit) ? !!config.inherit : !!type.inherit;
          function getArrayMode() {
            const arrayDefaults = {
              array: location === DefType.SEARCH ? "auto" : false
            };
            const arrayParamNomenclature = id2.match(/\[\]$/) ? { array: true } : {};
            return Object.assign(arrayDefaults, arrayParamNomenclature, config).array;
          }
          this.isOptional = isOptional;
          this.type = type;
          this.location = location;
          this.id = id2;
          this.dynamic = dynamic;
          this.raw = raw;
          this.squash = squash;
          this.replace = replace;
          this.inherit = inherit2;
          this.array = arrayMode;
          this.config = config;
        }
        isDefaultValue(value) {
          return this.isOptional && this.type.equals(this.value(), value);
        }
        /**
         * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the
         * default value, which may be the result of an injectable function.
         */
        value(value) {
          const getDefaultValue = () => {
            if (this._defaultValueCache) return this._defaultValueCache.defaultValue;
            if (!window["angular"].$injector)
              throw new Error(
                "Injectable functions cannot be called at configuration time"
              );
            const defaultValue = window["angular"].$injector.invoke(this.config.$$fn);
            if (defaultValue !== null && defaultValue !== void 0 && !this.type.is(defaultValue))
              throw new Error(
                `Default value (${defaultValue}) for parameter '${this.id}' is not an instance of ParamType (${this.type.name})`
              );
            if (this.config.$$fn["__cacheable"]) {
              this._defaultValueCache = { defaultValue };
            }
            return defaultValue;
          };
          const replaceSpecialValues = (val2) => {
            for (const tuple of this.replace) {
              if (tuple.from === val2) return tuple.to;
            }
            return val2;
          };
          value = replaceSpecialValues(value);
          return isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);
        }
        isSearch() {
          return this.location === DefType.SEARCH;
        }
        validates(value) {
          if ((isUndefined(value) || value === null) && this.isOptional) return true;
          const normalized = this.type.$normalize(value);
          if (!this.type.is(normalized)) return false;
          const encoded = normalized;
          return !(isString(encoded) && !this.type.pattern.exec(encoded));
        }
        toString() {
          return `{Param:${this.id} ${this.type} squash: '${this.squash}' optional: ${this.isOptional}}`;
        }
        static values(params, values = {}) {
          const paramValues = {};
          for (const param of params) {
            paramValues[param.id] = param.value(values[param.id]);
          }
          return paramValues;
        }
        /**
         * Finds [[Param]] objects which have different param values
         *
         * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects
         *
         * @param params: The list of Param objects to filter
         * @param values1: The first set of parameter values
         * @param values2: the second set of parameter values
         *
         * @returns any Param objects whose values were different between values1 and values2
         */
        static changed(params, values1 = {}, values2 = {}) {
          return params.filter(
            (param) => !param.type.equals(values1[param.id], values2[param.id])
          );
        }
        /**
         * Checks if two param value objects are equal (for a set of [[Param]] objects)
         *
         * @param params The list of [[Param]] objects to check
         * @param values1 The first set of param values
         * @param values2 The second set of param values
         *
         * @returns true if the param values in values1 and values2 are equal
         */
        static equals(params, values1 = {}, values2 = {}) {
          return Param.changed(params, values1, values2).length === 0;
        }
        /** Returns true if a the parameter values are valid, according to the Param definitions */
        static validates(params, values = {}) {
          return params.map((param) => param.validates(values[param.id])).reduce(allTrueR, true);
        }
      }
      class PathNode {
        constructor(stateOrNode) {
          if (stateOrNode instanceof PathNode) {
            const node = stateOrNode;
            this.state = node.state;
            this.paramSchema = node.paramSchema.slice();
            this.paramValues = Object.assign({}, node.paramValues);
            this.resolvables = node.resolvables.slice();
            this.views = node.views && node.views.slice();
          } else {
            const state = stateOrNode;
            this.state = state;
            this.paramSchema = state.parameters({ inherit: false });
            this.paramValues = {};
            this.resolvables = state.resolvables.map((res) => res.clone());
          }
        }
        clone() {
          return new PathNode(this);
        }
        /** Sets [[paramValues]] for the node, from the values of an object hash */
        applyRawParams(params) {
          const getParamVal = (paramDef) => [
            paramDef.id,
            paramDef.value(params[paramDef.id])
          ];
          this.paramValues = this.paramSchema.reduce(
            (memo, pDef) => applyPairs(memo, getParamVal(pDef)),
            {}
          );
          return this;
        }
        /** Gets a specific [[Param]] metadata that belongs to the node */
        parameter(name2) {
          return find(this.paramSchema, propEq("id", name2));
        }
        /**
         * @returns true if the state and parameter values for another PathNode are
         * equal to the state and param values for this PathNode
         */
        equals(node, paramsFn) {
          const diff = this.diff(node, paramsFn);
          return diff && diff.length === 0;
        }
        /**
         * Finds Params with different parameter values on another PathNode.
         *
         * Given another node (of the same state), finds the parameter values which differ.
         * Returns the [[Param]] (schema objects) whose parameter values differ.
         *
         * Given another node for a different state, returns `false`
         *
         * @param node The node to compare to
         * @param paramsFn A function that returns which parameters should be compared.
         * @returns The [[Param]]s which differ, or null if the two nodes are for different states
         */
        diff(node, paramsFn) {
          if (this.state !== node.state) return false;
          const params = paramsFn ? paramsFn(this) : this.paramSchema;
          return Param.changed(params, this.paramValues, node.paramValues);
        }
      }
      class PathUtils {
        static buildPath(targetState) {
          const toParams = targetState.params();
          return targetState.$state().path.map((state) => new PathNode(state).applyRawParams(toParams));
        }
        /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */
        static buildToPath(fromPath, targetState) {
          const toPath = PathUtils.buildPath(targetState);
          if (targetState.options().inherit) {
            return PathUtils.inheritParams(
              fromPath,
              toPath,
              Object.keys(targetState.params())
            );
          }
          return toPath;
        }
        /**
         * Creates ViewConfig objects and adds to nodes.
         *
         * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state
         */
        static applyViewConfigs($view, path, states) {
          path.filter((node) => states.includes(node.state)).forEach((node) => {
            const viewDecls = Object.values(node.state.views || {});
            const subPath = PathUtils.subPath(path, (n) => n === node);
            const viewConfigs = viewDecls.map((view) => {
              return $view.createViewConfig(subPath, view);
            });
            node.views = viewConfigs.reduce(unnestR, []);
          });
        }
        /**
         * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath
         *
         * For a parameter in a node to be inherited from the from path:
         * - The toPath's node must have a matching node in the fromPath (by state).
         * - The parameter name must not be found in the toKeys parameter array.
         *
         * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some
         * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,
         * it is not inherited from the fromPath.
         */
        static inheritParams(fromPath, toPath, toKeys = []) {
          function nodeParamVals(path, state) {
            const node = find(path, propEq("state", state));
            return Object.assign({}, node && node.paramValues);
          }
          const noInherit = fromPath.map((node) => node.paramSchema).reduce(unnestR, []).filter((param) => !param.inherit).map((x) => x.id);
          function makeInheritedParamsNode(toNode) {
            let toParamVals = Object.assign({}, toNode && toNode.paramValues);
            const incomingParamVals = pick(toParamVals, toKeys);
            toParamVals = omit(toParamVals, toKeys);
            const fromParamVals = omit(
              nodeParamVals(fromPath, toNode.state) || {},
              noInherit
            );
            const ownParamVals = Object.assign(
              toParamVals,
              fromParamVals,
              incomingParamVals
            );
            return new PathNode(toNode.state).applyRawParams(ownParamVals);
          }
          return toPath.map(makeInheritedParamsNode);
        }
        /**
         * Computes the tree changes (entering, exiting) between a fromPath and toPath.
         * @param {PathNode[]} fromPath
         * @param {PathNode[]} toPath
         * @param {boolean} [reloadState]
         * @returns {import("../transition/interface.js").TreeChanges}
         */
        static treeChanges(fromPath, toPath, reloadState) {
          const max = Math.min(fromPath.length, toPath.length);
          let keep = 0;
          const nodesMatch = (node1, node2) => node1.equals(node2, PathUtils.nonDynamicParams);
          while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {
            keep++;
          }
          function applyToParams(retainedNode, idx) {
            const cloned = retainedNode.clone();
            cloned.paramValues = toPath[idx].paramValues;
            return cloned;
          }
          let from, retained, exiting, entering, to;
          from = fromPath;
          retained = from.slice(0, keep);
          exiting = from.slice(keep);
          const retainedWithToParams = retained.map(applyToParams);
          entering = toPath.slice(keep);
          to = retainedWithToParams.concat(entering);
          return { from, to, retained, retainedWithToParams, exiting, entering };
        }
        /**
         * Returns a new path which is: the subpath of the first path which matches the second path.
         *
         * The new path starts from root and contains any nodes that match the nodes in the second path.
         * It stops before the first non-matching node.
         *
         * Nodes are compared using their state property and their parameter values.
         * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.
         *
         * @param pathA the first path
         * @param pathB the second path
         * @param paramsFn a function which returns the parameters to consider when comparing
         *
         * @returns an array of PathNodes from the first path which match the nodes in the second path
         */
        static matching(pathA, pathB, paramsFn) {
          let done = false;
          const tuples = arrayTuples(pathA, pathB);
          return tuples.reduce((matching, [nodeA, nodeB]) => {
            done = done || !nodeA.equals(nodeB, paramsFn);
            return done ? matching : matching.concat(nodeA);
          }, []);
        }
        /**
         * Returns true if two paths are identical.
         *
         * @param pathA
         * @param pathB
         * @param paramsFn a function which returns the parameters to consider when comparing
         * @returns true if the the states and parameter values for both paths are identical
         */
        static equals(pathA, pathB, paramsFn) {
          return pathA.length === pathB.length && PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;
        }
        /**
         * Return a subpath of a path, which stops at the first matching node
         *
         * Given an array of nodes, returns a subset of the array starting from the first node,
         * stopping when the first node matches the predicate.
         *
         * @param path a path of [[PathNode]]s
         * @param predicate a [[Predicate]] fn that matches [[PathNode]]s
         * @returns a subpath up to the matching node, or undefined if no match is found
         */
        static subPath(path, predicate) {
          const node = find(path, predicate);
          const elementIdx = path.indexOf(node);
          return elementIdx === -1 ? void 0 : path.slice(0, elementIdx + 1);
        }
        static nonDynamicParams(node) {
          return node.state.parameters({ inherit: false }).filter((param) => !param.dynamic);
        }
        /** Gets the raw parameter values from a path */
        static paramValues(path) {
          return path.reduce((acc, node) => Object.assign(acc, node.paramValues), {});
        }
      }
      function makeTargetState(registry, path) {
        return new TargetState(
          registry,
          path.at(-1).state,
          path.map((x) => x.paramValues).reduce((acc, obj) => ({ ...acc, ...obj }), {}),
          {}
        );
      }
      const resolvePolicies = {
        when: {
          LAZY: "LAZY",
          EAGER: "EAGER"
        }
      };
      const ALL_WHENS = [resolvePolicies.when.EAGER, resolvePolicies.when.LAZY];
      const EAGER_WHENS = [resolvePolicies.when.EAGER];
      class ResolveContext {
        constructor(_path) {
          this._path = _path;
        }
        /** Gets all the tokens found in the resolve context, de-duplicated */
        getTokens() {
          return this._path.reduce(
            (acc, node) => acc.concat(node.resolvables.map((r) => r.token)),
            []
          ).reduce(uniqR, []);
        }
        /**
         * Gets the Resolvable that matches the token
         *
         * Gets the last Resolvable that matches the token in this context, or undefined.
         * Throws an error if it doesn't exist in the ResolveContext
         */
        getResolvable(token) {
          const matching = this._path.map((node) => node.resolvables).reduce(unnestR, []).filter((r) => r.token === token);
          return tail(matching);
        }
        /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */
        getPolicy(resolvable) {
          const node = this.findNode(resolvable);
          return resolvable.getPolicy(node);
        }
        /**
         * Returns a ResolveContext that includes a portion of this one
         *
         * Given a state, this method creates a new ResolveContext from this one.
         * The new context starts at the first node (root) and stops at the node for the `state` parameter.
         *
         * #### Why
         *
         * When a transition is created, the nodes in the "To Path" are injected from a ResolveContext.
         * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.
         * The "To State" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).
         * This method is used to create a narrower context when injecting ancestor nodes.
         *
         * @example
         * `let ABCD = new ResolveContext([A, B, C, D]);`
         *
         * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:
         * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.
         * However, `B` should only be able to access resolvables from `A`, `B`.
         *
         * When resolving for the `B` node, first take the full "To Path" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.
         * `let AB = ABCD.subcontext(a)`
         */
        subContext(state) {
          return new ResolveContext(
            PathUtils.subPath(this._path, (node) => node.state === state)
          );
        }
        /**
         * Adds Resolvables to the node that matches the state
         *
         * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).
         * The resolvable is added to the node matching the `state` parameter.
         *
         * These new resolvables are not automatically fetched.
         * The calling code should either fetch them, fetch something that depends on them,
         * or rely on [[resolvePath]] being called when some state is being entered.
         *
         * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.
         *
         * @param {Resolvable[]} newResolvables the new Resolvables
         * @param state Used to find the node to put the resolvable on
         */
        addResolvables(newResolvables, state) {
          const node = find(this._path, propEq("state", state));
          const keys = newResolvables.map((r) => r.token);
          node.resolvables = node.resolvables.filter((r) => keys.indexOf(r.token) === -1).concat(newResolvables);
        }
        /**
         * Returns a promise for an array of resolved path Element promises
         *
         * @param {string} when
         * @param trans
         * @returns {Promise<any>|any}
         */
        resolvePath(when = "LAZY", trans) {
          const whenOption = ALL_WHENS.includes(when) ? when : "LAZY";
          const matchedWhens = whenOption === resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;
          trace.traceResolvePath(this._path, when, trans);
          const matchesPolicy = (acceptedVals, whenOrAsync) => (resolvable) => acceptedVals.includes(this.getPolicy(resolvable)[whenOrAsync]);
          const promises = this._path.reduce((acc, node) => {
            const nodeResolvables = node.resolvables.filter(
              matchesPolicy(matchedWhens, "when")
            );
            const nowait = nodeResolvables.filter(matchesPolicy(["NOWAIT"], "async"));
            const wait2 = nodeResolvables.filter(
              (x) => !matchesPolicy(["NOWAIT"], "async")(x)
            );
            const subContext = this.subContext(node.state);
            const getResult = (r) => r.get(subContext, trans).then((value) => ({ token: r.token, value }));
            nowait.forEach(getResult);
            return acc.concat(wait2.map(getResult));
          }, []);
          return Promise.all(promises);
        }
        findNode(resolvable) {
          return find(this._path, (node) => node.resolvables.includes(resolvable));
        }
        /**
         * Gets the async dependencies of a Resolvable
         *
         * Given a Resolvable, returns its dependencies as a Resolvable[]
         * @param {Resolvable} resolvable
         * @returns {Resolvable[]}
         */
        getDependencies(resolvable) {
          const node = this.findNode(resolvable);
          const subPath = PathUtils.subPath(this._path, (x) => x === node) || this._path;
          const availableResolvables = subPath.reduce((acc, _node) => acc.concat(_node.resolvables), []).filter((res) => res !== resolvable);
          return resolvable.deps.map((token) => {
            const matching = availableResolvables.filter((r) => r.token === token);
            if (matching.length) return tail(matching);
            const fromInjector = window["angular"].$injector.get(token);
            if (isUndefined(fromInjector)) {
              throw new Error(
                "Could not find Dependency Injection token: " + stringify(token)
              );
            }
            return new Resolvable(token, () => fromInjector, [], fromInjector);
          });
        }
      }
      function getViewConfigFactory() {
        let templateFactory = null;
        return (path, view) => {
          templateFactory = templateFactory || window["angular"].$injector.get("$templateFactory");
          return new ViewConfig(path, view, templateFactory);
        };
      }
      const hasAnyKey = (keys, obj) => keys.reduce((acc, key) => acc || isDefined(obj[key]), false);
      function ng1ViewsBuilder(state) {
        if (!state.parent) return {};
        const tplKeys = [
          "templateProvider",
          "templateUrl",
          "template",
          "notify",
          "async"
        ], ctrlKeys = [
          "controller",
          "controllerProvider",
          "controllerAs",
          "resolveAs"
        ], compKeys = ["component", "bindings", "componentProvider"], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);
        if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {
          throw new Error(
            `State '${state.name}' has a 'views' object. It cannot also have "view properties" at the state level.  Move the following properties into a view (in the 'views' object):  ${allViewKeys.filter((key) => isDefined(state[key])).join(", ")}`
          );
        }
        const views = {}, viewsObject = state.views || { $default: pick(state, allViewKeys) };
        Object.entries(viewsObject).forEach(([name2, config]) => {
          name2 = name2 || "$default";
          if (isString(config)) config = { component: config };
          config = Object.assign({}, config);
          if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {
            throw new Error(
              `Cannot combine: ${compKeys.join("|")} with: ${nonCompKeys.join("|")} in stateview: '${name2}@${state.name}'`
            );
          }
          config.resolveAs = config.resolveAs || "$resolve";
          config.$context = state;
          config.$name = name2;
          const normalized = ViewConfig.normalizeUIViewTarget(
            config.$context,
            config.$name
          );
          config.$ngViewName = normalized.ngViewName;
          config.$ngViewContextAnchor = normalized.ngViewContextAnchor;
          views[name2] = config;
        });
        return views;
      }
      let id$1 = 0;
      class ViewConfig {
        /**
         * @param {Array<import('../path/path-node.js').PathNode>} path
         * @param viewDecl
         * @param {import('../template-factory.js').TemplateFactoryProvider} factory
         */
        constructor(path, viewDecl, factory) {
          this.path = path;
          this.viewDecl = viewDecl;
          this.factory = factory;
          this.component = void 0;
          this.template = void 0;
          this.$id = id$1++;
          this.loaded = false;
          this.getTemplate = (ngView2, context) => this.component ? this.factory.makeComponentTemplate(
            ngView2,
            context,
            this.component,
            this.viewDecl.bindings
          ) : this.template;
        }
        load() {
          const context = new ResolveContext(this.path);
          const params = this.path.reduce(
            (acc, node) => Object.assign(acc, node.paramValues),
            {}
          );
          const promises = [
            Promise.resolve(this.factory.fromConfig(this.viewDecl, params, context)),
            Promise.resolve(this.getController(context))
          ];
          return Promise.all(promises).then((results) => {
            trace.traceViewServiceEvent("Loaded", this);
            this.controller = results[1];
            Object.assign(this, results[0]);
            return this;
          });
        }
        /**
         * Gets the controller for a view configuration.
         *
         * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.
         */
        getController(context) {
          const provider2 = this.viewDecl.controllerProvider;
          if (!isInjectable(provider2)) return this.viewDecl.controller;
          const deps = annotate(provider2);
          const providerFn = Array.isArray(provider2) ? tail(provider2) : provider2;
          const resolvable = new Resolvable("", providerFn, deps);
          return resolvable.get(context);
        }
        /**
         * Normalizes a view's name from a state.views configuration block.
         *
         * This should be used by a framework implementation to calculate the values for
         * [[_ViewDeclaration.$ngViewName]] and [[_ViewDeclaration.$ngViewContextAnchor]].
         *
         * @param context the context object (state declaration) that the view belongs to
         * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]
         *
         * @returns the normalized ngViewName and ngViewContextAnchor that the view targets
         */
        static normalizeUIViewTarget(context, rawViewName = "") {
          const viewAtContext = rawViewName.split("@");
          let ngViewName = viewAtContext[0] || "$default";
          let ngViewContextAnchor = isString(viewAtContext[1]) ? viewAtContext[1] : "^";
          const relativeViewNameSugar = /^(\^(?:\.\^)*)\.(.*$)/.exec(ngViewName);
          if (relativeViewNameSugar) {
            ngViewContextAnchor = relativeViewNameSugar[1];
            ngViewName = relativeViewNameSugar[2];
          }
          if (ngViewName.charAt(0) === "!") {
            ngViewName = ngViewName.substring(1);
            ngViewContextAnchor = "";
          }
          const relativeMatch = /^(\^(?:\.\^)*)$/;
          if (relativeMatch.exec(ngViewContextAnchor)) {
            const anchorState = ngViewContextAnchor.split(".").reduce((anchor) => anchor.parent, context);
            ngViewContextAnchor = anchorState.name;
          } else if (ngViewContextAnchor === ".") {
            ngViewContextAnchor = context.name;
          }
          return { ngViewName, ngViewContextAnchor };
        }
      }
      class ViewService {
        constructor() {
          this._ngViews = [];
          this._viewConfigs = [];
          this._viewConfigFactories = {};
          this._listeners = [];
          this._pluginapi = {
            _registeredUIView: (id2) => {
              return find(this._ngViews, (view) => view.id === id2);
            },
            _registeredUIViews: () => this._ngViews,
            _activeViewConfigs: () => this._viewConfigs,
            _onSync: (listener) => {
              this._listeners.push(listener);
              return () => removeFrom(this._listeners, listener);
            }
          };
          this.viewConfigFactory(getViewConfigFactory());
        }
        $get = [() => this];
        /**
         * @param {?import('../state/state-object.js').StateObject} context
         * @return {?import('../state/state-object.js').StateObject}
         */
        rootViewContext(context) {
          return this._rootContext = context || this._rootContext;
        }
        viewConfigFactory(factory) {
          this.viewConfigFactory = factory;
        }
        /**
         * @param path
         * @param decl
         * @return {import("../state/views.js").ViewConfig}
         */
        createViewConfig(path, decl) {
          const cfgFactory = this.viewConfigFactory;
          if (!cfgFactory)
            throw new Error(
              "ViewService: No view config factory registered for type " + decl.$type
            );
          return cfgFactory(path, decl);
        }
        /**
         * Deactivates a ViewConfig.
         *
         * This function deactivates a `ViewConfig`.
         * After calling [[sync]], it will un-pair from any `ng-view` with which it is currently paired.
         *
         * @param viewConfig The ViewConfig view to deregister.
         */
        deactivateViewConfig(viewConfig) {
          trace.traceViewServiceEvent("<- Removing", viewConfig);
          removeFrom(this._viewConfigs, viewConfig);
        }
        activateViewConfig(viewConfig) {
          trace.traceViewServiceEvent("-> Registering", viewConfig);
          this._viewConfigs.push(viewConfig);
        }
        sync() {
          const ngViewsByFqn = this._ngViews.map((uiv) => [uiv.fqn, uiv]).reduce(applyPairs, {});
          function ngViewDepth(ngView2) {
            const stateDepth = (context) => context && context.parent ? stateDepth(context.parent) + 1 : 1;
            return ngView2.fqn.split(".").length * 1e4 + stateDepth(ngView2.creationContext);
          }
          function viewConfigDepth(config) {
            let context = config.viewDecl.$context, count = 0;
            while (++count && context.parent) context = context.parent;
            return count;
          }
          const depthCompare = curry(
            (depthFn, posNeg, left, right) => posNeg * (depthFn(left) - depthFn(right))
          );
          const matchingConfigPair = (ngView2) => {
            const matchingConfigs = this._viewConfigs.filter(
              ViewService.matches(ngViewsByFqn, ngView2)
            );
            if (matchingConfigs.length > 1) {
              matchingConfigs.sort(depthCompare(viewConfigDepth, -1));
            }
            return { ngView: ngView2, viewConfig: matchingConfigs[0] };
          };
          const configureUIView = (tuple) => {
            if (this._ngViews.indexOf(tuple.ngView) !== -1) {
              tuple.ngView.configUpdated(tuple.viewConfig);
            }
          };
          const ngViewTuples = this._ngViews.sort(depthCompare(ngViewDepth, 1)).map(matchingConfigPair);
          const matchedViewConfigs = ngViewTuples.map((tuple) => tuple.viewConfig);
          const unmatchedConfigTuples = this._viewConfigs.filter((config) => !matchedViewConfigs.includes(config)).map((viewConfig) => ({ ngView: void 0, viewConfig }));
          ngViewTuples.forEach((tuple) => {
            configureUIView(tuple);
          });
          const allTuples = ngViewTuples.concat(unmatchedConfigTuples);
          this._listeners.forEach((cb) => cb(allTuples));
          trace.traceViewSync(allTuples);
        }
        /**
         * Registers a `ng-view` component
         *
         * When a `ng-view` component is created, it uses this method to register itself.
         * After registration the [[sync]] method is used to ensure all `ng-view` are configured with the proper [[ViewConfig]].
         *
         * Note: the `ng-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ng-view`,
         * and what the view's state context is.
         *
         * Note: There is no corresponding `deregisterUIView`.
         *       A `ng-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.
         *
         * @param ngView The metadata for a UIView
         * @return a de-registration function used when the view is destroyed.
         */
        registerUIView(ngView2) {
          trace.traceViewServiceUIViewEvent("-> Registering", ngView2);
          const ngViews = this._ngViews;
          const fqnAndTypeMatches = (uiv) => uiv.fqn === ngView2.fqn;
          if (ngViews.filter(fqnAndTypeMatches).length)
            trace.traceViewServiceUIViewEvent("!!!! duplicate ngView named:", ngView2);
          ngViews.push(ngView2);
          this.sync();
          return () => {
            const idx = ngViews.indexOf(ngView2);
            if (idx === -1) {
              trace.traceViewServiceUIViewEvent(
                "Tried removing non-registered ngView",
                ngView2
              );
              return;
            }
            trace.traceViewServiceUIViewEvent("<- Deregistering", ngView2);
            removeFrom(ngViews)(ngView2);
          };
        }
        /**
         * Returns the list of views currently available on the page, by fully-qualified name.
         *
         * @return {Array} Returns an array of fully-qualified view names.
         */
        available() {
          return this._ngViews.map((x) => x.fqn);
        }
        /**
         * Returns the list of views on the page containing loaded content.
         *
         * @return {Array} Returns an array of fully-qualified view names.
         */
        active() {
          return this._ngViews.filter((x) => x.$config).map((x) => x.name);
        }
      }
      ViewService.matches = (ngViewsByFqn, ngView2) => (viewConfig) => {
        if (ngView2.$type !== viewConfig.viewDecl.$type) return false;
        const vc = viewConfig.viewDecl;
        const vcSegments = vc.$ngViewName.split(".");
        const uivSegments = ngView2.fqn.split(".");
        if (!equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))
          return false;
        const negOffset = 1 - vcSegments.length || void 0;
        const fqnToFirstSegment = uivSegments.slice(0, negOffset).join(".");
        const ngViewContext = ngViewsByFqn[fqnToFirstSegment].creationContext;
        return vc.$ngViewContextAnchor === (ngViewContext && ngViewContext.name);
      };
      const TransitionHookPhase = {
        CREATE: 0,
        BEFORE: 1,
        RUN: 2,
        SUCCESS: 3,
        ERROR: 4
      };
      const TransitionHookScope = {
        TRANSITION: 0,
        STATE: 1
      };
      const RejectType = {
        /**
         * A new transition superseded this one.
         *
         * While this transition was running, a new transition started.
         * This transition is cancelled because it was superseded by a new transition.
         * @type {number}
         */
        SUPERSEDED: 2,
        /**
         * The transition was aborted.
         *
         * The transition was aborted by a hook which returned `false`.
         * @type {number}
         */
        ABORTED: 3,
        /**
         * The transition was invalid.
         *
         * The transition was never started because it was invalid.
         * @type {number}
         */
        INVALID: 4,
        /**
         * The transition was ignored.
         *
         * The transition was ignored because it would have no effect.
         * Either:
         * - The transition is targeting the current state and parameter values.
         * - The transition is targeting the same state and parameter values as the currently running transition.
         * @type {number}
         */
        IGNORED: 5,
        /**
         * The transition errored.
         *
         * This generally means a hook threw an error or returned a rejected promise.
         * @type {number}
         */
        ERROR: 6
      };
      let id = 0;
      class Rejection {
        /** Returns a Rejection due to transition superseded */
        static superseded(detail, options) {
          const message = "The transition has been superseded by a different transition";
          const rejection = new Rejection(RejectType.SUPERSEDED, message, detail);
          if (options && options.redirected) {
            rejection.redirected = true;
          }
          return rejection;
        }
        /** Returns a Rejection due to redirected transition */
        static redirected(detail) {
          return Rejection.superseded(detail, { redirected: true });
        }
        /** Returns a Rejection due to invalid transition */
        static invalid(detail) {
          const message = "This transition is invalid";
          return new Rejection(RejectType.INVALID, message, detail);
        }
        /** Returns a Rejection due to ignored transition */
        static ignored(detail) {
          const message = "The transition was ignored";
          return new Rejection(RejectType.IGNORED, message, detail);
        }
        /** Returns a Rejection due to aborted transition */
        static aborted(detail) {
          const message = "The transition has been aborted";
          return new Rejection(RejectType.ABORTED, message, detail);
        }
        /** Returns a Rejection due to aborted transition */
        static errored(detail) {
          const message = "The transition errored";
          return new Rejection(RejectType.ERROR, message, detail);
        }
        /**
         * Returns a Rejection
         *
         * Normalizes a value as a Rejection.
         * If the value is already a Rejection, returns it.
         * Otherwise, wraps and returns the value as a Rejection (Rejection type: ERROR).
         *
         * @returns `detail` if it is already a `Rejection`, else returns an ERROR Rejection.
         */
        static normalize(detail) {
          return is(Rejection)(detail) ? detail : Rejection.errored(detail);
        }
        constructor(type, message, detail) {
          this.$id = id++;
          this.type = type;
          this.message = message;
          this.detail = detail;
          this.redirected = false;
        }
        toString() {
          const detailString = (d) => d && d.toString !== Object.prototype.toString ? d.toString() : stringify(d);
          const detail = detailString(this.detail);
          const { $id, type, message } = this;
          return `Transition Rejection($id: ${$id} type: ${type}, message: ${message}, detail: ${detail})`;
        }
        toPromise() {
          return Object.assign(silentRejection(this), { _transitionRejection: this });
        }
      }
      class PubSubProvider {
        constructor() {
          this.eventBus = EventBus;
        }
        /**
         * @returns {PubSub}
         */
        $get = () => this.eventBus;
      }
      class PubSub {
        /**
         * Topic-based publish/subscribe channel.  Maintains a map of topics to
         * subscriptions.  When a message is published to a topic, all functions
         * subscribed to that topic are invoked in the order they were added.
         * Uncaught errors abort publishing.
         *
         * Topics may be identified by any nonempty string, <strong>except</strong>
         * strings corresponding to native Object properties, e.g. "constructor",
         * "toString", "hasOwnProperty", etc.
         *
         * @param {boolean=} async Enable asynchronous behavior.  Recommended for
         *     new code.  See notes on the publish() method.
         */
        constructor(async = false) {
          this.disposed = false;
          this.key = 1;
          this.pendingKeys = [];
          this.publishDepth = 0;
          this.subscriptions = [];
          this.topics = {};
          this.async_ = Boolean(async);
        }
        /**
         * Subscribes a function to a topic.  The function is invoked as a method on
         * the given `opt_context` object, or in the global scope if no context
         * is specified.  Subscribing the same function to the same topic multiple
         * times will result in multiple function invocations while publishing.
         * Returns a subscription key that can be used to unsubscribe the function from
         * the topic via {@link unsubscribeByKey}.
         *
         * @param {string} topic Topic to subscribe to.
         * @param {Function} fn Function to be invoked when a message is published to
         *     the given topic.
         * @param {Object=} opt_context Object in whose context the function is to be
         *     called (the global scope if none).
         * @return {number} Subscription key.
         */
        subscribe(topic, fn, opt_context = null) {
          let keys = this.topics[topic];
          if (!keys) {
            keys = this.topics[topic] = [];
          }
          const key = this.key;
          this.subscriptions[key] = topic;
          this.subscriptions[key + 1] = fn;
          this.subscriptions[key + 2] = opt_context;
          this.key = key + 3;
          keys.push(key);
          return key;
        }
        /**
         * Subscribes a single-use function to a topic.  The function is invoked as a
         * method on the given `opt_context` object, or in the global scope if
         * no context is specified, and is then unsubscribed.  Returns a subscription
         * key that can be used to unsubscribe the function from the topic via
         * {@link unsubscribeByKey}.
         *
         * @param {string} topic Topic to subscribe to.
         * @param {Function} fn Function to be invoked once and then unsubscribed when
         *     a message is published to the given topic.
         * @param {Object=} opt_context Object in whose context the function is to be
         *     called (the global scope if none).
         * @return {number} Subscription key.
         */
        subscribeOnce(topic, fn, opt_context = null) {
          let called = false;
          const key = this.subscribe(
            topic,
            (...args) => {
              if (!called) {
                called = true;
                this.unsubscribeByKey(key);
                fn.apply(opt_context, args);
              }
            },
            this
          );
          return key;
        }
        /**
         * Runs a function asynchronously.
         *
         * @private
         * @param {Function} fn Function to run.
         * @param {Object} context Context in which to run the function.
         * @param {Array} args Arguments to pass to the function.
         */
        static runAsync_(fn, context, args) {
          Promise.resolve().then(() => {
            fn.apply(context, args);
          });
        }
        /**
         * Unsubscribes a function from a topic.  Only deletes the first match found.
         * Returns a Boolean indicating whether a subscription was removed.
         *
         * @param {string} topic Topic to unsubscribe from.
         * @param {Function} fn Function to unsubscribe.
         * @param {Object=} opt_context Object in whose context the function was to be
         *     called (the global scope if none).
         * @return {boolean} Whether a matching subscription was removed.
         */
        unsubscribe(topic, fn, opt_context = null) {
          const keys = this.topics[topic];
          if (keys) {
            const subscriptions = this.subscriptions;
            const key = keys.find(
              (k) => subscriptions[k + 1] === fn && subscriptions[k + 2] === opt_context
            );
            if (key !== void 0) {
              return this.unsubscribeByKey(key);
            }
          }
          return false;
        }
        /**
         * Removes a subscription based on the key returned by {@link subscribe}.
         * No-op if no matching subscription is found.  Returns a Boolean indicating
         * whether a subscription was removed.
         *
         * @param {number} key Subscription key.
         * @return {boolean} Whether a matching subscription was removed.
         */
        unsubscribeByKey(key) {
          const topic = this.subscriptions[key];
          if (topic) {
            let keys = this.topics[topic];
            if (this.publishDepth !== 0) {
              this.pendingKeys.push(key);
              this.subscriptions[key + 1] = () => {
              };
            } else {
              if (keys) {
                this.topics[topic] = keys.filter((k) => k !== key);
              }
              delete this.subscriptions[key];
              delete this.subscriptions[key + 1];
              delete this.subscriptions[key + 2];
            }
          }
          return !!topic;
        }
        /**
         * Publishes a message to a topic.  Calls functions subscribed to the topic in
         * the order in which they were added, passing all arguments along.
         *
         * If this object was created with async=true, subscribed functions are called
         * via Promise.resolve().  Otherwise, the functions are called directly, and if
         * any of them throw an uncaught error, publishing is aborted.
         *
         * @param {string} topic Topic to publish to.
         * @param {...*} var_args Arguments that are applied to each subscription
         *     function.
         * @return {boolean} Whether any subscriptions were called.
         */
        publish(topic, ...var_args) {
          const keys = this.topics[topic];
          if (keys) {
            const args = var_args;
            if (this.async_) {
              for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                PubSub.runAsync_(
                  this.subscriptions[key + 1],
                  this.subscriptions[key + 2],
                  args
                );
              }
            } else {
              this.publishDepth++;
              try {
                for (let i = 0, len = keys.length; i < len && !this.isDisposed(); i++) {
                  const key = keys[i];
                  this.subscriptions[key + 1].apply(
                    this.subscriptions[key + 2],
                    args
                  );
                }
              } finally {
                this.publishDepth--;
                if (this.pendingKeys.length > 0 && this.publishDepth === 0) {
                  let pendingKey;
                  while (pendingKey = this.pendingKeys.pop()) {
                    this.unsubscribeByKey(pendingKey);
                  }
                }
              }
            }
            return true;
          }
          return false;
        }
        /**
         * Clears the subscription list for a topic, or all topics if unspecified.
         * @param {string=} opt_topic Topic to clear (all topics if unspecified).
         */
        clear(opt_topic) {
          if (opt_topic) {
            const keys = this.topics[opt_topic];
            if (keys) {
              keys.forEach(this.unsubscribeByKey, this);
              delete this.topics[opt_topic];
            }
          } else {
            this.subscriptions.length = 0;
            this.topics = {};
          }
        }
        /**
         * Returns the number of subscriptions to the given topic (or all topics if
         * unspecified). This number will not change while publishing any messages.
         * @param {string=} opt_topic The topic (all topics if unspecified).
         * @return {number} Number of subscriptions to the topic.
         */
        getCount(opt_topic) {
          if (opt_topic) {
            const keys = this.topics[opt_topic];
            return keys ? keys.length : 0;
          }
          let count = 0;
          for (const topic in this.topics) {
            count += this.getCount(topic);
          }
          return count;
        }
        isDisposed() {
          return this.disposed;
        }
        dispose() {
          this.clear();
          this.pendingKeys.length = 0;
          this.disposed = true;
        }
      }
      const EventBus = new PubSub(true);
      const defaultOptions = {
        current: () => {
        },
        transition: null,
        traceData: {},
        bind: null
      };
      class TransitionHook {
        /**
         * Chains together an array of TransitionHooks.
         *
         * Given a list of [[TransitionHook]] objects, chains them together.
         * Each hook is invoked after the previous one completes.
         *
         * #### Example:
         * ```js
         * var hooks: TransitionHook[] = getHooks();
         * let promise: Promise<any> = TransitionHook.chain(hooks);
         *
         * promise.then(handleSuccess, handleError);
         * ```
         *
         * @param hooks the list of hooks to chain together
         * @param waitFor if provided, the chain is `.then()`'ed off this promise
         * @returns a `Promise` for sequentially invoking the hooks (in order)
         */
        static chain(hooks, waitFor) {
          const createHookChainR = (prev, nextHook) => prev.then(() => nextHook.invokeHook());
          return hooks.reduce(createHookChainR, waitFor || Promise.resolve());
        }
        /**
         * Invokes all the provided TransitionHooks, in order.
         * Each hook's return value is checked.
         * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.
         * If no hook returns a promise, then all hooks are processed synchronously.
         *
         * @param hooks the list of TransitionHooks to invoke
         * @param doneCallback a callback that is invoked after all the hooks have successfully completed
         *
         * @returns a promise for the async result, or the result of the callback
         */
        static invokeHooks(hooks, doneCallback) {
          for (let idx = 0; idx < hooks.length; idx++) {
            const hookResult = hooks[idx].invokeHook();
            if (isPromise(hookResult)) {
              const remainingHooks = hooks.slice(idx + 1);
              return TransitionHook.chain(remainingHooks, hookResult).then(() => {
                doneCallback();
              });
            }
          }
          return doneCallback();
        }
        /**
         * Run all TransitionHooks, ignoring their return value.
         */
        static runAllHooks(hooks) {
          hooks.forEach((hook) => hook.invokeHook());
        }
        constructor(transition, stateContext2, registeredHook, options) {
          this.transition = transition;
          this.stateContext = stateContext2;
          this.registeredHook = registeredHook;
          this.options = options;
          this.isSuperseded = () => this.type.hookPhase === TransitionHookPhase.RUN && !this.options.transition.isActive();
          this.options = defaults(options, defaultOptions);
          this.type = registeredHook.eventType;
        }
        logError(err2) {
          EventBus.publish("$stateService:defaultErrorHandler", err2);
        }
        invokeHook() {
          const hook = this.registeredHook;
          if (hook._deregistered) return;
          const notCurrent = this.getNotCurrentRejection();
          if (notCurrent) return notCurrent;
          const options = this.options;
          trace.traceHookInvocation(this, this.transition, options);
          const invokeCallback = () => hook.callback.call(options.bind, this.transition, this.stateContext);
          const normalizeErr = (err2) => Rejection.normalize(err2).toPromise();
          const handleError = (err2) => hook.eventType.getErrorHandler(this)(err2);
          const handleResult = (result) => hook.eventType.getResultHandler(this)(result);
          try {
            const result = invokeCallback();
            if (!this.type.synchronous && isPromise(result)) {
              return result.catch(normalizeErr).then(handleResult, handleError);
            } else {
              return handleResult(result);
            }
          } catch (err2) {
            return handleError(Rejection.normalize(err2));
          } finally {
            if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {
              hook.deregister();
            }
          }
        }
        /**
         * This method handles the return value of a Transition Hook.
         *
         * A hook can return false (cancel), a TargetState (redirect),
         * or a promise (which may later resolve to false or a redirect)
         *
         * This also handles "transition superseded" -- when a new transition
         * was started while the hook was still running
         */
        handleHookResult(result) {
          const notCurrent = this.getNotCurrentRejection();
          if (notCurrent) return notCurrent;
          if (isPromise(result)) {
            return result.then((val2) => this.handleHookResult(val2));
          }
          trace.traceHookResult(result, this.transition);
          if (result === false) {
            return Rejection.aborted("Hook aborted transition").toPromise();
          }
          if (result instanceof TargetState) {
            return Rejection.redirected(result).toPromise();
          }
        }
        /**
         * Return a Rejection promise if the transition is no longer current due
         * a new transition has started and superseded this one.
         */
        getNotCurrentRejection() {
          if (this.transition._aborted) {
            return Rejection.aborted().toPromise();
          }
          if (this.isSuperseded()) {
            return Rejection.superseded(this.options.current()).toPromise();
          }
        }
        toString() {
          const { options, registeredHook } = this;
          const event = parse("traceData.hookType")(options) || "internal", context = parse("traceData.context.state.name")(options) || parse("traceData.context")(options) || "unknown", name2 = fnToString(registeredHook.callback);
          return `${event} context: ${context}, ${maxLength(200, name2)}`;
        }
      }
      TransitionHook.HANDLE_RESULT = (hook) => (result) => hook.handleHookResult(result);
      TransitionHook.LOG_REJECTED_RESULT = (hook) => (result) => {
        isPromise(result) && result.catch((err2) => hook.logError(Rejection.normalize(err2)));
        return void 0;
      };
      TransitionHook.LOG_ERROR = (hook) => (error) => hook.logError(error);
      TransitionHook.REJECT_ERROR = () => (error) => silentRejection(error);
      TransitionHook.THROW_ERROR = () => (error) => {
        throw error;
      };
      class Glob {
        /** Returns a glob from the string, or null if the string isn't Glob-like
         * @param {string} text
         * @returns {?Glob}
         */
        static fromString(text) {
          return hasGlobs(text) ? new Glob(text) : null;
        }
        /**
         * @param {string} text
         */
        constructor(text) {
          this.text = text;
          this.glob = text.split(".");
          const regexpString = this.text.split(".").map((seg) => {
            if (seg === "**") return "(?:|(?:\\.[^.]*)*)";
            if (seg === "*") return "\\.[^.]*";
            return "\\." + seg;
          }).join("");
          this.regexp = new RegExp("^" + regexpString + "$");
        }
        /**
         * @param {string} name
         * @return {boolean}
         */
        matches(name2) {
          return this.regexp.test("." + name2);
        }
      }
      function hasGlobs(text) {
        return !!/[!,*]+/.exec(text);
      }
      function matchState(state, criterion, transition) {
        const toMatch = isString(criterion) ? [criterion] : criterion;
        function matchGlobs(_state) {
          const globStrings = toMatch;
          for (let i = 0; i < globStrings.length; i++) {
            const glob = new Glob(globStrings[i]);
            if (glob && glob.matches(_state.name) || !glob && globStrings[i] === _state.name) {
              return true;
            }
          }
          return false;
        }
        const matchFn = isFunction(toMatch) ? toMatch : matchGlobs;
        return !!matchFn(state, transition);
      }
      class RegisteredHook {
        constructor(tranSvc, eventType, callback, matchCriteria, removeHookFromRegistry, options = {}) {
          this.tranSvc = tranSvc;
          this.eventType = eventType;
          this.callback = callback;
          this.matchCriteria = matchCriteria;
          this.removeHookFromRegistry = removeHookFromRegistry;
          this.invokeCount = 0;
          this._deregistered = false;
          this.priority = options.priority || 0;
          this.bind = options.bind || null;
          this.invokeLimit = options.invokeLimit;
        }
        /**
         * Gets the matching [[PathNode]]s
         *
         * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing
         * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.
         *
         * Returning `null` is significant to distinguish between the default
         * "match-all criterion value" of `true` compared to a `() => true` function,
         * when the nodes is an empty array.
         *
         * This is useful to allow a transition match criteria of `entering: true`
         * to still match a transition, even when `entering === []`.  Contrast that
         * with `entering: (state) => true` which only matches when a state is actually
         * being entered.
         */
        _matchingNodes(nodes, criterion, transition) {
          if (criterion === true) return nodes;
          const matching = nodes.filter(
            (node) => matchState(node.state, criterion, transition)
          );
          return matching.length ? matching : null;
        }
        /**
         * Gets the default match criteria (all `true`)
         *
         * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:
         *
         * ```js
         * {
         *   to: true,
         *   from: true,
         *   entering: true,
         *   exiting: true,
         *   retained: true,
         * }
         */
        _getDefaultMatchCriteria() {
          return map(this.tranSvc._pluginapi._getPathTypes(), () => true);
        }
        /**
         * Gets matching nodes as [[IMatchingNodes]]
         *
         * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:
         *
         * ```js
         * let matches: IMatchingNodes = {
         *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),
         *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),
         *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),
         *   retained: _matchingNodes(treeChanges.retained,     mc.retained),
         *   entering: _matchingNodes(treeChanges.entering,     mc.entering),
         * };
         * ```
         */
        _getMatchingNodes(treeChanges, transition) {
          const criteria = Object.assign(
            this._getDefaultMatchCriteria(),
            this.matchCriteria
          );
          const paths = Object.values(this.tranSvc._pluginapi._getPathTypes());
          return paths.reduce((mn, pathtype) => {
            const isStateHook = pathtype.scope === TransitionHookScope.STATE;
            const path = treeChanges[pathtype.name] || [];
            const nodes = isStateHook ? path : [tail(path)];
            mn[pathtype.name] = this._matchingNodes(
              nodes,
              criteria[pathtype.name],
              transition
            );
            return mn;
          }, {});
        }
        /**
         * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]
         *
         * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values
         * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)
         */
        matches(treeChanges, transition) {
          const matches = this._getMatchingNodes(treeChanges, transition);
          const allMatched = Object.values(matches).every((x) => x);
          return allMatched ? matches : null;
        }
        deregister() {
          this.removeHookFromRegistry(this);
          this._deregistered = true;
        }
      }
      function makeEvent(registry, transitionService, eventType) {
        const _registeredHooks = registry._registeredHooks = registry._registeredHooks || {};
        const hooks = _registeredHooks[eventType.name] = [];
        const removeHookFn = removeFrom(hooks);
        registry[eventType.name] = hookRegistrationFn;
        function hookRegistrationFn(matchObject, callback, options = {}) {
          const registeredHook = new RegisteredHook(
            transitionService,
            eventType,
            callback,
            matchObject,
            removeHookFn,
            options
          );
          hooks.push(registeredHook);
          return registeredHook.deregister.bind(registeredHook);
        }
        return hookRegistrationFn;
      }
      class HookBuilder {
        constructor(transition) {
          this.transition = transition;
        }
        /**
         * @param {TransitionHookPhase} phase
         * @returns
         */
        buildHooksForPhase(phase) {
          return this.transition.transitionService._pluginapi._getEvents(phase).map((type) => this.buildHooks(type)).reduce(unnestR, []).filter(Boolean);
        }
        /**
         * Returns an array of newly built TransitionHook objects.
         *
         * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].
         * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)
         * - For each of the [[PathNode]]s, creates a TransitionHook
         *
         * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.
         */
        buildHooks(hookType) {
          const transition = this.transition;
          const treeChanges = transition.treeChanges();
          const matchingHooks = this.getMatchingHooks(
            hookType,
            treeChanges,
            transition
          );
          if (!matchingHooks) return [];
          const baseHookOptions = {
            transition,
            current: transition.options().current
          };
          const makeTransitionHooks = (hook) => {
            const matches = hook.matches(treeChanges, transition);
            const matchingNodes = matches[hookType.criteriaMatchPath.name];
            return matchingNodes.map((node) => {
              const _options = Object.assign(
                {
                  bind: hook.bind,
                  traceData: { hookType: hookType.name, context: node }
                },
                baseHookOptions
              );
              const state = hookType.criteriaMatchPath.scope === TransitionHookScope.STATE ? node.state.self : null;
              const transitionHook = new TransitionHook(
                transition,
                state,
                hook,
                _options
              );
              return { hook, node, transitionHook };
            });
          };
          return matchingHooks.map(makeTransitionHooks).reduce(unnestR, []).sort(tupleSort(hookType.reverseSort)).map((tuple) => tuple.transitionHook);
        }
        /**
         * Finds all RegisteredHooks from:
         * - The Transition object instance hook registry
         * - The TransitionService ($transitions) global hook registry
         *
         * which matched:
         * - the eventType
         * - the matchCriteria (to, from, exiting, retained, entering)
         *
         * @returns an array of matched [[RegisteredHook]]s
         */
        getMatchingHooks(hookType, treeChanges, transition) {
          const isCreate = hookType.hookPhase === TransitionHookPhase.CREATE;
          const $transitions = this.transition.transitionService;
          const registries = isCreate ? [$transitions] : [this.transition, $transitions];
          return registries.map((reg) => reg.getHooks(hookType.name)).filter(
            assertPredicate(Array.isArray, `broken event named: ${hookType.name}`)
          ).reduce(unnestR, []).filter((hook) => hook.matches(treeChanges, transition));
        }
      }
      function tupleSort(reverseDepthSort = false) {
        return function nodeDepthThenPriority(l, r) {
          const factor = reverseDepthSort ? -1 : 1;
          const depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;
          return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;
        };
      }
      class Transition {
        /**
         * Creates a new Transition object.
         *
         * If the target state is not valid, an error is thrown.
         *
         * @param {Array<import('../path/path-node.js').PathNode>} fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`
         *        encapsulates the "from state".
         * @param {import('../state/target-state.js').TargetState} targetState The target state and parameters being transitioned to (also, the transition options)
         * @param {import('../transition/transition-service.js').TransitionProvider} transitionService The [[TransitionService]] instance
         * @param {import('../router.js').Router} globals
         */
        constructor(fromPath, targetState, transitionService, globals) {
          this.globals = globals;
          this.transitionService = transitionService;
          this._deferred = Promise.withResolvers();
          this.promise = this._deferred.promise;
          this._registeredHooks = {};
          this._hookBuilder = new HookBuilder(this);
          this.isActive = () => this.globals.transition === this;
          this._targetState = targetState;
          if (!targetState.valid()) {
            throw new Error(targetState.error());
          }
          this._options = Object.assign(
            { current: val(this) },
            targetState.options()
          );
          this.$id = transitionService._transitionCount++;
          const toPath = PathUtils.buildToPath(fromPath, targetState);
          this._treeChanges = PathUtils.treeChanges(
            fromPath,
            toPath,
            this._options.reloadState
          );
          this.createTransitionHookRegFns();
          const onCreateHooks = this._hookBuilder.buildHooksForPhase(
            TransitionHookPhase.CREATE
          );
          TransitionHook.invokeHooks(onCreateHooks, () => null);
          this.applyViewConfigs();
          this.onStart = void 0;
          this.onBefore = void 0;
          this.onSuccess = void 0;
          this.onEnter = void 0;
          this.onRetain = void 0;
          this.onExit = void 0;
          this.onFinish = void 0;
          this.onError = void 0;
        }
        /**
         * Creates the transition-level hook registration functions
         * (which can then be used to register hooks)
         */
        createTransitionHookRegFns() {
          this.transitionService._pluginapi._getEvents().filter((type) => type.hookPhase !== TransitionHookPhase.CREATE).forEach((type) => makeEvent(this, this.transitionService, type));
        }
        getHooks(hookName) {
          return this._registeredHooks[hookName];
        }
        applyViewConfigs() {
          const enteringStates = this._treeChanges.entering.map((node) => node.state);
          PathUtils.applyViewConfigs(
            this.transitionService.$view,
            this._treeChanges.to,
            enteringStates
          );
        }
        /**
         * @returns {import('../state/state-object.js').StateObject} the internal from [State] object
         */
        $from() {
          return tail(this._treeChanges.from).state;
        }
        /**
         * @returns {import('../state/state-object.js').StateObject} the internal to [State] object
         */
        $to() {
          return tail(this._treeChanges.to).state;
        }
        /**
         * Returns the "from state"
         *
         * Returns the state that the transition is coming *from*.
         *
         * @returns The state declaration object for the Transition's ("from state").
         */
        from() {
          return this.$from().self;
        }
        /**
         * Returns the "to state"
         *
         * Returns the state that the transition is going *to*.
         *
         * @returns The state declaration object for the Transition's target state ("to state").
         */
        to() {
          return this.$to().self;
        }
        /**
         * Gets the Target State
         *
         * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.
         *
         * @returns the [[TargetState]] of this Transition
         */
        targetState() {
          return this._targetState;
        }
        /**
         * Determines whether two transitions are equivalent.
         * @deprecated
         */
        is(compare) {
          if (compare instanceof Transition) {
            return this.is({ to: compare.$to().name, from: compare.$from().name });
          }
          return !(compare.to && !matchState(this.$to(), compare.to, this) || compare.from && !matchState(this.$from(), compare.from, this));
        }
        params(pathname = "to") {
          return Object.freeze(
            this._treeChanges[pathname].map((x) => x.paramValues).reduce((acc, obj) => ({ ...acc, ...obj }), {})
          );
        }
        /**
         * Gets all available resolve tokens (keys)
         *
         * This method can be used in conjunction with [[injector]] to inspect the resolve values
         * available to the Transition.
         *
         * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states
         * in the Transition's [[TreeChanges.to]] path.
         *
         * #### Example:
         * This example logs all resolve values
         * ```js
         * let tokens = trans.getResolveTokens();
         * tokens.forEach(token => console.log(token + " = " + trans.injector().get(token)));
         * ```
         *
         * #### Example:
         * This example creates promises for each resolve value.
         * This triggers fetches of resolves (if any have not yet been fetched).
         * When all promises have all settled, it logs the resolve values.
         * ```js
         * let tokens = trans.getResolveTokens();
         * let promise = tokens.map(token => trans.injector().getAsync(token));
         * Promise.all(promises).then(values => console.log("Resolved values: " + values));
         * ```
         *
         * Note: Angular 1 users whould use `$q.all()`
         *
         * @param pathname resolve context's path name (e.g., `to` or `from`)
         *
         * @returns an array of resolve tokens (keys)
         */
        getResolveTokens(pathname = "to") {
          return new ResolveContext(this._treeChanges[pathname]).getTokens();
        }
        /**
         * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.
         *
         * Allows a transition hook to dynamically add a Resolvable to this Transition.
         *
         * Use the [[Transition.injector]] to retrieve the resolved data in subsequent hooks ([[UIInjector.get]]).
         *
         * If a `state` argument is provided, the Resolvable is processed when that state is being entered.
         * If no `state` is provided then the root state is used.
         * If the given `state` has already been entered, the Resolvable is processed when any child state is entered.
         * If no child states will be entered, the Resolvable is processed during the `onFinish` phase of the Transition.
         *
         * The `state` argument also scopes the resolved data.
         * The resolved data is available from the injector for that `state` and any children states.
         *
         * #### Example:
         * ```js
         * transitionService.onBefore({}, transition => {
         *   transition.addResolvable({
         *     token: 'myResolve',
         *     deps: ['MyService'],
         *     resolveFn: myService => myService.getData()
         *   });
         * });
         * ```
         *
         * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])
         * @param state the state in the "to path" which should receive the new resolve (otherwise, the root state)
         */
        addResolvable(resolvable, state) {
          if (state === void 0) {
            state = "";
          }
          resolvable = is(Resolvable)(resolvable) ? resolvable : new Resolvable(resolvable);
          const stateName = typeof state === "string" ? state : state.name;
          const topath = this._treeChanges.to;
          const targetNode = find(topath, (node) => {
            return node.state.name === stateName;
          });
          assert(!!targetNode, `targetNode not found ${stateName}`);
          const resolveContext = new ResolveContext(topath);
          resolveContext.addResolvables(
            [resolvable],
            /** @type {import("../path/path-node.js").PathNode} */
            targetNode.state
          );
        }
        /**
         * Gets the transition from which this transition was redirected.
         *
         * If the current transition is a redirect, this method returns the transition that was redirected.
         *
         * #### Example:
         * ```js
         * let transitionA = $state.go('A').transition
         * transitionA.onStart({}, () => $state.target('B'));
         * $transitions.onSuccess({ to: 'B' }, (trans) => {
         *   trans.to().name === 'B'; // true
         *   trans.redirectedFrom() === transitionA; // true
         * });
         * ```
         *
         * @returns The previous Transition, or null if this Transition is not the result of a redirection
         */
        redirectedFrom() {
          return this._options.redirectedFrom || null;
        }
        /**
         * Gets the original transition in a redirect chain
         *
         * A transition might belong to a long chain of multiple redirects.
         * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.
         *
         * #### Example:
         * ```js
         * // states
         * registry.register({ name: 'A', redirectTo: 'B' });
         * registry.register({ name: 'B', redirectTo: 'C' });
         * registry.register({ name: 'C', redirectTo: 'D' });
         * registry.register({ name: 'D' });
         *
         * let transitionA = $state.go('A').transition
         *
         * $transitions.onSuccess({ to: 'D' }, (trans) => {
         *   trans.to().name === 'D'; // true
         *   trans.redirectedFrom().to().name === 'C'; // true
         *   trans.originalTransition() === transitionA; // true
         *   trans.originalTransition().to().name === 'A'; // true
         * });
         * ```
         *
         * @returns The original Transition that started a redirect chain
         */
        originalTransition() {
          const rf = this.redirectedFrom();
          return rf && rf.originalTransition() || this;
        }
        /**
         * Get the transition options
         *
         * @returns the options for this Transition.
         */
        options() {
          return this._options;
        }
        /**
         * Gets the states being entered.
         *
         * @returns an array of states that will be entered during this transition.
         */
        entering() {
          return map(this._treeChanges.entering, (x) => x.state).map((x) => x.self);
        }
        /**
         * Gets the states being exited.
         *
         * @returns an array of states that will be exited during this transition.
         */
        exiting() {
          return map(this._treeChanges.exiting, (x) => x.state).map((x) => x.self).reverse();
        }
        /**
         * Gets the states being retained.
         *
         * @returns an array of states that are already entered from a previous Transition, that will not be
         *    exited during this Transition
         */
        retained() {
          return map(this._treeChanges.retained, (x) => x.state).map((x) => x.self);
        }
        /**
         * Get the [[ViewConfig]]s associated with this Transition
         *
         * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.
         * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., "to" or "entering").
         *
         * @param pathname the name of the path to fetch views for:
         *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)
         * @param state If provided, only returns the `ViewConfig`s for a single state in the path
         *
         * @returns a list of ViewConfig objects for the given path.
         */
        views(pathname = "entering", state) {
          let path = this._treeChanges[pathname];
          path = !state ? path : path.filter(propEq("state", state));
          return path.map((x) => x.views).reduce(unnestR, []);
        }
        treeChanges(pathname) {
          return pathname ? this._treeChanges[pathname] : this._treeChanges;
        }
        /**
         * Creates a new transition that is a redirection of the current one.
         *
         * This transition can be returned from a [[TransitionService]] hook to
         * redirect a transition to a new state and/or set of parameters.
         *
         * @internal
         *
         * @returns Returns a new [[Transition]] instance.
         */
        redirect(targetState) {
          let redirects = 1, trans = this;
          while ((trans = trans.redirectedFrom()) != null) {
            if (++redirects > 20)
              throw new Error(`Too many consecutive Transition redirects (20+)`);
          }
          const redirectOpts = { redirectedFrom: this, source: "redirect" };
          if (this.options().source === "url" && targetState.options().location !== false) {
            redirectOpts.location = "replace";
          }
          const newOptions = Object.assign(
            {},
            this.options(),
            targetState.options(),
            redirectOpts
          );
          targetState = targetState.withOptions(newOptions, true);
          const newTransition = this.transitionService.create(
            this._treeChanges.from,
            targetState
          );
          const originalEnteringNodes = this._treeChanges.entering;
          const redirectEnteringNodes = newTransition._treeChanges.entering;
          const nodeIsReloading = (reloadState) => (node) => {
            return reloadState && node.state.includes[reloadState.name];
          };
          const matchingEnteringNodes = PathUtils.matching(
            redirectEnteringNodes,
            originalEnteringNodes,
            PathUtils.nonDynamicParams
          ).filter((x) => !nodeIsReloading(targetState.options().reloadState)(x));
          matchingEnteringNodes.forEach((node, idx) => {
            node.resolvables = originalEnteringNodes[idx].resolvables;
          });
          return newTransition;
        }
        /** @internal If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */
        _changedParams() {
          const tc = this._treeChanges;
          if (this._options.reload) return void 0;
          if (tc.exiting.length || tc.entering.length) return void 0;
          if (tc.to.length !== tc.from.length) return void 0;
          const pathsDiffer = arrayTuples(tc.to, tc.from).map((tuple) => tuple[0].state !== tuple[1].state).reduce(anyTrueR, false);
          if (pathsDiffer) return void 0;
          const nodeSchemas = tc.to.map((node) => node.paramSchema);
          const [toValues, fromValues] = [tc.to, tc.from].map(
            (path) => path.map((x) => x.paramValues)
          );
          const tuples = arrayTuples(nodeSchemas, toValues, fromValues);
          return tuples.map(
            ([schema, toVals, fromVals]) => Param.changed(schema, toVals, fromVals)
          ).reduce(unnestR, []);
        }
        /**
         * Returns true if the transition is dynamic.
         *
         * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.
         *
         * @returns true if the Transition is dynamic
         */
        dynamic() {
          const changes = this._changedParams();
          return !changes ? false : changes.map((x) => x.dynamic).reduce(anyTrueR, false);
        }
        /**
         * Returns true if the transition is ignored.
         *
         * A transition is ignored if no states are entered nor exited, and no parameter values have changed.
         *
         * @returns true if the Transition is ignored.
         */
        ignored() {
          return !!this._ignoredReason();
        }
        _ignoredReason() {
          const pending = this.globals.transition;
          const reloadState = this._options.reloadState;
          const same = (pathA, pathB) => {
            if (pathA.length !== pathB.length) return false;
            const matching = PathUtils.matching(pathA, pathB);
            return pathA.length === matching.filter(
              (node) => !reloadState || !node.state.includes[reloadState.name]
            ).length;
          };
          const newTC = this._treeChanges;
          const pendTC = pending && pending._treeChanges;
          if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting))
            return "SameAsPending";
          if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to))
            return "SameAsCurrent";
        }
        /**
         * Runs the transition
         *
         * This method is generally called from the [[StateService.transitionTo]]
         *
         * @internal
         *
         * @returns a promise for a successful transition.
         */
        run() {
          const getHooksFor = (phase) => this._hookBuilder.buildHooksForPhase(phase);
          const transitionSuccess = () => {
            trace.traceSuccess(this.$to(), this);
            this.success = true;
            this._deferred.resolve(this.to());
            const hooks = this._hookBuilder.buildHooksForPhase(
              TransitionHookPhase.SUCCESS
            );
            hooks.forEach((hook) => {
              hook.invokeHook();
            });
          };
          const transitionError = (reason) => {
            trace.traceError(reason, this);
            this.success = false;
            this._deferred.reject(reason);
            this._error = reason;
            const hooks = getHooksFor(TransitionHookPhase.ERROR);
            hooks.forEach((hook) => hook.invokeHook());
          };
          const runTransition = () => {
            const allRunHooks = getHooksFor(TransitionHookPhase.RUN);
            const resolved = Promise.resolve();
            return TransitionHook.invokeHooks(allRunHooks, () => resolved);
          };
          const startTransition = () => {
            const globals = this.globals;
            globals.lastStartedTransitionId = this.$id;
            globals.transition = this;
            globals.transitionHistory.enqueue(this);
            trace.traceTransitionStart(this);
            return Promise.resolve();
          };
          const allBeforeHooks = getHooksFor(TransitionHookPhase.BEFORE);
          TransitionHook.invokeHooks(allBeforeHooks, startTransition).then(runTransition).then(transitionSuccess, transitionError);
          return this.promise;
        }
        /**
         * Checks if the Transition is valid
         *
         * @returns true if the Transition is valid
         */
        valid() {
          return !this.error() || this.success !== void 0;
        }
        /**
         * Aborts this transition
         *
         * Imperative API to abort a Transition.
         * This only applies to Transitions that are not yet complete.
         */
        abort() {
          if (isUndefined(this.success)) {
            this._aborted = true;
          }
        }
        /**
         * The Transition error reason.
         *
         * If the transition is invalid (and could not be run), returns the reason the transition is invalid.
         * If the transition was valid and ran, but was not successful, returns the reason the transition failed.
         *
         * @returns a transition rejection explaining why the transition is invalid, or the reason the transition failed.
         */
        error() {
          const state = this.$to();
          if (state.self.abstract) {
            return Rejection.invalid(
              `Cannot transition to abstract state '${state.name}'`
            );
          }
          const paramDefs = state.parameters();
          const values = this.params();
          const invalidParams = paramDefs.filter(
            (param) => !param.validates(values[param.id])
          );
          if (invalidParams.length) {
            const invalidValues = invalidParams.map((param) => `[${param.id}:${stringify(values[param.id])}]`).join(", ");
            const detail = `The following parameter values are not valid for state '${state.name}': ${invalidValues}`;
            return Rejection.invalid(detail);
          }
          if (this.success === false) return this._error;
        }
        /**
         * A string representation of the Transition
         *
         * @returns A string representation of the Transition
         */
        toString() {
          const fromStateOrName = this.from();
          const toStateOrName = this.to();
          const avoidEmptyHash = (params) => params["#"] !== null && params["#"] !== void 0 ? params : omit(params, ["#"]);
          const id2 = this.$id, from = isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = stringify(
            avoidEmptyHash(
              this._treeChanges.from.map((x) => x.paramValues).reduce((acc, obj) => ({ ...acc, ...obj }), {})
            )
          ), toValid = this.valid() ? "" : "(X) ", to = isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = stringify(avoidEmptyHash(this.params()));
          return `Transition#${id2}( '${from}'${fromParams} -> ${toValid}'${to}'${toParams} )`;
        }
      }
      Transition.diToken = Transition;
      function registerAddCoreResolvables(transitionService) {
        transitionService.onCreate({}, function addCoreResolvables(trans) {
          trans.addResolvable(Resolvable.fromData(Transition, trans), "");
          trans.addResolvable(Resolvable.fromData("$transition$", trans), "");
          trans.addResolvable(
            Resolvable.fromData("$stateParams", trans.params()),
            ""
          );
          trans.entering().forEach((state) => {
            trans.addResolvable(Resolvable.fromData("$state$", state), state);
          });
        });
      }
      const TRANSITION_TOKENS = ["$transition$", Transition];
      function treeChangesCleanup(trans) {
        const nodes = Object.values(trans.treeChanges()).reduce(unnestR, []).reduce(uniqR, []);
        const replaceTransitionWithNull = (r) => {
          return TRANSITION_TOKENS.includes(r.token) ? Resolvable.fromData(r.token, null) : r;
        };
        nodes.forEach((node) => {
          node.resolvables = node.resolvables.map(replaceTransitionWithNull);
        });
      }
      function makeEnterExitRetainHook(hookName) {
        return (transition, state) => {
          const _state = state.$$state();
          const hookFn = _state[hookName];
          return hookFn(transition, state);
        };
      }
      const onExitHook = makeEnterExitRetainHook("onExit");
      const registerOnExitHook = (transitionService) => transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);
      const onRetainHook = makeEnterExitRetainHook("onRetain");
      const registerOnRetainHook = (transitionService) => transitionService.onRetain(
        { retained: (state) => !!state.onRetain },
        onRetainHook
      );
      const onEnterHook = makeEnterExitRetainHook("onEnter");
      const registerOnEnterHook = (transitionService) => transitionService.onEnter(
        { entering: (state) => !!state.onEnter },
        onEnterHook
      );
      const RESOLVE_HOOK_PRIORITY = 1e3;
      const eagerResolvePath = (trans) => new ResolveContext(trans.treeChanges().to).resolvePath("EAGER", trans).then(() => {
      });
      const registerEagerResolvePath = (transitionService) => transitionService.onStart({}, eagerResolvePath, {
        priority: RESOLVE_HOOK_PRIORITY
      });
      const lazyResolveState = (trans, state) => new ResolveContext(trans.treeChanges().to).subContext(state.$$state()).resolvePath("LAZY", trans).then(() => {
      });
      const registerLazyResolveState = (transitionService) => transitionService.onEnter({ entering: val(true) }, lazyResolveState, {
        priority: RESOLVE_HOOK_PRIORITY
      });
      const resolveRemaining = (trans) => new ResolveContext(trans.treeChanges().to).resolvePath("LAZY", trans).then(() => {
      });
      const registerResolveRemaining = (transitionService) => transitionService.onFinish({}, resolveRemaining, {
        priority: RESOLVE_HOOK_PRIORITY
      });
      const loadEnteringViews = (transition) => {
        const enteringViews = transition.views("entering");
        if (!enteringViews.length) return;
        return Promise.all(
          enteringViews.map((view) => Promise.resolve(view.load()))
        ).then(() => {
        });
      };
      const registerLoadEnteringViews = (transitionService) => transitionService.onFinish({}, loadEnteringViews);
      const registerActivateViews = (transitionService, viewService) => {
        const activateViews = (transition) => {
          const enteringViews = transition.views("entering");
          const exitingViews = transition.views("exiting");
          if (!enteringViews.length && !exitingViews.length) return;
          exitingViews.forEach((vc) => viewService.deactivateViewConfig(vc));
          enteringViews.forEach((vc) => {
            viewService.activateViewConfig(vc);
          });
          viewService.sync();
        };
        transitionService.onSuccess({}, activateViews);
      };
      const updateGlobalState = (trans) => {
        const globals = trans.globals;
        const transitionSuccessful = () => {
          globals.successfulTransitions.enqueue(trans);
          globals.$current = trans.$to();
          globals.current = globals.$current.self;
          copy(trans.params(), globals.params);
        };
        const clearCurrentTransition = () => {
          if (globals.transition === trans) globals.transition = null;
        };
        trans.onSuccess({}, transitionSuccessful, { priority: 1e4 });
        trans.promise.then(clearCurrentTransition, clearCurrentTransition);
      };
      const registerUpdateGlobalState = (transitionService) => transitionService.onCreate({}, updateGlobalState);
      function registerLazyLoadHook(transitionService, stateService, urlService, stateRegistry) {
        return transitionService.onBefore(
          { entering: (state) => !!state.lazyLoad },
          (transition) => {
            function retryTransition() {
              if (transition.originalTransition().options().source !== "url") {
                const orig = transition.targetState();
                return stateService.target(
                  orig.identifier(),
                  orig.params(),
                  orig.options()
                );
              }
              const result = urlService.match(urlService.parts());
              const rule = result && result.rule;
              if (rule && rule.type === "STATE") {
                const state = rule.state;
                const params = result.match;
                return stateService.target(state, params, transition.options());
              }
              urlService.sync();
            }
            const promises = transition.entering().filter((state) => !!state.$$state().lazyLoad).map((state) => lazyLoadState(transition, state, stateRegistry));
            return Promise.all(promises).then(retryTransition);
          }
        );
      }
      function lazyLoadState(transition, state, stateRegistry) {
        const lazyLoadFn = state.$$state().lazyLoad;
        let promise = lazyLoadFn["_promise"];
        if (!promise) {
          const success = (result) => {
            delete state.lazyLoad;
            delete state.$$state().lazyLoad;
            delete lazyLoadFn["_promise"];
            return result;
          };
          const error = (err2) => {
            delete lazyLoadFn["_promise"];
            return Promise.reject(err2);
          };
          promise = lazyLoadFn["_promise"] = Promise.resolve(
            lazyLoadFn(transition, state)
          ).then(updateStateRegistry).then(success, error);
        }
        function updateStateRegistry(result) {
          if (result && Array.isArray(result.states)) {
            result.states.forEach((_state) => stateRegistry.register(_state));
          }
          return result;
        }
        return promise;
      }
      class TransitionEventType {
        constructor(name2, hookPhase, hookOrder, criteriaMatchPath, reverseSort = false, getResultHandler = TransitionHook.HANDLE_RESULT, getErrorHandler = TransitionHook.REJECT_ERROR, synchronous = false) {
          this.name = name2;
          this.hookPhase = hookPhase;
          this.hookOrder = hookOrder;
          this.criteriaMatchPath = criteriaMatchPath;
          this.reverseSort = reverseSort;
          this.getResultHandler = getResultHandler;
          this.getErrorHandler = getErrorHandler;
          this.synchronous = synchronous;
        }
      }
      function ignoredHook(trans) {
        const ignoredReason = trans._ignoredReason();
        if (!ignoredReason) return;
        trace.traceTransitionIgnored(trans);
        const pending = trans.globals.transition;
        if (ignoredReason === "SameAsCurrent" && pending) {
          pending.abort();
        }
        return Rejection.ignored().toPromise();
      }
      const registerIgnoredTransitionHook = (transitionService) => transitionService.onBefore({}, ignoredHook, { priority: -9999 });
      function invalidTransitionHook(trans) {
        if (!trans.valid()) {
          throw new Error(trans.error().toString());
        }
      }
      const registerInvalidTransitionHook = (transitionService) => transitionService.onBefore({}, invalidTransitionHook, { priority: -1e4 });
      const registerRedirectToHook = (transitionService, stateService) => {
        const redirectToHook = (trans) => {
          const redirect = trans.to().redirectTo;
          if (!redirect) return;
          const $state = stateService;
          function handleResult(result) {
            if (!result) return;
            if (result instanceof TargetState) return result;
            if (isString(result))
              return $state.target(result, trans.params(), trans.options());
            if (result["state"] || result["params"])
              return $state.target(
                result["state"] || trans.to(),
                result["params"] || trans.params(),
                trans.options()
              );
          }
          if (isFunction(redirect)) {
            return Promise.resolve(redirect(trans)).then(handleResult);
          }
          return handleResult(redirect);
        };
        transitionService.onStart(
          { to: (state) => !!state.redirectTo },
          redirectToHook
        );
      };
      const registerUpdateUrl = (transitionService, stateService, urlService) => {
        const updateUrl = (transition) => {
          const options = transition.options();
          const $state = stateService;
          if (options.source !== "url" && options.location && $state.$current.navigable) {
            const urlOptions = { replace: options.location === "replace" };
            urlService.push(
              $state.$current.navigable.url,
              $state.globals.params,
              urlOptions
            );
          }
          urlService.update(true);
        };
        transitionService.onSuccess({}, updateUrl, { priority: 9999 });
      };
      let defaultTransOpts = {
        location: true,
        relative: null,
        inherit: false,
        notify: true,
        reload: false,
        supercede: true,
        custom: {},
        current: () => null,
        source: "unknown"
      };
      class TransitionProvider {
        /* @ignore */
        static $inject = provider([$injectTokens.$router, $injectTokens.$view]);
        /**
         * @param {import('../router.js').Router} globals
         * @param viewService
         */
        constructor(globals, viewService) {
          this._transitionCount = 0;
          this._eventTypes = [];
          this._registeredHooks = {};
          this._criteriaPaths = {};
          this.globals = globals;
          this.$view = viewService;
          this._deregisterHookFns = {};
          this._pluginapi = createProxyFunctions(val(this), {}, val(this), [
            "_definePathType",
            "_defineEvent",
            "_getPathTypes",
            "_getEvents",
            "getHooks"
          ]);
          this._defineCorePaths();
          this._defineCoreEvents();
          this._registerCoreTransitionHooks();
          globals.successfulTransitions.onEvict(treeChangesCleanup);
        }
        $get = [
          $injectTokens.$state,
          $injectTokens.$url,
          $injectTokens.$stateRegistry,
          $injectTokens.$view,
          (stateService, urlService, stateRegistry, viewService) => {
            this._deregisterHookFns.lazyLoad = registerLazyLoadHook(
              this,
              stateService,
              urlService,
              stateRegistry
            );
            this._deregisterHookFns.updateUrl = registerUpdateUrl(
              this,
              stateService,
              urlService
            );
            this._deregisterHookFns.redirectTo = registerRedirectToHook(
              this,
              stateService
            );
            this._deregisterHookFns.activateViews = registerActivateViews(
              this,
              viewService
            );
            return this;
          }
        ];
        /**
         * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.
         *
         * Registers a transition lifecycle hook, which is invoked during transition construction.
         *
         * This low level hook should only be used by plugins.
         * This can be a useful time for plugins to add resolves or mutate the transition as needed.
         * The Sticky States plugin uses this hook to modify the treechanges.
         *
         * ### Lifecycle
         *
         * `onCreate` hooks are invoked *while a transition is being constructed*.
         *
         * ### Return value
         *
         * The hook's return value is ignored
         *
         * @internal
         * @param criteria defines which Transitions the Hook should be invoked for.
         * @param callback the hook function which will be invoked.
         * @param options the registration options
         * @returns a function which deregisters the hook.
         */
        /**
         * Creates a new [[Transition]] object
         *
         * This is a factory function for creating new Transition objects.
         * It is used internally by the [[StateService]] and should generally not be called by application code.
         *
         * @internal
         * @param fromPath the path to the current state (the from state)
         * @param targetState the target state (destination)
         * @returns a Transition
         */
        create(fromPath, targetState) {
          return new Transition(fromPath, targetState, this, this.globals);
        }
        _defineCoreEvents() {
          const Phase = TransitionHookPhase;
          const TH = TransitionHook;
          const paths = this._criteriaPaths;
          const NORMAL_SORT = false, REVERSE_SORT = true;
          const SYNCHRONOUS = true;
          this._defineEvent(
            "onCreate",
            Phase.CREATE,
            0,
            paths.to,
            NORMAL_SORT,
            TH.LOG_REJECTED_RESULT,
            TH.THROW_ERROR,
            SYNCHRONOUS
          );
          this._defineEvent("onBefore", Phase.BEFORE, 0, paths.to);
          this._defineEvent("onStart", Phase.RUN, 0, paths.to);
          this._defineEvent("onExit", Phase.RUN, 100, paths.exiting, REVERSE_SORT);
          this._defineEvent("onRetain", Phase.RUN, 200, paths.retained);
          this._defineEvent("onEnter", Phase.RUN, 300, paths.entering);
          this._defineEvent("onFinish", Phase.RUN, 400, paths.to);
          this._defineEvent(
            "onSuccess",
            Phase.SUCCESS,
            0,
            paths.to,
            NORMAL_SORT,
            TH.LOG_REJECTED_RESULT,
            TH.LOG_ERROR,
            SYNCHRONOUS
          );
          this._defineEvent(
            "onError",
            Phase.ERROR,
            0,
            paths.to,
            NORMAL_SORT,
            TH.LOG_REJECTED_RESULT,
            TH.LOG_ERROR,
            SYNCHRONOUS
          );
        }
        _defineCorePaths() {
          const { STATE, TRANSITION } = TransitionHookScope;
          this._definePathType("to", TRANSITION);
          this._definePathType("from", TRANSITION);
          this._definePathType("exiting", STATE);
          this._definePathType("retained", STATE);
          this._definePathType("entering", STATE);
        }
        _defineEvent(name2, hookPhase, hookOrder, criteriaMatchPath, reverseSort = false, getResultHandler = TransitionHook.HANDLE_RESULT, getErrorHandler = TransitionHook.REJECT_ERROR, synchronous = false) {
          const eventType = new TransitionEventType(
            name2,
            hookPhase,
            hookOrder,
            criteriaMatchPath,
            reverseSort,
            getResultHandler,
            getErrorHandler,
            synchronous
          );
          this._eventTypes.push(eventType);
          makeEvent(this, this, eventType);
        }
        _getEvents(phase) {
          const transitionHookTypes = isDefined(phase) ? this._eventTypes.filter((type) => type.hookPhase === phase) : this._eventTypes.slice();
          return transitionHookTypes.sort((l, r) => {
            const cmpByPhase = l.hookPhase - r.hookPhase;
            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;
          });
        }
        /**
         * Adds a Path to be used as a criterion against a TreeChanges path
         *
         * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.
         * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`
         * Each state in the exiting path is checked against the criteria and returned as part of the match.
         *
         * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.
         * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`
         * Only the tail of the `to` path is checked against the criteria and returned as part of the match.
         *
         * @internal
         */
        _definePathType(name2, hookScope) {
          this._criteriaPaths[name2] = { name: name2, scope: hookScope };
        }
        _getPathTypes() {
          return this._criteriaPaths;
        }
        getHooks(hookName) {
          return this._registeredHooks[hookName];
        }
        _registerCoreTransitionHooks() {
          const fns = this._deregisterHookFns;
          fns.addCoreResolves = registerAddCoreResolvables(this);
          fns.ignored = registerIgnoredTransitionHook(this);
          fns.invalid = registerInvalidTransitionHook(this);
          fns.onExit = registerOnExitHook(this);
          fns.onRetain = registerOnRetainHook(this);
          fns.onEnter = registerOnEnterHook(this);
          fns.eagerResolve = registerEagerResolvePath(this);
          fns.lazyResolve = registerLazyResolveState(this);
          fns.resolveAll = registerResolveRemaining(this);
          fns.loadViews = registerLoadEnteringViews(this);
          fns.updateGlobals = registerUpdateGlobalState(this);
          fns.lazyLoad = registerLazyLoadHook(this);
        }
      }
      const err = minErr("$stateProvider");
      class StateProvider {
        /**
         * The latest successful state parameters
         *
         * @deprecated This is a passthrough through to [[Router.params]]
         */
        get params() {
          return this.globals.params;
        }
        /**
         * The current [[StateDeclaration]]
         *
         * @deprecated This is a passthrough through to [[Router.current]]
         */
        get current() {
          return this.globals.current;
        }
        /**
         * The current [[StateObject]] (an internal API)
         *
         * @deprecated This is a passthrough through to [[Router.$current]]
         */
        get $current() {
          return this.globals.$current;
        }
        static $inject = ["$routerProvider", "$transitionsProvider"];
        /**
         *
         * @param {import('../router.js').Router} globals
         * @param {*} transitionService
         * @param {import('../../core/di/internal-injector.js').InjectorService} $injector
         */
        constructor(globals, transitionService, $injector) {
          this.stateRegistry = void 0;
          this.urlService = void 0;
          this.globals = globals;
          this.transitionService = transitionService;
          this.$injector = $injector;
          this.invalidCallbacks = [];
          this._defaultErrorHandler = function $defaultErrorHandler($error$) {
            if ($error$ instanceof Error && $error$.stack) {
              throw $error$;
            } else if ($error$ instanceof Rejection) {
              throw new Error($error$.toString());
            } else {
              throw new Error($error$);
            }
          };
          const getters = ["current", "$current", "params", "transition"];
          const boundFns = Object.keys(StateProvider.prototype).filter(
            (x) => !getters.includes(x)
          );
          createProxyFunctions(
            val(StateProvider.prototype),
            this,
            val(this),
            boundFns
          );
          EventBus.subscribe(
            "$stateService:defaultErrorHandler",
            (err2) => this.defaultErrorHandler()(err2)
          );
        }
        $get = () => this;
        /**
         * Decorates states when they are registered
         *
         * Allows you to extend (carefully) or override (at your own peril) the
         * `stateBuilder` object used internally by [[StateRegistry]].
         * This can be used to add custom functionality to ng-router,
         * for example inferring templateUrl based on the state name.
         *
         * When passing only a name, it returns the current (original or decorated) builder
         * function that matches `name`.
         *
         * The builder functions that can be decorated are listed below. Though not all
         * necessarily have a good use case for decoration, that is up to you to decide.
         *
         * In addition, users can attach custom decorators, which will generate new
         * properties within the state's internal definition. There is currently no clear
         * use-case for this beyond accessing internal states (i.e. $state.$current),
         * however, expect this to become increasingly relevant as we introduce additional
         * meta-programming features.
         *
         * **Warning**: Decorators should not be interdependent because the order of
         * execution of the builder functions in non-deterministic. Builder functions
         * should only be dependent on the state definition object and super function.
         *
         *
         * Existing builder functions and current return values:
         *
         * - **parent** `{object}` - returns the parent state object.
         * - **data** `{object}` - returns state data, including any inherited data that is not
         *   overridden by own values (if any).
         * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}
         *   or `null`.
         * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is
         *   navigable).
         * - **params** `{object}` - returns an array of state params that are ensured to
         *   be a super-set of parent's params.
         * - **views** `{object}` - returns a views object where each key is an absolute view
         *   name (i.e. "viewName@stateName") and each value is the urlConfig object
         *   (template, controller) for the view. Even when you don't use the views object
         *   explicitly on a state urlConfig, one is still created for you internally.
         *   So by decorating this builder function you have access to decorating template
         *   and controller properties.
         * - **ownParams** `{object}` - returns an array of params that belong to the state,
         *   not including any params defined by ancestor states.
         * - **path** `{string}` - returns the full path from the root down to this state.
         *   Needed for state activation.
         * - **includes** `{object}` - returns an object that includes every state that
         *   would pass a `$state.includes()` test.
         *
         * #### Example:
         * Override the internal 'views' builder with a function that takes the state
         * definition, and a reference to the internal function being overridden:
         * ```js
         * $stateProvider.decorator('views', function (state, parent) {
         *   let result = {},
         *       views = parent(state);
         *
         *   angular.forEach(views, function (urlConfig, name) {
         *     let autoName = (state.name + '.' + name).replace('.', '/');
         *     urlConfig.templateUrl = urlConfig.templateUrl || '/partials/' + autoName + '.html';
         *     result[name] = urlConfig;
         *   });
         *   return result;
         * });
         *
         * $stateProvider.state('home', {
         *   views: {
         *     'contact.list': { controller: 'ListController' },
         *     'contact.item': { controller: 'ItemController' }
         *   }
         * });
         * ```
         *
         *
         * ```js
         * // Auto-populates list and item views with /partials/home/contact/list.html,
         * // and /partials/home/contact/item.html, respectively.
         * $state.go('home');
         * ```
         *
         * @param {string} name The name of the builder function to decorate.
         * @param {object} func A function that is responsible for decorating the original
         * builder function. The function receives two parameters:
         *
         *   - `{object}` - state - The state urlConfig object.
         *   - `{object}` - super - The original builder function.
         *
         * @return {object} $stateProvider - $stateProvider instance
         */
        decorator(name2, func) {
          return this.stateRegistry.decorator(name2, func) || this;
        }
        /**
         *
         * @param {import("./interface.js").StateDeclaration} definition
         */
        state(definition) {
          if (!definition.name) {
            throw err("stateinvalid", `'name' required`);
          }
          try {
            this.stateRegistry.register(definition);
          } catch (e) {
            throw err("stateinvalid", e.message);
          }
          return this;
        }
        /**
         * Handler for when [[transitionTo]] is called with an invalid state.
         *
         * Invokes the [[onInvalid]] callbacks, in natural order.
         * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.
         * The results of the callbacks are wrapped in Promise.resolve(), so the callbacks may return promises.
         *
         * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.
         *
         * @internal
         */
        _handleInvalidTargetState(fromPath, toState) {
          const fromState = makeTargetState(this.stateRegistry, fromPath);
          const globals = this.globals;
          const latestThing = () => globals.transitionHistory.peekTail();
          const latest = latestThing();
          const callbackQueue = new Queue(this.invalidCallbacks.slice());
          const injector = this.$injector;
          const checkForRedirect = (result) => {
            if (!(result instanceof TargetState)) {
              return;
            }
            let target = result;
            target = this.target(
              target.identifier(),
              target.params(),
              target.options()
            );
            if (!target.valid()) {
              return Rejection.invalid(target.error()).toPromise();
            }
            if (latestThing() !== latest) {
              return Rejection.superseded().toPromise();
            }
            return this.transitionTo(
              target.identifier(),
              target.params(),
              target.options()
            );
          };
          function invokeNextCallback() {
            const nextCallback = callbackQueue.dequeue();
            if (nextCallback === void 0)
              return Rejection.invalid(toState.error()).toPromise();
            const callbackResult = Promise.resolve(
              nextCallback(toState, fromState, injector)
            );
            return callbackResult.then(checkForRedirect).then((result) => result || invokeNextCallback());
          }
          return invokeNextCallback();
        }
        /**
         * Registers an Invalid State handler
         *
         * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]
         * has been called with an invalid state reference parameter
         *
         * Example:
         * ```js
         * stateService.onInvalid(function(to, from, injector) {
         *   if (to.name() === 'foo') {
         *     let lazyLoader = injector.get('LazyLoadService');
         *     return lazyLoader.load('foo')
         *         .then(() => stateService.target('foo'));
         *   }
         * });
         * ```
         *
         * @param {function} callback invoked when the toState is invalid
         *   This function receives the (invalid) toState, the fromState, and an injector.
         *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.
         *   If one is returned, it is treated as a redirect.
         *
         * @returns a function which deregisters the callback
         */
        onInvalid(callback) {
          this.invalidCallbacks.push(callback);
          return (function deregisterListener() {
            removeFrom(this.invalidCallbacks)(callback);
          }).bind(this);
        }
        /**
         * Reloads the current state
         *
         * A method that force reloads the current state, or a partial state hierarchy.
         * All resolves are re-resolved, and components reinstantiated.
         *
         * #### Example:
         * ```js
         * let app angular.module('app', ['ui.router']);
         *
         * app.controller('ctrl', function ($scope, $state) {
         *   $scope.reload = function(){
         *     $state.reload();
         *   }
         * });
         * ```
         *
         * Note: `reload()` is just an alias for:
         *
         * ```js
         * $state.transitionTo($state.current, $state.params, {
         *   reload: true, inherit: false
         * });
         * ```
         *
         * @param reloadState A state name or a state object.
         *    If present, this state and all its children will be reloaded, but ancestors will not reload.
         *
         * #### Example:
         * ```js
         * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'
         * //and current state is 'contacts.detail.item'
         * let app angular.module('app', ['ui.router']);
         *
         * app.controller('ctrl', function ($scope, $state) {
         *   $scope.reload = function(){
         *     //will reload 'contact.detail' and nested 'contact.detail.item' states
         *     $state.reload('contact.detail');
         *   }
         * });
         * ```
         *
         * @returns A promise representing the state of the new transition. See [[StateService.go]]
         */
        reload(reloadState) {
          return this.transitionTo(this.globals.current, this.globals.params, {
            reload: isDefined(reloadState) ? reloadState : true,
            inherit: false,
            notify: false
          });
        }
        /**
         * Transition to a different state and/or parameters
         *
         * Convenience method for transitioning to a new state.
         *
         * `$state.go` calls `$state.transitionTo` internally but automatically sets options to
         * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.
         * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).
         * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters
         * inherit from the current parameter values (because of `inherit: true`).
         *
         * #### Example:
         * ```js
         * let app = angular.module('app', ['ui.router']);
         *
         * app.controller('ctrl', function ($scope, $state) {
         *   $scope.changeState = function () {
         *     $state.go('contact.detail');
         *   };
         * });
         * ```
         *
         * @param to Absolute state name, state object, or relative state path (relative to current state).
         *
         * Some examples:
         *
         * - `$state.go('contact.detail')` - will go to the `contact.detail` state
         * - `$state.go('^')` - will go to the parent state
         * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state
         * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state
         *
         * @param params A map of the parameters that will be sent to the state, will populate $stateParams.
         *
         *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).
         *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.
         *
         * @param options Transition options
         *
         * @returns {promise} A promise representing the state of the new transition.
         */
        go(to, params, options) {
          const defautGoOpts = { relative: this.$current, inherit: true };
          const transOpts = defaults(options, defautGoOpts, defaultTransOpts);
          return this.transitionTo(to, params, transOpts);
        }
        /**
         * Creates a [[TargetState]]
         *
         * This is a factory method for creating a TargetState
         *
         * This may be returned from a Transition Hook to redirect a transition, for example.
         */
        target(identifier, params, options = {}) {
          if (isObject(options.reload) && !options.reload.name)
            throw new Error("Invalid reload state object");
          const reg = this.stateRegistry;
          options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);
          if (options.reload && !options.reloadState)
            throw new Error(
              `No such reload state '${isString(options.reload) ? options.reload : options.reload.name}'`
            );
          return new TargetState(this.stateRegistry, identifier, params, options);
        }
        getCurrentPath() {
          const globals = this.globals;
          const latestSuccess = globals.successfulTransitions.peekTail();
          const rootPath = () => [new PathNode(this.stateRegistry.root())];
          return latestSuccess ? latestSuccess._treeChanges.to : rootPath();
        }
        /**
         * Low-level method for transitioning to a new state.
         *
         * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.
         *
         * #### Example:
         * ```js
         * let app = angular.module('app', ['ui.router']);
         *
         * app.controller('ctrl', function ($scope, $state) {
         *   $scope.changeState = function () {
         *     $state.transitionTo('contact.detail');
         *   };
         * });
         * ```
         *
         * @param to State name or state object.
         * @param toParams A map of the parameters that will be sent to the state,
         *      will populate $stateParams.
         * @param options Transition options
         *
         * @returns A promise representing the state of the new transition. See [[go]]
         */
        transitionTo(to, toParams = {}, options = {}) {
          options = defaults(options, defaultTransOpts);
          const getCurrent = () => this.globals.transition;
          options = Object.assign(options, { current: getCurrent });
          const ref = this.target(to, toParams, options);
          const currentPath = this.getCurrentPath();
          if (!ref.exists()) return this._handleInvalidTargetState(currentPath, ref);
          if (!ref.valid()) return silentRejection(ref.error());
          if (options.supercede === false && getCurrent()) {
            return Rejection.ignored(
              "Another transition is in progress and supercede has been set to false in TransitionOptions for the transition. So the transition was ignored in favour of the existing one in progress."
            ).toPromise();
          }
          const rejectedTransitionHandler = (trans) => (error) => {
            if (error instanceof Rejection) {
              const isLatest = this.globals.lastStartedTransitionId <= trans.$id;
              if (error.type === RejectType.IGNORED) {
                isLatest && this.urlService.update();
                return Promise.resolve(this.globals.current);
              }
              const detail = error.detail;
              if (error.type === RejectType.SUPERSEDED && error.redirected && detail instanceof TargetState) {
                const redirect = trans.redirect(detail);
                return redirect.run().catch(rejectedTransitionHandler(redirect));
              }
              if (error.type === RejectType.ABORTED) {
                isLatest && this.urlService.update();
                return Promise.reject(error);
              }
            }
            const errorHandler = this.defaultErrorHandler();
            errorHandler(error);
            return Promise.reject(error);
          };
          const transition = this.transitionService.create(currentPath, ref);
          const transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));
          silenceUncaughtInPromise(transitionToPromise);
          return Object.assign(transitionToPromise, { transition });
        }
        /**
         * Checks if the current state *is* the provided state
         *
         * Similar to [[includes]] but only checks for the full state name.
         * If params is supplied then it will be tested for strict equality against the current
         * active params object, so all params must match with none missing and no extras.
         *
         * #### Example:
         * ```js
         * $state.$current.name = 'contacts.details.item';
         *
         * // absolute name
         * $state.is('contact.details.item'); // returns true
         * $state.is(contactDetailItemStateObject); // returns true
         * ```
         *
         * // relative name (. and ^), typically from a template
         * // E.g. from the 'contacts.details' template
         * ```html
         * <div ng-class="{highlighted: $state.is('.item')}">Item</div>
         * ```
         *
         * @param stateOrName The state name (absolute or relative) or state object you'd like to check.
         * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like
         * to test against the current active state.
         * @param options An options object. The options are:
         *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will
         *     test relative to `options.relative` state (or name).
         *
         * @returns Returns true if it is the state.
         */
        is(stateOrName, params, options) {
          options = defaults(options, { relative: this.$current });
          const state = this.stateRegistry.matcher.find(
            stateOrName,
            options.relative
          );
          if (!isDefined(state)) return void 0;
          if (this.$current !== state) return false;
          if (!params) return true;
          const schema = state.parameters({ inherit: true, matchingKeys: params });
          return Param.equals(
            schema,
            Param.values(schema, params),
            this.globals.params
          );
        }
        /**
         * Checks if the current state *includes* the provided state
         *
         * A method to determine if the current active state is equal to or is the child of the
         * state stateName. If any params are passed then they will be tested for a match as well.
         * Not all the parameters need to be passed, just the ones you'd like to test for equality.
         *
         * #### Example when `$state.$current.name === 'contacts.details.item'`
         * ```js
         * // Using partial names
         * $state.includes("contacts"); // returns true
         * $state.includes("contacts.details"); // returns true
         * $state.includes("contacts.details.item"); // returns true
         * $state.includes("contacts.list"); // returns false
         * $state.includes("about"); // returns false
         * ```
         *
         * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:
         * ```js
         * $state.includes("*.details.*.*"); // returns true
         * $state.includes("*.details.**"); // returns true
         * $state.includes("**.item.**"); // returns true
         * $state.includes("*.details.item.url"); // returns true
         * $state.includes("*.details.*.url"); // returns true
         * $state.includes("*.details.*"); // returns false
         * $state.includes("item.**"); // returns false
         * ```
         *
         * @param stateOrName A partial name, relative name, glob pattern,
         *   or state object to be searched for within the current state name.
         * @param params A param object, e.g. `{sectionId: section.id}`,
         *   that you'd like to test against the current active state.
         * @param options An options object. The options are:
         *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will
         *     test relative to `options.relative` state (or name).
         *
         * @returns {boolean} Returns true if it does include the state
         */
        includes(stateOrName, params, options) {
          options = defaults(options, { relative: this.$current });
          const glob = isString(stateOrName) && Glob.fromString(stateOrName);
          if (glob) {
            if (!glob.matches(this.$current.name)) return false;
            stateOrName = this.$current.name;
          }
          const state = this.stateRegistry.matcher.find(
            stateOrName,
            options.relative
          );
          const include = this.$current.includes;
          if (!isDefined(state)) return void 0;
          if (!isDefined(include[state.name])) return false;
          if (!params) return true;
          const schema = state.parameters({ inherit: true, matchingKeys: params });
          return Param.equals(
            schema,
            Param.values(schema, params),
            this.globals.params
          );
        }
        /**
         * Generates a URL for a state and parameters
         *
         * Returns the url for the given state populated with the given params.
         *
         * #### Example:
         * ```js
         * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
         * ```
         *
         * @param stateOrName The state name or state object you'd like to generate a url from.
         * @param params An object of parameter values to fill the state's required parameters.
         * @param options Options object. The options are:
         *
         * @returns {string} compiled state url
         */
        href(stateOrName, params, options) {
          const defaultHrefOpts = {
            lossy: true,
            inherit: true,
            absolute: false,
            relative: this.$current
          };
          options = defaults(options, defaultHrefOpts);
          params = params || {};
          const state = this.stateRegistry.matcher.find(
            stateOrName,
            options.relative
          );
          if (!isDefined(state)) return null;
          if (options.inherit)
            params = this.globals.params.$inherit(params, this.$current, state);
          const nav = state && options.lossy ? state.navigable : state;
          if (!nav || nav.url === void 0 || nav.url === null) {
            return null;
          }
          return this.urlService.href(nav.url, params, {
            absolute: options.absolute
          });
        }
        /**
         * Sets or gets the default [[transitionTo]] error handler.
         *
         * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.
         * This includes errors caused by resolves and transition hooks.
         *
         * Note:
         * This handler does not receive certain Transition rejections.
         * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].
         *
         * The built-in default error handler logs the error to the console.
         *
         * You can provide your own custom handler.
         *
         * #### Example:
         * ```js
         * stateService.defaultErrorHandler(function() {
         *   // Do not log transitionTo errors
         * });
         * ```
         *
         * @param handler a global error handler function
         * @returns the current global error handler
         */
        defaultErrorHandler(handler) {
          return this._defaultErrorHandler = handler || this._defaultErrorHandler;
        }
        get(stateOrName, base) {
          const reg = this.stateRegistry;
          if (arguments.length === 0) return reg.get();
          return reg.get(stateOrName, base || this.$current);
        }
        /**
         * Lazy loads a state
         *
         * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.
         *
         * @param stateOrName the state that should be lazy loaded
         * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)
         * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.
         * This noop transition is not actually run.
         *
         * @returns a promise to lazy load
         */
        lazyLoad(stateOrName, transition) {
          const state = this.get(stateOrName);
          if (!state || !state.lazyLoad)
            throw new Error("Can not lazy load " + stateOrName);
          const currentPath = this.getCurrentPath();
          const target = makeTargetState(this.stateRegistry, currentPath);
          transition = transition || this.transitionService.create(currentPath, target);
          return lazyLoadState(transition, state);
        }
      }
      class ViewScrollProvider {
        constructor() {
          this.enabled = false;
        }
        useAnchorScroll() {
          this.enabled = true;
        }
        $get = [
          $injectTokens.$anchorScroll,
          /**
           * @param {import('../services/anchor-scroll.js').AnchorScrollObject} $anchorScroll
           * @returns {import('../services/anchor-scroll.js').AnchorScrollObject|Function}
           */
          ($anchorScroll) => {
            if (this.enabled) {
              return $anchorScroll;
            }
            return async function($element) {
              return setTimeout(() => {
                $element.scrollIntoView(false);
              }, 0);
            };
          }
        ];
      }
      class TemplateFactoryProvider {
        constructor() {
          this._useHttp = false;
        }
        $get = [
          $injectTokens.$http,
          $injectTokens.$templateCache,
          $injectTokens.$templateRequest,
          $injectTokens.$injector,
          /**
           * @param {import("interface.ts").HttpService} $http
           * @param {import("../services/template-cache/interface.ts").TemplateCache} $templateCache
           * @param {any} $templateRequest
           * @param {import("../core/di/internal-injector.js").InjectorService} $injector
           * @returns
           */
          ($http, $templateCache, $templateRequest, $injector) => {
            this.$templateRequest = $templateRequest;
            this.$http = $http;
            this.$templateCache = $templateCache;
            this.$injector = $injector;
            return this;
          }
        ];
        /**
         * Forces the provider to use $http service directly
         * @param {boolean} value
         */
        useHttpService(value) {
          this._useHttp = value;
        }
        /**
         * Creates a template from a configuration object.
         *
         * @param config Configuration object for which to load a template.
         * The following properties are search in the specified order, and the first one
         * that is defined is used to create the template:
         *
         * @param {any} config
         * @param {any} params  Parameters to pass to the template function.
         * @param {import("./resolve/resolve-context.js").ResolveContext} context The resolve context associated with the template's view
         *
         * @return {string|object}  The template html as a string, or a promise for
         * that string,or `null` if no template is configured.
         */
        fromConfig(config, params, context) {
          const defaultTemplate = "<ng-view></ng-view>";
          const asTemplate = (result) => Promise.resolve(result).then((str) => ({ template: str }));
          const asComponent = (result) => Promise.resolve(result).then((str) => ({ component: str }));
          const getConfigType = (config2) => {
            if (isDefined(config2.template)) return "template";
            if (isDefined(config2.templateUrl)) return "templateUrl";
            if (isDefined(config2.templateProvider)) return "templateProvider";
            if (isDefined(config2.component)) return "component";
            if (isDefined(config2.componentProvider)) return "componentProvider";
            return "default";
          };
          switch (getConfigType(config)) {
            case "template":
              return asTemplate(this.fromString(config.template, params));
            case "templateUrl":
              return asTemplate(this.fromUrl(config.templateUrl, params));
            case "templateProvider":
              return asTemplate(
                this.fromProvider(config.templateProvider, params, context)
              );
            case "component":
              return asComponent(config.component);
            case "componentProvider":
              return asComponent(
                this.fromComponentProvider(config.componentProvider, context)
              );
            default:
              return asTemplate(defaultTemplate);
          }
        }
        /**
         * Creates a template from a string or a function returning a string.
         *
         * @param {string | Function} template html template as a string or function that returns an html template as a string.
         * @param {any} [params] Parameters to pass to the template function.
         *
         * @return {string|object} The template html as a string, or a promise for that
         * string.
         */
        fromString(template, params) {
          return isFunction(template) ? (
            /** @type {Function} */
            template(params)
          ) : template;
        }
        /**
         * Loads a template from the a URL via `$http` and `$templateCache`.
         *
         * @param {string|Function} url url of the template to load, or a function
         * that returns a url.
         * @param {Object} params Parameters to pass to the url function.
         * @return {string|Promise.<string>} The template html as a string, or a promise
         * for that string.
         */
        fromUrl(url, params) {
          if (isFunction(url)) url = /** @type {Function} */
          url(params);
          if (url == null) return null;
          if (this._useHttp) {
            return this.$http.get(
              /** @type {string} */
              url,
              {
                cache: this.$templateCache,
                headers: { Accept: "text/html" }
              }
            ).then(function(response) {
              return response.data;
            });
          }
          return this.$templateRequest(url);
        }
        /**
         * Creates a template by invoking an injectable provider function.
         *
         * @param {import('../interface.ts').Injectable} provider Function to invoke via `locals`
         * @param {Function} params a function used to invoke the template provider
         * @param {import("./resolve/resolve-context.js").ResolveContext} context
         * @return {string|Promise.<string>} The template html as a string, or a promise
         * for that string.
         */
        fromProvider(provider2, params, context) {
          const deps = annotate(provider2);
          const providerFn = Array.isArray(provider2) ? tail(provider2) : provider2;
          const resolvable = new Resolvable("", providerFn, deps);
          return resolvable.get(context);
        }
        /**
         * Creates a component's template by invoking an injectable provider function.
         *
         * @param {import('../interface.ts').Injectable} provider Function to invoke via `locals`
         * @return {Promise<any>} The template html as a string: "<component-name input1='::$resolve.foo'></component-name>".
         */
        fromComponentProvider(provider2, context) {
          const deps = annotate(provider2);
          const providerFn = Array.isArray(provider2) ? tail(provider2) : provider2;
          const resolvable = new Resolvable("", providerFn, deps);
          return resolvable.get(context);
        }
        /**
         * Creates a template from a component's name
         *
         * This implements route-to-component.
         * It works by retrieving the component (directive) metadata from the injector.
         * It analyses the component's bindings, then constructs a template that instantiates the component.
         * The template wires input and output bindings to resolves or from the parent component.
         *
         * @param {any} ngView {object} The parent ng-view (for binding outputs to callbacks)
         * @param {import("./resolve/resolve-context.js").ResolveContext} context The ResolveContext (for binding outputs to callbacks returned from resolves)
         * @param {string} component {string} Component's name in camel case.
         * @param {any} [bindings] An object defining the component's bindings: {foo: '<'}
         * @return {string} The template as a string: "<component-name input1='$resolve.foo'></component-name>".
         */
        makeComponentTemplate(ngView2, context, component, bindings) {
          bindings = bindings || {};
          const kebob = (camelCase) => {
            const kebobed = kebobString(camelCase);
            return /^(x|data)-/.exec(kebobed) ? `x-${kebobed}` : kebobed;
          };
          const attributeTpl = (
            /** @param {BindingTuple} input*/
            (input) => {
              const { name: name2, type } = input;
              const attrName = kebob(name2);
              if (ngView2.getAttribute(attrName) && !bindings[name2])
                return `${attrName}='${ngView2.getAttribute(attrName)}'`;
              const resolveName = bindings[name2] || name2;
              if (type === "@") return `${attrName}='{{s$resolve.${resolveName}}}'`;
              if (type === "&") {
                const res = context.getResolvable(resolveName);
                const fn = res && res.data;
                const args = fn && annotate(fn) || [];
                const arrayIdxStr = Array.isArray(fn) ? `[${fn.length - 1}]` : "";
                return `${attrName}='$resolve.${resolveName}${arrayIdxStr}(${args.join(",")})'`;
              }
              return `${attrName}='$resolve.${resolveName}'`;
            }
          );
          const attrs = getComponentBindings(this.$injector, component).map(attributeTpl).join(" ");
          const kebobName = kebob(component);
          return `<${kebobName} ${attrs}></${kebobName}>`;
        }
      }
      function getComponentBindings($injector, name2) {
        const cmpDefs = $injector.get(name2 + DirectiveSuffix);
        if (!cmpDefs || !cmpDefs.length)
          throw new Error(`Unable to find component named '${name2}'`);
        return cmpDefs.map(getBindings).reduce(unnestR, []);
      }
      const getBindings = (def) => {
        if (isObject(def.bindToController))
          return scopeBindings(def.bindToController);
        return scopeBindings(def.scope);
      };
      const scopeBindings = (bindingsObj) => Object.keys(bindingsObj || {}).map((key) => [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])]).filter((tuple) => isDefined(tuple) && Array.isArray(tuple[1])).map((tuple) => ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }));
      function quoteRegExp(str, param) {
        let surroundPattern = ["", ""];
        let result = str.replace(/[\\[\]^$*+?.()|{}]/g, "\\$&");
        if (!param) return result;
        switch (param.squash) {
          case false:
            surroundPattern = ["(", ")" + (param.isOptional ? "?" : "")];
            break;
          case true:
            result = result.replace(/\/$/, "");
            surroundPattern = ["(?:/(", ")|/)?"];
            break;
          default:
            surroundPattern = [`(${param.squash}|`, ")?"];
            break;
        }
        return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];
      }
      const memoizeTo = (obj, _prop, fn) => obj[_prop] = obj[_prop] || fn();
      const splitOnSlash = splitOnDelim("/");
      const defaultConfig = {
        state: { params: {} },
        strict: true,
        caseInsensitive: true
      };
      class UrlMatcher {
        /** @internal Given a matcher, return an array with the matcher's path segments and path params, in order */
        static pathSegmentsAndParams(matcher) {
          const staticSegments = matcher._segments;
          const pathParams = matcher._params.filter(
            (p) => p.location === DefType.PATH
          );
          return arrayTuples(staticSegments, pathParams.concat(void 0)).reduce(unnestR, []).filter((x) => x !== "" && isDefined(x));
        }
        /** @internal Given a matcher, return an array with the matcher's query params */
        static queryParams(matcher) {
          return matcher._params.filter((p) => p.location === DefType.SEARCH);
        }
        /**
         * Compare two UrlMatchers
         *
         * This comparison function converts a UrlMatcher into static and dynamic path segments.
         * Each static path segment is a static string between a path separator (slash character).
         * Each dynamic segment is a path parameter.
         *
         * The comparison function sorts static segments before dynamic ones.
         */
        static compare(a, b) {
          const segments = (matcher) => matcher._cache.segments = matcher._cache.segments || matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams).reduce(unnestR, []).reduce(joinNeighborsR, []).map((x) => isString(x) ? splitOnSlash(x) : x).reduce(unnestR, []);
          const weights = (matcher) => matcher._cache.weights = matcher._cache.weights || segments(matcher).map((segment) => {
            if (segment === "/") return 1;
            if (isString(segment)) return 2;
            if (segment instanceof Param) return 3;
          });
          const padArrays = (l, r, padVal) => {
            const len = Math.max(l.length, r.length);
            while (l.length < len) l.push(padVal);
            while (r.length < len) r.push(padVal);
          };
          const weightsA = weights(a), weightsB = weights(b);
          padArrays(weightsA, weightsB, 0);
          const _pairs = arrayTuples(weightsA, weightsB);
          let cmp, i;
          for (i = 0; i < _pairs.length; i++) {
            cmp = _pairs[i][0] - _pairs[i][1];
            if (cmp !== 0) return cmp;
          }
          return 0;
        }
        /**
         * @param pattern The pattern to compile into a matcher.
         * @param paramTypes The [[ParamTypes]] registry
         * @param paramFactory A [[ParamFactory]] object
         * @param config  A [[UrlMatcherCompileConfig]] configuration object
         */
        constructor(pattern2, paramTypes, paramFactory, config) {
          this._cache = { path: [
            /** @type {UrlMatcher} */
            this
          ] };
          this._children = [];
          this._params = [];
          this._segments = [];
          this._compiled = [];
          this.config = config = defaults(config, defaultConfig);
          this.pattern = pattern2;
          const placeholder = /([:*])([\w[\]]+)|\{([\w[\]]+)(?::\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g;
          const searchPlaceholder = /([:]?)([\w[\].-]+)|\{([\w[\].-]+)(?::\s*((?:[^{\\}]+|\\.|{(?:[^{\\}]+|\\.)*})+))?\}/g;
          const patterns = [];
          let last = 0;
          let matchArray;
          const checkParamErrors = (id2) => {
            if (!UrlMatcher.nameValidator.test(id2))
              throw new Error(
                `Invalid parameter name '${id2}' in pattern '${pattern2}'`
              );
            if (find(this._params, propEq("id", id2)))
              throw new Error(
                `Duplicate parameter name '${id2}' in pattern '${pattern2}'`
              );
          };
          const matchDetails = (m, isSearch) => {
            const id2 = m[2] || m[3];
            const regexp = isSearch ? m[4] : m[4] || (m[1] === "*" ? "[\\s\\S]*" : null);
            const makeRegexpType = (str) => inherit(paramTypes.type(isSearch ? "query" : "path"), {
              pattern: new RegExp(
                str,
                this.config.caseInsensitive ? "i" : void 0
              )
            });
            return {
              id: id2,
              regexp,
              segment: pattern2.substring(last, m.index),
              type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)
            };
          };
          let details;
          let segment;
          while (matchArray = placeholder.exec(pattern2)) {
            details = matchDetails(matchArray, false);
            if (details.segment.indexOf("?") >= 0) break;
            checkParamErrors(details.id);
            this._params.push(
              paramFactory.fromPath(details.id, details.type, config.state)
            );
            this._segments.push(details.segment);
            patterns.push([details.segment, tail(this._params)]);
            last = placeholder.lastIndex;
          }
          segment = pattern2.substring(last);
          const i = segment.indexOf("?");
          if (i >= 0) {
            const search = segment.substring(i);
            segment = segment.substring(0, i);
            if (search.length > 0) {
              last = 0;
              while (matchArray = searchPlaceholder.exec(search)) {
                details = matchDetails(matchArray, true);
                checkParamErrors(details.id);
                this._params.push(
                  paramFactory.fromSearch(details.id, details.type, config.state)
                );
                last = placeholder.lastIndex;
              }
            }
          }
          this._segments.push(segment);
          this._compiled = patterns.map((_pattern) => quoteRegExp.apply(null, _pattern)).concat(quoteRegExp(segment));
        }
        /**
         * Creates a new concatenated UrlMatcher
         *
         * Builds a new UrlMatcher by appending another UrlMatcher to this one.
         *
         * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.
         */
        append(url) {
          this._children.push(url);
          url._cache = {
            path: this._cache.path.concat(url),
            parent: this,
            pattern: null
          };
          return url;
        }
        isRoot() {
          return this._cache.path[0] === this;
        }
        /** Returns the input pattern string */
        toString() {
          return this.pattern;
        }
        _getDecodedParamValue(value, param) {
          return param.value(value);
        }
        /**
         * Tests the specified url/path against this matcher.
         *
         * Tests if the given url matches this matcher's pattern, and returns an object containing the captured
         * parameter values.  Returns null if the path does not match.
         *
         * The returned object contains the values
         * of any search parameters that are mentioned in the pattern, but their value may be null if
         * they are not present in `search`. This means that search parameters are always treated
         * as optional.
         *
         * #### Example:
         * ```js
         * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {
         *   x: '1', q: 'hello'
         * });
         * // returns { id: 'bob', q: 'hello', r: null }
         * ```
         *
         * @param path    The URL path to match, e.g. `$location.getPath()`.
         * @param search  URL search parameters, e.g. `$location.getSearch()`.
         * @param hash    URL hash e.g. `$location.getHash()`.
         *
         * @returns The captured parameter values.
         */
        exec(path, search = {}, hash) {
          const match = memoizeTo(this._cache, "pattern", () => {
            return new RegExp(
              [
                "^",
                unnest(this._cache.path.map((x) => x._compiled)).join(""),
                this.config.strict === false ? "/?" : "",
                "$"
              ].join(""),
              this.config.caseInsensitive ? "i" : void 0
            );
          }).exec(path);
          if (!match) return null;
          const allParams = this.parameters(), pathParams = allParams.filter((param) => !param.isSearch()), searchParams = allParams.filter((param) => param.isSearch()), nPathSegments = this._cache.path.map((urlm) => urlm._segments.length - 1).reduce((a, x) => a + x), values = {};
          if (nPathSegments !== match.length - 1)
            throw new Error(`Unbalanced capture group in route '${this.pattern}'`);
          function decodePathArray(paramVal) {
            const reverseString = (str) => str.split("").reverse().join("");
            const unquoteDashes = (str) => str.replace(/\\-/g, "-");
            const split2 = reverseString(paramVal).split(/-(?!\\)/);
            const allReversed = map(split2, reverseString);
            return map(allReversed, unquoteDashes).reverse();
          }
          for (let i = 0; i < nPathSegments; i++) {
            const param = pathParams[i];
            let value = match[i + 1];
            for (let j = 0; j < param.replace.length; j++) {
              if (param.replace[j].from === value) value = param.replace[j].to;
            }
            if (value && param.array === true) value = decodePathArray(value);
            values[param.id] = this._getDecodedParamValue(value, param);
          }
          searchParams.forEach((param) => {
            let value = search[param.id];
            for (let j = 0; j < param.replace.length; j++) {
              if (param.replace[j].from === value) value = param.replace[j].to;
            }
            values[param.id] = this._getDecodedParamValue(value, param);
          });
          if (hash) values["#"] = hash;
          return values;
        }
        /**
         * @internal
         * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.
         *
         * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the
         *    pattern has no parameters, an empty array is returned.
         */
        parameters(opts = {}) {
          if (opts.inherit === false) return this._params;
          return unnest(this._cache.path.map((matcher) => matcher._params));
        }
        /**
         * @internal
         * Returns a single parameter from this UrlMatcher by id
         *
         * @param id
         * @param opts
         * @returns {Param|any|boolean|UrlMatcher|null}
         */
        parameter(id2, opts = {}) {
          const findParam = () => {
            for (const param of this._params) {
              if (param.id === id2) return param;
            }
          };
          const parent = this._cache.parent;
          return findParam() || opts.inherit !== false && parent && parent.parameter(id2, opts) || null;
        }
        /**
         * Validates the input parameter values against this UrlMatcher
         *
         * Checks an object hash of parameters to validate their correctness according to the parameter
         * types of this `UrlMatcher`.
         *
         * @param params The object hash of parameters to validate.
         * @returns Returns `true` if `params` validates, otherwise `false`.
         */
        validates(params) {
          const validParamVal = (param, val2) => !param || param.validates(val2);
          params = params || {};
          const paramSchema = this.parameters().filter(
            (paramDef) => hasOwn(params, paramDef.id)
          );
          return paramSchema.map((paramDef) => validParamVal(paramDef, params[paramDef.id])).reduce(allTrueR, true);
        }
        /**
         * Given a set of parameter values, creates a URL from this UrlMatcher.
         *
         * Creates a URL that matches this pattern by substituting the specified values
         * for the path and search parameters.
         *
         * #### Example:
         * ```js
         * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
         * // returns '/user/bob?q=yes'
         * ```
         *
         * @param values  the values to substitute for the parameters in this pattern.
         * @returns the formatted URL (path and optionally search part).
         */
        format(values = {}) {
          const urlMatchers = this._cache.path;
          const pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams).reduce(unnestR, []).map((x) => isString(x) ? x : getDetails(x));
          const queryParams = urlMatchers.map(UrlMatcher.queryParams).reduce(unnestR, []).map(getDetails);
          const isInvalid = (param) => param.isValid === false;
          if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {
            return null;
          }
          function getDetails(param) {
            const value = param.value(values[param.id]);
            const isValid = param.validates(value);
            const isDefaultValue = param.isDefaultValue(value);
            const squash = isDefaultValue ? param.squash : false;
            const encoded = param.type.encode(value);
            return { param, value, isValid, isDefaultValue, squash, encoded };
          }
          const pathString = pathSegmentsAndParams.reduce((acc, x) => {
            if (isString(x)) return acc + x;
            const { squash, encoded, param } = x;
            if (squash === true) return acc.match(/\/$/) ? acc.slice(0, -1) : acc;
            if (isString(squash)) return acc + squash;
            if (squash !== false) return acc;
            if (encoded == null) return acc;
            if (Array.isArray(encoded))
              return acc + map(encoded, encodeDashes).join("-");
            if (param.raw) return acc + encoded;
            return acc + encodeURIComponent(encoded);
          }, "");
          const queryString = queryParams.map((paramDetails) => {
            let { param, squash, encoded, isDefaultValue } = paramDetails;
            if (encoded == null || isDefaultValue && squash !== false) return;
            if (!Array.isArray(encoded)) encoded = [encoded];
            if (encoded.length === 0) return;
            if (!param.raw) encoded = map(encoded, encodeURIComponent);
            return encoded.map((val2) => `${param.id}=${val2}`);
          }).reduce(unnestR, []).join("&");
          return pathString + (queryString ? `?${queryString}` : "") + (values["#"] ? "#" + values["#"] : "");
        }
      }
      UrlMatcher.nameValidator = /^\w+([-.]+\w+)*(?:\[\])?$/;
      function encodeDashes(str) {
        return encodeURIComponent(str).replace(
          /-/g,
          (c) => `%5C%${c.charCodeAt(0).toString(16).toUpperCase()}`
        );
      }
      class StateObject {
        name = void 0;
        navigable = void 0;
        /** @type {?StateObject} */
        parent = void 0;
        params = void 0;
        url = void 0;
        includes = void 0;
        /**
         * @param {import('./interface.js').StateDeclaration} config
         */
        constructor(config) {
          Object.assign(this, config);
          this.$$state = () => {
            return this;
          };
          this.self = config;
          const nameGlob = this.name ? Glob.fromString(this.name) : null;
          this.__stateObjectCache = { nameGlob };
        }
        /**
         * Returns true if the provided parameter is the same state.
         *
         * Compares the identity of the state against the passed value, which is either an object
         * reference to the actual `State` instance, the original definition object passed to
         * `$stateProvider.state()`, or the fully-qualified name.
         *
         * @param ref Can be one of (a) a `State` instance, (b) an object that was passed
         *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.
         * @returns Returns `true` if `ref` matches the current `State` instance.
         */
        is(ref) {
          return this === ref || this.self === ref || this.fqn() === ref;
        }
        /**
         * @deprecated this does not properly handle dot notation
         * @returns Returns a dot-separated name of the state.
         */
        fqn() {
          if (!this.parent || !(this.parent instanceof this.constructor))
            return this.name;
          const name2 = this.parent.fqn();
          return name2 ? name2 + "." + this.name : this.name;
        }
        /**
         * Returns the root node of this state's tree.
         *
         * @returns The root of this state's tree.
         */
        root() {
          return this.parent && this.parent.root() || this;
        }
        /**
         * Gets the state's `Param` objects
         *
         * Gets the list of [[Param]] objects owned by the state.
         * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] objects.
         * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object
         *
         * @param opts options
         */
        parameters(opts) {
          opts = defaults(opts, { inherit: true, matchingKeys: null });
          const inherited = opts.inherit && this.parent && this.parent.parameters() || [];
          return inherited.concat(Object.values(this.params)).filter(
            (param) => !opts.matchingKeys || hasOwn(opts.matchingKeys, param.id)
          );
        }
        /**
         * Returns a single [[Param]] that is owned by the state
         *
         * If `opts.inherit` is true, it also searches the ancestor states` [[Param]]s.
         * @param id the name of the [[Param]] to return
         * @param opts options
         */
        parameter(id2, opts = {}) {
          return this.url && this.url.parameter(id2, opts) || find(Object.values(this.params), propEq("id", id2)) || opts.inherit && this.parent && this.parent.parameter(id2);
        }
        toString() {
          return this.fqn();
        }
      }
      StateObject.isStateDeclaration = (obj) => isFunction(obj["$$state"]);
      StateObject.isState = (obj) => isObject(obj["__stateObjectCache"]);
      class UrlRuleFactory {
        /**
         * @param {import('../url/url-service.js').UrlService} urlService
         * @param {import('../state/state-service.js').StateProvider} stateService
         * @param {import('../router.js').Router} routerGlobals
         */
        constructor(urlService, stateService, routerGlobals) {
          this.urlService = urlService;
          this.stateService = stateService;
          this.routerGlobals = routerGlobals;
        }
        /**
         *
         * @param {*} what
         * @param {*} handler
         * @returns {BaseUrlRule}
         */
        create(what, handler) {
          const { isState, isStateDeclaration } = StateObject;
          const makeRule = pattern([
            [isString, (_what) => makeRule(this.urlService.compile(_what))],
            [is(UrlMatcher), (_what) => this.fromUrlMatcher(_what, handler)],
            [
              (...args) => isState(...args) || isStateDeclaration(...args),
              (_what) => this.fromState(_what, this.stateService, this.routerGlobals)
            ],
            [is(RegExp), (_what) => this.fromRegExp(_what, handler)],
            [isFunction, (_what) => new BaseUrlRule(_what, handler)]
          ]);
          const rule = makeRule(what);
          if (!rule) throw new Error("invalid 'what' in when()");
          return rule;
        }
        /**
         * A UrlRule which matches based on a UrlMatcher
         *
         * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]
         *
         * ## Handler as a function
         *
         * If `handler` is a function, the function is invoked with:
         *
         * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])
         * - url: the current Url ([[UrlParts]])
         * - router: the router object ([[UIRouter]])
         *
         * #### Example:
         * ```js
         * var urlMatcher = $umf.compile("/foo/:fooId/:barId");
         * var rule = factory.fromUrlMatcher(urlMatcher, match => "/home/" + match.fooId + "/" + match.barId);
         * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
         * var result = rule.handler(match); // '/home/123/456'
         * ```
         *
         * ## Handler as UrlMatcher
         *
         * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.
         * The `handler` UrlMatcher is formatted using the matched param from the first matcher.
         * The url is replaced with the result.
         *
         * #### Example:
         * ```js
         * var urlMatcher = $umf.compile("/foo/:fooId/:barId");
         * var handler = $umf.compile("/home/:fooId/:barId");
         * var rule = factory.fromUrlMatcher(urlMatcher, handler);
         * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
         * var result = rule.handler(match); // '/home/123/456'
         * ```
         */
        fromUrlMatcher(urlMatcher, handler) {
          let _handler = handler;
          if (isString(handler)) handler = this.urlService.compile(handler);
          if (is(UrlMatcher)(handler)) _handler = (match) => handler.format(match);
          function matchUrlParamters(url) {
            const params = urlMatcher.exec(url.path, url.search, url.hash);
            return urlMatcher.validates(params) && params;
          }
          function matchPriority(params) {
            const optional = urlMatcher.parameters().filter((param) => param.isOptional);
            if (!optional.length) return 1e-6;
            const matched = optional.filter((param) => params[param.id]);
            return matched.length / optional.length;
          }
          const details = { urlMatcher, matchPriority, type: "URLMATCHER" };
          return Object.assign(new BaseUrlRule(matchUrlParamters, _handler), details);
        }
        /**
         * A UrlRule which matches a state by its url
         *
         * #### Example:
         * ```js
         * var rule = factory.fromState($state.get('foo'), router);
         * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
         * var result = rule.handler(match);
         * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }
         * ```
         */
        fromState(stateOrDecl, stateService, globals) {
          const state = StateObject.isStateDeclaration(stateOrDecl) ? stateOrDecl.$$state() : stateOrDecl;
          const handler = (match) => {
            const $state = stateService;
            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {
              $state.transitionTo(state, match, { inherit: true, source: "url" });
            }
          };
          const details = { state, type: "STATE" };
          return Object.assign(this.fromUrlMatcher(state.url, handler), details);
        }
        /**
         * A UrlRule which matches based on a regular expression
         *
         * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.
         *
         * ## Handler as a function
         *
         * If `handler` is a function, the function is invoked with:
         *
         * - regexp match array (from `regexp`)
         * - url: the current Url ([[UrlParts]])
         * - router: the router object ([[UIRouter]])
         *
         * #### Example:
         * ```js
         * var rule = factory.fromRegExp(/^\/foo\/(bar|baz)$/, match => "/home/" + match[1])
         * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]
         * var result = rule.handler(match); // '/home/bar'
         * ```
         *
         * ## Handler as string
         *
         * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.
         * The string is first interpolated using `string.replace()` style pattern.
         *
         * #### Example:
         * ```js
         * var rule = factory.fromRegExp(/^\/foo\/(bar|baz)$/, "/home/$1")
         * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]
         * var result = rule.handler(match); // '/home/bar'
         * ```
         */
        fromRegExp(regexp, handler) {
          if (regexp.global || regexp.sticky)
            throw new Error("Rule RegExp must not be global or sticky");
          const redirectUrlTo = (match) => (
            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern
            handler.replace(
              /\$(\$|\d{1,2})/,
              (m, what) => match[what === "$" ? 0 : Number(what)]
            )
          );
          const _handler = isString(handler) ? redirectUrlTo : handler;
          const matchParamsFromRegexp = (url) => regexp.exec(url.path);
          const details = { regexp, type: "REGEXP" };
          return Object.assign(
            new BaseUrlRule(matchParamsFromRegexp, _handler),
            details
          );
        }
      }
      UrlRuleFactory.isUrlRule = (obj) => obj && ["type", "match", "handler"].every((key) => isDefined(obj[key]));
      class BaseUrlRule {
        constructor(match, handler) {
          this.match = match;
          this.type = "RAW";
          this.$id = -1;
          this._group = void 0;
          this.handler = handler || ((x) => x);
          this.priority = void 0;
        }
        /**
         * This function should be overridden
         * @param {*} [params]
         * @returns {number}
         */
        matchPriority(params) {
          assert(isUndefined(params));
          return 0 - this.$id;
        }
      }
      function prioritySort(a, b) {
        return (b.priority || 0) - (a.priority || 0);
      }
      const typeSort = (a, b) => {
        const weights = { STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1 };
        return (weights[a.type] || 0) - (weights[b.type] || 0);
      };
      const urlMatcherSort = (a, b) => !a.urlMatcher || !b.urlMatcher ? 0 : UrlMatcher.compare(a.urlMatcher, b.urlMatcher);
      const idSort = (a, b) => {
        const useMatchPriority = { STATE: true, URLMATCHER: true };
        const equal = useMatchPriority[a.type] && useMatchPriority[b.type];
        return equal ? 0 : (a.$id || 0) - (b.$id || 0);
      };
      function defaultRuleSortFn(a, b) {
        let cmp = prioritySort(a, b);
        if (cmp !== 0) return cmp;
        cmp = typeSort(a, b);
        if (cmp !== 0) return cmp;
        cmp = urlMatcherSort(a, b);
        if (cmp !== 0) return cmp;
        return idSort(a, b);
      }
      function getHandlerFn(handler) {
        if (!isFunction(handler) && !isString(handler) && !is(TargetState)(handler) && !TargetState.isDef(handler)) {
          throw new Error(
            "'handler' must be a string, function, TargetState, or have a state: 'newtarget' property"
          );
        }
        return isFunction(handler) ? handler : val(handler);
      }
      class UrlRules {
        /** @param {UrlRuleFactory} urlRuleFactory */
        constructor(urlRuleFactory) {
          this._sortFn = defaultRuleSortFn;
          this._rules = [];
          this._id = 0;
          this.urlRuleFactory = urlRuleFactory;
        }
        /**
         * Defines the initial state, path, or behavior to use when the app starts.
         *
         * This rule defines the initial/starting state for the application.
         *
         * This rule is triggered the first time the URL is checked (when the app initially loads).
         * The rule is triggered only when the url matches either `""` or `"/"`.
         *
         * Note: The rule is intended to be used when the root of the application is directly linked to.
         * When the URL is *not* `""` or `"/"` and doesn't match other rules, the [[otherwise]] rule is triggered.
         * This allows 404-like behavior when an unknown URL is deep-linked.
         *
         * #### Example:
         * Start app at `home` state.
         * ```js
         * .initial({ state: 'home' });
         * ```
         *
         * #### Example:
         * Start app at `/home` (by url)
         * ```js
         * .initial('/home');
         * ```
         *
         * #### Example:
         * When no other url rule matches, go to `home` state
         * ```js
         * .initial((matchValue, url, router) => {
         *   console.log('initial state');
         *   return { state: 'home' };
         * })
         * ```
         *
         * @param handler The initial state or url path, or a function which returns the state or url path (or performs custom logic).
         */
        initial(handler) {
          const handlerFn = getHandlerFn(handler);
          const matchFn = (urlParts, router) => router.globals.transitionHistory.size() === 0 && !!/^\/?$/.exec(urlParts.path);
          this.rule(this.urlRuleFactory.create(matchFn, handlerFn));
        }
        /**
         * Defines the state, url, or behavior to use when no other rule matches the URL.
         *
         * This rule is matched when *no other rule* matches.
         * It is generally used to handle unknown URLs (similar to "404" behavior, but on the client side).
         *
         * - If `handler` a string, it is treated as a url redirect
         *
         * #### Example:
         * When no other url rule matches, redirect to `/index`
         * ```js
         * .otherwise('/index');
         * ```
         *
         * - If `handler` is an object with a `state` property, the state is activated.
         *
         * #### Example:
         * When no other url rule matches, redirect to `home` and provide a `dashboard` parameter value.
         * ```js
         * .otherwise({ state: 'home', params: { dashboard: 'default' } });
         * ```
         *
         * - If `handler` is a function, the function receives the current url ([[UrlParts]]) and the [[UIRouter]] object.
         *   The function can perform actions, and/or return a value.
         *
         * #### Example:
         * When no other url rule matches, manually trigger a transition to the `home` state
         * ```js
         * .otherwise((matchValue, urlParts, router) => {
         *   router.stateService.go('home');
         * });
         * ```
         *
         * #### Example:
         * When no other url rule matches, go to `home` state
         * ```js
         * .otherwise((matchValue, urlParts, router) => {
         *   return { state: 'home' };
         * });
         * ```
         *
         * @param handler The url path to redirect to, or a function which returns the url path (or performs custom logic).
         */
        otherwise(handler) {
          const handlerFn = getHandlerFn(handler);
          this._otherwiseFn = this.urlRuleFactory.create(val(true), handlerFn);
          this._sorted = false;
        }
        /**
         * Remove a rule previously registered
         *
         * @param rule the matcher rule that was previously registered using [[rule]]
         */
        removeRule(rule) {
          removeFrom(this._rules, rule);
        }
        /**
         * Manually adds a URL Rule.
         *
         * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].
         * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).
         * Rules can be created using [[urlRuleFactory]], or created manually as simple objects.
         *
         * A rule should have a `match` function which returns truthy if the rule matched.
         * It should also have a `handler` function which is invoked if the rule is the best match.
         *
         * @return a function that deregisters the rule
         */
        rule(rule) {
          if (!UrlRuleFactory.isUrlRule(rule)) throw new Error("invalid rule");
          rule.$id = this._id++;
          rule.priority = rule.priority || 0;
          this._rules.push(rule);
          this._sorted = false;
          return () => this.removeRule(rule);
        }
        /**
         * Gets all registered rules
         *
         * @returns an array of all the registered rules
         */
        rules() {
          this.ensureSorted();
          return this._rules.concat(this._otherwiseFn ? [this._otherwiseFn] : []);
        }
        /**
         * Defines URL Rule priorities
         *
         * More than one rule ([[UrlRule]]) might match a given URL.
         * This `compareFn` is used to sort the rules by priority.
         * Higher priority rules should sort earlier.
         *
         * The [[defaultRuleSortFn]] is used by default.
         *
         * You only need to call this function once.
         * The `compareFn` will be used to sort the rules as each is registered.
         *
         * If called without any parameter, it will re-sort the rules.
         *
         * ---
         *
         * Url rules may come from multiple sources: states's urls ([[StateDeclaration.url]]), [[when]], and [[rule]].
         * Each rule has a (user-provided) [[UrlRule.priority]], a [[UrlRule.type]], and a [[UrlRule.$id]]
         * The `$id` is is the order in which the rule was registered.
         *
         * The sort function should use these data, or data found on a specific type
         * of [[UrlRule]] (such as [[StateRule.state]]), to order the rules as desired.
         *
         * #### Example:
         * This compare function prioritizes rules by the order in which the rules were registered.
         * A rule registered earlier has higher priority.
         *
         * ```js
         * function compareFn(a, b) {
         *   return a.$id - b.$id;
         * }
         * ```
         *
         * @param compareFn a function that compares to [[UrlRule]] objects.
         *    The `compareFn` should abide by the `Array.sort` compare function rules.
         *    Given two rules, `a` and `b`, return a negative number if `a` should be higher priority.
         *    Return a positive number if `b` should be higher priority.
         *    Return `0` if the rules are identical.
         *
         *    See the [mozilla reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Description)
         *    for details.
         */
        sort(compareFn) {
          const sorted = this.stableSort(
            this._rules,
            this._sortFn = compareFn || this._sortFn
          );
          let group = 0;
          for (let i = 0; i < sorted.length; i++) {
            sorted[i]._group = group;
            if (i < sorted.length - 1 && this._sortFn(sorted[i], sorted[i + 1]) !== 0) {
              group++;
            }
          }
          this._rules = sorted;
          this._sorted = true;
        }
        ensureSorted() {
          this._sorted || this.sort();
        }
        stableSort(arr, compareFn) {
          const arrOfWrapper = arr.map((elem, idx) => ({ elem, idx }));
          arrOfWrapper.sort((wrapperA, wrapperB) => {
            const cmpDiff = compareFn(wrapperA.elem, wrapperB.elem);
            return cmpDiff === 0 ? wrapperA.idx - wrapperB.idx : cmpDiff;
          });
          return arrOfWrapper.map((wrapper) => wrapper.elem);
        }
        /**
         * Registers a `matcher` and `handler` for custom URLs handling.
         *
         * The `matcher` can be:
         *
         * - a [[UrlMatcher]]: See: [[UrlMatcherFactory.compile]]
         * - a `string`: The string is compiled to a [[UrlMatcher]]
         * - a `RegExp`: The regexp is used to match the url.
         *
         * The `handler` can be:
         *
         * - a string: The url is redirected to the value of the string.
         * - a function: The url is redirected to the return value of the function.
         *
         * ---
         *
         * When the `handler` is a `string` and the `matcher` is a `UrlMatcher` (or string), the redirect
         * string is interpolated with parameter values.
         *
         * #### Example:
         * When the URL is `/foo/123` the rule will redirect to `/bar/123`.
         * ```js
         * .when("/foo/:param1", "/bar/:param1")
         * ```
         *
         * ---
         *
         * When the `handler` is a string and the `matcher` is a `RegExp`, the redirect string is
         * interpolated with capture groups from the RegExp.
         *
         * #### Example:
         * When the URL is `/foo/123` the rule will redirect to `/bar/123`.
         * ```js
         * .when(new RegExp("^/foo/(.*)$"), "/bar/$1");
         * ```
         *
         * ---
         *
         * When the handler is a function, it receives the matched value, the current URL, and the `UIRouter` object (See [[UrlRuleHandlerFn]]).
         * The "matched value" differs based on the `matcher`.
         * For [[UrlMatcher]]s, it will be the matched state params.
         * For `RegExp`, it will be the match array from `regexp.exec()`.
         *
         * If the handler returns a string, the URL is redirected to the string.
         *
         * #### Example:
         * When the URL is `/foo/123` the rule will redirect to `/bar/123`.
         * ```js
         * .when(new RegExp("^/foo/(.*)$"), match => "/bar/" + match[1]);
         * ```
         *
         * Note: the `handler` may also invoke arbitrary code, such as `$state.go()`
         *
         * @param matcher A pattern `string` to match, compiled as a [[UrlMatcher]], or a `RegExp`.
         * @param handler The path to redirect to, or a function that returns the path.
         * @param options `{ priority: number }`
         *
         * @return the registered [[UrlRule]]
         */
        when(matcher, handler, options) {
          const rule = this.urlRuleFactory.create(matcher, handler);
          if (isDefined(options && options.priority))
            rule.priority = options.priority;
          this.rule(rule);
          return rule;
        }
      }
      class ParamFactory {
        /**
         * @param {import("../url/url-config.js").UrlConfigProvider} urlServiceConfig
         */
        constructor(urlServiceConfig) {
          this.urlServiceConfig = urlServiceConfig;
        }
        fromConfig(id2, type, state) {
          return new Param(id2, type, DefType.CONFIG, this.urlServiceConfig, state);
        }
        fromPath(id2, type, state) {
          return new Param(id2, type, DefType.PATH, this.urlServiceConfig, state);
        }
        fromSearch(id2, type, state) {
          return new Param(id2, type, DefType.SEARCH, this.urlServiceConfig, state);
        }
      }
      class UrlService {
        static $inject = provider([
          $injectTokens.$location,
          $injectTokens.$state,
          $injectTokens.$router,
          $injectTokens.$urlConfig
        ]);
        /** @type {import("../../services/location/location").Location} */
        $location;
        /**
         * @param {import("../../services/location/location").LocationProvider} $locationProvider
         * @param {import("../../router/state/state-service.js").StateProvider} stateService
         * @param {import("../router.js").Router} globals
         * @param {import("../../router/url/url-config.js").UrlConfigProvider} urlConfigProvider
         */
        constructor($locationProvider, stateService, globals, urlConfigProvider) {
          this.$locationProvider = $locationProvider;
          this.stateService = stateService;
          this.stateService.urlService = this;
          this.urlRuleFactory = new UrlRuleFactory(this, this.stateService, globals);
          this.rules = new UrlRules(this.urlRuleFactory);
          this.config = urlConfigProvider;
          this.paramFactory = new ParamFactory(this.config);
          this._urlListeners = [];
        }
        /**
         * Gets the path part of the current url
         *
         * If the current URL is `/some/path?query=value#anchor`, this returns `/some/path`
         *
         * @return {string} the path portion of the url
         */
        getPath() {
          return this.$location.getPath();
        }
        /**
         * Gets the search part of the current url as an object
         *
         * If the current URL is `/some/path?query=value#anchor`, this returns `{ query: 'value' }`
         *
         * @return {Object} the search (query) portion of the url, as an object
         */
        getSearch() {
          return this.$location.getSearch();
        }
        /**
         * Gets the hash part of the current url
         *
         * If the current URL is `/some/path?query=value#anchor`, this returns `anchor`
         *
         * @return {string} the hash (anchor) portion of the url
         */
        getHash() {
          return this.$location.getHash();
        }
        $get = [
          $injectTokens.$location,
          $injectTokens.$rootScope,
          /**
           *
           * @param {import('../../services/location/location.js').Location} $location
           * @param {import('../../core/scope/scope.js').Scope} $rootScope
           * @returns {UrlService}
           */
          ($location, $rootScope) => {
            this.$location = $location;
            $rootScope.$on("$locationChangeSuccess", (evt) => {
              this._urlListeners.forEach((fn) => {
                fn(evt);
              });
            });
            this.listen(true);
            return this;
          }
        ];
        /**
         * @returns {string}
         */
        baseHref() {
          return this._baseHref || (this._baseHref = getBaseHref() || window.location.pathname);
        }
        /**
         * Gets the current url, or updates the url
         *
         * ### Getting the current URL
         *
         * When no arguments are passed, returns the current URL.
         * The URL is normalized using the internal [[path]]/[[search]]/[[hash]] values.
         *
         * For example, the URL may be stored in the hash ([[HashLocationServices]]) or
         * have a base HREF prepended ([[PushStateLocationServices]]).
         *
         * The raw URL in the browser might be:
         *
         * ```
         * http://mysite.com/somepath/index.html#/internal/path/123?param1=foo#anchor
         * ```
         *
         * or
         *
         * ```
         * http://mysite.com/basepath/internal/path/123?param1=foo#anchor
         * ```
         *
         * then this method returns:
         *
         * ```
         * /internal/path/123?param1=foo#anchor
         * ```
         *
         *
         * #### Example:
         * ```js
         * locationServices.url(); // "/some/path?query=value#anchor"
         * ```
         *
         * ### Updating the URL
         *
         * When `newurl` arguments is provided, changes the URL to reflect `newurl`
         *
         * #### Example:
         * ```js
         * locationServices.url("/some/path?query=value#anchor", true);
         * ```
         *
         * @param {string} [newUrl] The new value for the URL.
         *               This url should reflect only the new internal [[path]], [[search]], and [[hash]] values.
         *               It should not include the protocol, site, port, or base path of an absolute HREF.
         * @param {any} [state] The history's state object, i.e., pushState (if the LocationServices implementation supports it)
         *
         * @return the url (after potentially being processed)
         */
        url(newUrl, state) {
          if (isDefined(newUrl)) {
            const decodeUri = decodeURIComponent(newUrl);
            this.$location.setUrl(decodeUri);
          }
          if (state) this.$location.setState(state);
          return this.$location.getUrl();
        }
        /**
         * @private
         *
         * Registers a low level url change handler
         *
         * Note: Because this is a low level handler, it's not recommended for general use.
         *
         * #### Example:
         * ```js
         * let deregisterFn = locationServices.onChange((evt) => console.log("url change", evt));
         * ```
         *
         * @param {Function} callback a function that will be called when the url is changing
         * @return {Function} a function that de-registers the callback
         */
        onChange(callback) {
          this._urlListeners.push(callback);
          return () => removeFrom(this._urlListeners)(callback);
        }
        /**
         * Gets the current URL parts.
         *
         * Returns an object with the `path`, `search`, and `hash` components
         * of the current browser location.
         *
         * @returns {import("../../services/location/interface.ts").UrlParts} The current URL's path, search, and hash.
         */
        parts() {
          return {
            path: this.$location.getPath(),
            search: this.$location.getSearch(),
            hash: this.$location.getHash()
          };
        }
        /**
         * Activates the best rule for the current URL
         *
         * Checks the current URL for a matching [[UrlRule]], then invokes that rule's handler.
         * This method is called internally any time the URL has changed.
         *
         * This effectively activates the state (or redirect, etc) which matches the current URL.
         *
         * #### Example:
         * ```js
         *
         * fetch('/states.json').then(resp => resp.json()).then(data => {
         *   data.forEach(state => $stateRegistry.register(state));
         *   urlService.listen();
         *   // Find the matching URL and invoke the handler.
         *   urlService.sync();
         * });
         * ```
         */
        sync(evt) {
          if (evt && evt.defaultPrevented) return;
          const stateService = this.stateService;
          const url = {
            path: this.$location.getPath(),
            search: this.$location.getSearch(),
            hash: this.$location.getHash()
          };
          const best = this.match(url);
          const applyResult = pattern([
            [isString, (newurl) => this.url(newurl)],
            [
              TargetState.isDef,
              (def) => stateService.go(def.state, def.params, def.options)
            ],
            [
              is(TargetState),
              (target) => stateService.go(target.state(), target.params(), target.options())
            ]
          ]);
          applyResult(best && best.rule.handler(best.match, url));
        }
        /**
         * Starts or stops listening for URL changes
         *
         * Call this sometime after calling [[deferIntercept]] to start monitoring the url.
         * This causes ng-router to start listening for changes to the URL, if it wasn't already listening.
         *
         * If called with `false`, ng-router will stop listening (call listen(true) to start listening again).
         *
         * #### Example:
         * ```js
         *
         * fetch('/states.json').then(resp => resp.json()).then(data => {
         *   data.forEach(state => $stateRegistry.register(state));
         *   // Start responding to URL changes
         *   urlService.listen();
         *   urlService.sync();
         * });
         * ```
         *
         * @param {boolean} enabled `true` or `false` to start or stop listening to URL changes
         */
        listen(enabled) {
          if (enabled === false) {
            this._stopListeningFn && this._stopListeningFn();
            delete this._stopListeningFn;
          } else {
            return this._stopListeningFn = this._stopListeningFn || this.onChange((evt) => this.sync(evt));
          }
        }
        /**
         * Matches a URL
         *
         * Given a URL (as a [[UrlParts]] object), check all rules and determine the best matching rule.
         * Return the result as a [[MatchResult]].
         * @returns {any}
         */
        match(url) {
          url = Object.assign({ path: "", search: {}, hash: "" }, url);
          const rules = this.rules.rules();
          const checkRule = (rule) => {
            const match = rule.match(url);
            return match && { match, rule, weight: rule.matchPriority(match) };
          };
          let best;
          for (let i = 0; i < rules.length; i++) {
            if (best && best.rule._group !== rules[i]._group) break;
            const current = checkRule(rules[i]);
            best = !best || current && current.weight > best.weight ? current : best;
          }
          return best;
        }
        update(read) {
          if (read) {
            this.location = this.url();
            return;
          }
          if (this.url() === this.location) return;
          this.url(
            /** @type {string} */
            this.location,
            true
          );
        }
        /**
         * Internal API.
         *
         * Pushes a new location to the browser history.
         *
         * @internal
         * @param urlMatcher
         * @param params
         * @param options
         */
        push(urlMatcher, params, options) {
          const replace = options && !!options.replace;
          this.url(urlMatcher.format(params || {}), replace);
        }
        /**
         * Builds and returns a URL with interpolated parameters
         *
         * #### Example:
         * ```js
         * matcher = $umf.compile("/about/:person");
         * params = { person: "bob" };
         * $bob = $url.href(matcher, params);
         * // $bob == "/about/bob";
         * ```
         *
         * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.
         * @param params An object of parameter values to fill the matcher's required parameters.
         * @param options Options object. The options are:
         *
         * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
         *
         * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`
         */
        href(urlMatcher, params, options) {
          let url = urlMatcher.format(params);
          if (url == null) return null;
          options = options || { absolute: false };
          const isHtml5 = this.$locationProvider.html5ModeConf.enabled;
          if (!isHtml5) {
            url = "#" + this.$locationProvider.hashPrefixConf + url;
          }
          url = appendBasePath(url, isHtml5, options.absolute, this.baseHref());
          if (!options.absolute || !url) {
            return url;
          }
          const slash = !isHtml5 && url ? "/" : "";
          return [
            `${window.location.protocol}//`,
            window.location.host,
            slash,
            url
          ].join("");
        }
        /**
         * Creates a [[UrlMatcher]] for the specified pattern.
         *
         * @param pattern  The URL pattern.
         * @param config  The config object hash.
         * @returns The UrlMatcher.
         */
        compile(pattern2, config) {
          const urlConfig = this.config;
          const params = config && !config.state && config.params;
          config = params ? Object.assign({ state: { params } }, config) : config;
          const globalConfig = {
            strict: urlConfig._isStrictMode,
            caseInsensitive: urlConfig._isCaseInsensitive
          };
          return new UrlMatcher(
            pattern2,
            urlConfig.paramTypes,
            this.paramFactory,
            Object.assign(globalConfig, config)
          );
        }
        /**
         * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.
         *
         * @param object  The object to perform the type check against.
         * @returns `true` if the object matches the `UrlMatcher` interface, by
         *          implementing all the same methods.
         */
        isMatcher(object) {
          if (!isObject(object)) return false;
          let result = true;
          Object.entries(UrlMatcher.prototype).forEach(([name2, val2]) => {
            if (isFunction(val2))
              result = result && isDefined(object[name2]) && isFunction(object[name2]);
          });
          return result;
        }
      }
      function appendBasePath(url, isHtml5, absolute, baseHref) {
        if (baseHref === "/") return url;
        if (isHtml5) return stripLastPathElement(baseHref) + url;
        if (absolute) return baseHref.slice(1) + url;
        return url;
      }
      class StateMatcher {
        constructor(_states) {
          this._states = _states;
        }
        isRelative(stateName) {
          stateName = stateName || "";
          return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
        }
        find(stateOrName, base, matchGlob = true) {
          if (!stateOrName && stateOrName !== "") return void 0;
          const isStr = isString(stateOrName);
          let name2 = isStr ? stateOrName : stateOrName.name;
          if (this.isRelative(name2)) name2 = this.resolvePath(name2, base);
          const state = this._states[name2];
          if (state && (isStr || !isStr && (state === stateOrName || state.self === stateOrName))) {
            return state;
          } else if (isStr && matchGlob) {
            const _states = Object.values(this._states);
            const matches = _states.filter(
              (_state) => _state.__stateObjectCache.nameGlob && _state.__stateObjectCache.nameGlob.matches(name2)
            );
            if (matches.length > 1) {
              console.error(
                `stateMatcher.find: Found multiple matches for ${name2} using glob: `,
                matches.map((match) => match.name)
              );
            }
            return matches[0];
          }
          return void 0;
        }
        resolvePath(name2, base) {
          if (!base) throw new Error(`No reference point given for path '${name2}'`);
          const baseState = this.find(base);
          const splitName = name2.split(".");
          const pathLength = splitName.length;
          let i = 0, current = baseState;
          for (; i < pathLength; i++) {
            if (splitName[i] === "" && i === 0) {
              current = baseState;
              continue;
            }
            if (splitName[i] === "^") {
              if (!current.parent)
                throw new Error(
                  `Path '${name2}' not valid for state '${baseState.name}'`
                );
              current = current.parent;
              continue;
            }
            break;
          }
          const relName = splitName.slice(i).join(".");
          return current.name + (current.name && relName ? "." : "") + relName;
        }
      }
      function parseUrl(url) {
        if (!isString(url)) return false;
        const root = url.charAt(0) === "^";
        return { val: root ? url.substring(1) : url, root };
      }
      function selfBuilder(state) {
        state.self.$$state = () => state;
        return state.self;
      }
      function dataBuilder(state) {
        if (state.parent && state.parent.data) {
          state.data = state.self.data = inherit(state.parent.data, state.data);
        }
        return state.data;
      }
      function getUrlBuilder($url, root) {
        return function(stateObject) {
          let stateDec = stateObject.self;
          if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\.\*\*$/)) {
            const newStateDec = {};
            copy(stateDec, newStateDec);
            newStateDec.url += "{remainder:any}";
            stateDec = newStateDec;
          }
          const parent = stateObject.parent;
          const parsed = parseUrl(stateDec.url);
          const url = !parsed ? stateDec.url : $url.compile(parsed.val, { state: stateDec });
          if (!url) return null;
          if (!$url.isMatcher(url))
            throw new Error(`Invalid url '${url}' in state '${stateObject}'`);
          return parsed && parsed.root ? url : (parent && parent.navigable || root()).url.append(url);
        };
      }
      function getNavigableBuilder(isRoot2) {
        return function(state) {
          return !isRoot2(state) && state.url ? state : state.parent ? state.parent.navigable : null;
        };
      }
      function getParamsBuilder(paramFactory) {
        return function(state) {
          const makeConfigParam = (_config, id2) => paramFactory.fromConfig(id2, null, state.self);
          const urlParams = state.url && state.url.parameters({ inherit: false }) || [];
          const nonUrlParams = Object.values(
            map(
              omit(
                state.params || {},
                urlParams.map((x) => x.id)
              ),
              makeConfigParam
            )
          );
          return urlParams.concat(nonUrlParams).map((p) => [p.id, p]).reduce(applyPairs, {});
        };
      }
      function pathBuilder(state) {
        return state.parent ? state.parent.path.concat(state) : [state];
      }
      function includesBuilder(state) {
        const includes2 = state.parent ? Object.assign({}, state.parent.includes) : {};
        includes2[state.name] = true;
        return includes2;
      }
      function resolvablesBuilder(state) {
        const objects2Tuples = (resolveObj, resolvePolicies2) => Object.keys(resolveObj || {}).map((token) => ({
          token,
          val: resolveObj[token],
          deps: void 0,
          policy: resolvePolicies2[token]
        }));
        const annotateFn = (fn) => {
          const $injector = window["angular"].$injector;
          return fn["$inject"] || $injector && annotate(fn, $injector.strictDi) || "deferred";
        };
        const isResolveLiteral = (obj) => !!(obj.token && obj.resolveFn);
        const isTupleFromObj = (obj) => !!(obj && obj.val && (isString(obj.val) || Array.isArray(obj.val) || isFunction(obj.val)));
        const literal2Resolvable = pattern([
          [
            (x) => x.resolveFn,
            (p) => new Resolvable(getToken(p), p.resolveFn, p.deps, p.policy)
          ],
          [
            (x) => x.useFactory,
            (p) => new Resolvable(
              getToken(p),
              p.useFactory,
              p.deps || p.dependencies,
              p.policy
            )
          ],
          [
            (x) => x.useClass,
            (p) => new Resolvable(getToken(p), () => new p.useClass(), [], p.policy)
          ],
          [
            (x) => x.useValue,
            (p) => new Resolvable(getToken(p), () => p.useValue, [], p.policy, p.useValue)
          ],
          [
            (x) => x.useExisting,
            (p) => new Resolvable(getToken(p), (x) => x, [p.useExisting], p.policy)
          ]
        ]);
        const tuple2Resolvable = pattern([
          [
            pipe((x) => x.val, isString),
            (tuple) => new Resolvable(tuple.token, (x) => x, [tuple.val], tuple.policy)
          ],
          [
            pipe((x) => x.val, Array.isArray),
            (tuple) => new Resolvable(
              tuple.token,
              tail(tuple.val),
              tuple.val.slice(0, -1),
              tuple.policy
            )
          ],
          [
            pipe((x) => x.val, isFunction),
            (tuple) => new Resolvable(
              tuple.token,
              tuple.val,
              annotateFn(tuple.val),
              tuple.policy
            )
          ]
        ]);
        const item2Resolvable = pattern([
          [is(Resolvable), (r) => r],
          [isResolveLiteral, literal2Resolvable],
          [isTupleFromObj, tuple2Resolvable],
          [
            val(true),
            (obj) => {
              throw new Error("Invalid resolve value: " + stringify(obj));
            }
          ]
        ]);
        const decl = state.resolve;
        const items = Array.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});
        return items.map(item2Resolvable);
      }
      class StateBuilder {
        /**
         * @param {import('./state-matcher.js').StateMatcher} matcher
         * @param urlService
         */
        constructor(matcher, urlService) {
          this.matcher = matcher;
          this.$injector = void 0;
          const self2 = this;
          const root = () => matcher.find("");
          function parentBuilder(state) {
            if (isRoot(state)) return null;
            return matcher.find(self2.parentName(state)) || root();
          }
          this.builders = {
            name: [(state) => state.name],
            self: [selfBuilder],
            parent: [parentBuilder],
            data: [dataBuilder],
            // Build a URLMatcher if necessary, either via a relative or absolute URL
            url: [getUrlBuilder(urlService, root)],
            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
            navigable: [getNavigableBuilder(isRoot)],
            // TODO
            params: [getParamsBuilder(urlService.paramFactory)],
            // Each framework-specific ng-router implementation should define its own `views` builder
            // e.g., src/ng1/statebuilders/views.ts
            views: [],
            // Keep a full path from the root down to this state as this is needed for state activation.
            path: [pathBuilder],
            // Speed up $state.includes() as it's used a lot
            includes: [includesBuilder],
            resolvables: [resolvablesBuilder]
          };
        }
        builder(name2, fn) {
          const builders = this.builders;
          const array = builders[name2] || [];
          if (isString(name2) && !isDefined(fn))
            return array.length > 1 ? array : array[0];
          if (!isString(name2) || !isFunction(fn)) return;
          builders[name2] = array;
          builders[name2].push(fn);
          return () => builders[name2].splice(builders[name2].indexOf(fn, 1)) && null;
        }
        /**
         * Builds all of the properties on an essentially blank State object, returning a State object which has all its
         * properties and API built.
         *
         * @param state an uninitialized State object
         * @returns the built State object
         */
        build(state) {
          const { matcher, builders } = this;
          const parent = this.parentName(state);
          if (parent && !matcher.find(parent, void 0, false)) {
            return null;
          }
          for (const key in builders) {
            if (!hasOwn(builders, key)) continue;
            const chain = builders[key].reduce(
              (parentFn, step) => (_state) => step(_state, parentFn),
              () => {
              }
            );
            state[key] = chain(state);
          }
          return state;
        }
        parentName(state) {
          const name2 = state.name || "";
          const segments = name2.split(".");
          const lastSegment = segments.pop();
          if (lastSegment === "**") segments.pop();
          if (segments.length) {
            if (state.parent) {
              throw new Error(
                `States that specify the 'parent:' property should not have a '.' in their name (${name2})`
              );
            }
            return segments.join(".");
          }
          if (!state.parent) return "";
          return isString(state.parent) ? state.parent : state.parent.name;
        }
        name(state) {
          const name2 = state.name;
          if (name2.indexOf(".") !== -1 || !state.parent) return name2;
          const parentName = isString(state.parent) ? state.parent : state.parent.name;
          return parentName ? parentName + "." + name2 : name2;
        }
      }
      function isRoot(state) {
        return state.name === "";
      }
      function getToken(p) {
        return p.provide || p.token;
      }
      class StateQueueManager {
        /**
         * @param {import("./state-registry.js").StateRegistryProvider} stateRegistry
         * @param {*} urlServiceRules
         * @param {*} states
         * @param {*} builder
         * @param {*} listeners
         */
        constructor(stateRegistry, urlServiceRules, states, builder, listeners) {
          this.stateRegistry = stateRegistry;
          this.urlServiceRules = urlServiceRules;
          this.states = states;
          this.builder = builder;
          this.listeners = listeners;
          this.queue = [];
        }
        register(stateDecl) {
          const state = new StateObject(stateDecl);
          if (!isString(name)) throw new Error("State must have a valid name");
          if (hasOwn(this.states, state.name) || this.queue.map((x) => x.name).includes(state.name))
            throw new Error(`State '${state.name}' is already defined`);
          this.queue.push(state);
          this.flush();
          return state;
        }
        flush() {
          const { queue, states, builder } = this;
          const registered = [], orphans = [], previousQueueLength = {};
          const getState = (name2) => hasOwn(this.states, name2) && this.states[name2];
          const notifyListeners = () => {
            if (registered.length) {
              this.listeners.forEach(
                (listener) => listener(
                  "registered",
                  registered.map((s) => s.self)
                )
              );
            }
          };
          while (queue.length > 0) {
            const state = queue.shift();
            const name2 = state.name;
            const result = builder.build(state);
            const orphanIdx = orphans.indexOf(state);
            if (result) {
              const existingState = getState(name2);
              if (existingState && existingState.name === name2) {
                throw new Error(`State '${name2}' is already defined`);
              }
              const existingFutureState = getState(name2 + ".**");
              if (existingFutureState) {
                this.stateRegistry.deregister(existingFutureState);
              }
              states[name2] = state;
              this.attachRoute(state);
              if (orphanIdx >= 0) orphans.splice(orphanIdx, 1);
              registered.push(state);
              continue;
            }
            const prev = previousQueueLength[name2];
            previousQueueLength[name2] = queue.length;
            if (orphanIdx >= 0 && prev === queue.length) {
              queue.push(state);
              notifyListeners();
              return states;
            } else if (orphanIdx < 0) {
              orphans.push(state);
            }
            queue.push(state);
          }
          notifyListeners();
          return states;
        }
        attachRoute(state) {
          if (state.abstract || !state.url) return;
          const rulesApi = this.urlServiceRules;
          rulesApi.rule(rulesApi.urlRuleFactory.create(state));
        }
      }
      class StateRegistryProvider {
        static $inject = provider([$injectTokens.$url, $injectTokens.$state, $injectTokens.$router, $injectTokens.$view]);
        /**
         * @param urlService
         * @param stateService
         * @param {import('../router.js').Router} globals
         * @param viewService
         */
        constructor(urlService, stateService, globals, viewService) {
          this.states = {};
          stateService.stateRegistry = this;
          this.urlService = urlService;
          this.urlServiceRules = urlService.rules;
          this.$injector = void 0;
          this.listeners = [];
          this.matcher = new StateMatcher(this.states);
          this.builder = new StateBuilder(this.matcher, urlService);
          this.builder.builder("views", ng1ViewsBuilder);
          this.builder.builder("onExit", this.getStateHookBuilder("onExit"));
          this.builder.builder("onRetain", this.getStateHookBuilder("onRetain"));
          this.builder.builder("onEnter", this.getStateHookBuilder("onEnter"));
          this.stateQueue = new StateQueueManager(
            this,
            this.urlServiceRules,
            this.states,
            this.builder,
            this.listeners
          );
          this.registerRoot();
          viewService.rootViewContext(this.root());
          globals.$current = this.root();
          globals.current = globals.$current.self;
        }
        $get = [
          $injectTokens.$injector,
          /**
           * @param {import("../../core/di/internal-injector").InjectorService} $injector
           * @returns {StateRegistryProvider}
           */
          ($injector) => {
            this.$injector = $injector;
            this.builder.$injector = $injector;
            return this;
          }
        ];
        /**
         * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,
         * `onRetain` callback hooks on a [[StateDeclaration]].
         *
         * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
         * ensures that those hooks are injectable for @uirouter/angularjs (ng1).
         *
         * @internalapi
         */
        getStateHookBuilder(hookName) {
          let that = this;
          return function stateHookBuilder(stateObject) {
            const hook = stateObject[hookName];
            const pathname = hookName === "onExit" ? "from" : "to";
            function decoratedNg1Hook(trans, state) {
              const resolveContext = new ResolveContext(trans.treeChanges(pathname));
              const subContext = resolveContext.subContext(state.$$state());
              const locals = Object.assign(getLocals(subContext), {
                $state$: state,
                $transition$: trans
              });
              return that.$injector.invoke(hook, this, locals);
            }
            return hook ? decoratedNg1Hook : void 0;
          };
        }
        /**
         * @private
         */
        registerRoot() {
          const rootStateDef = {
            name: "",
            url: "^",
            views: null,
            params: {
              "#": { value: null, type: "hash", dynamic: true }
            },
            abstract: true
          };
          this._root = this.stateQueue.register(rootStateDef);
          this._root.navigable = null;
        }
        /**
         * Listen for a State Registry events
         *
         * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.
         *
         * #### Example:
         * ```js
         * let allStates = registry.get();
         *
         * // Later, invoke deregisterFn() to remove the listener
         * let deregisterFn = registry.onStatesChanged((event, states) => {
         *   switch(event) {
         *     case: 'registered':
         *       states.forEach(state => allStates.push(state));
         *       break;
         *     case: 'deregistered':
         *       states.forEach(state => {
         *         let idx = allStates.indexOf(state);
         *         if (idx !== -1) allStates.splice(idx, 1);
         *       });
         *       break;
         *   }
         * });
         * ```
         *
         * @param listener a callback function invoked when the registered states changes.
         *        The function receives two parameters, `event` and `state`.
         *        See [[StateRegistryListener]]
         * @return a function that deregisters the listener
         */
        onStatesChanged(listener) {
          this.listeners.push(listener);
          return (function deregisterListener() {
            removeFrom(this.listeners)(listener);
          }).bind(this);
        }
        /**
         * Gets the implicit root state
         *
         * Gets the root of the state tree.
         * The root state is implicitly created by ng-router.
         * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]
         *
         * @return the root [[StateObject]]
         */
        root() {
          return this._root;
        }
        /**
         * Adds a state to the registry
         *
         * Registers a [[StateDeclaration]] or queues it for registration.
         *
         * Note: a state will be queued if the state's parent isn't yet registered.
         *
         * @param stateDefinition the definition of the state to register.
         * @returns the internal [[StateObject]] object.
         *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).
         *          If the state was only queued, then the object is not fully built.
         */
        register(stateDefinition) {
          return this.stateQueue.register(stateDefinition);
        }
        _deregisterTree(state) {
          const all = this.get().map((s) => s.$$state());
          const getChildren = (states) => {
            const _children = all.filter((s) => states.indexOf(s.parent) !== -1);
            return _children.length === 0 ? _children : _children.concat(getChildren(_children));
          };
          const children = getChildren([state]);
          const deregistered = [state].concat(children).reverse();
          deregistered.forEach((_state) => {
            const rulesApi = this.urlServiceRules;
            rulesApi.rules().filter(propEq("state", _state)).forEach((rule) => rulesApi.removeRule(rule));
            delete this.states[_state.name];
          });
          return deregistered;
        }
        /**
         * Removes a state from the registry
         *
         * This removes a state from the registry.
         * If the state has children, they are are also removed from the registry.
         *
         * @param stateOrName the state's name or object representation
         * @returns {import('./state-object').StateObject[]} a list of removed states
         */
        deregister(stateOrName) {
          const _state = this.get(stateOrName);
          if (!_state)
            throw new Error("Can't deregister state; not found: " + stateOrName);
          const deregisteredStates = this._deregisterTree(_state.$$state());
          this.listeners.forEach(
            (listener) => listener(
              "deregistered",
              deregisteredStates.map((s) => s.self)
            )
          );
          return deregisteredStates;
        }
        get(stateOrName, base) {
          if (arguments.length === 0)
            return Object.keys(this.states).map((name2) => this.states[name2].self);
          const found = this.matcher.find(stateOrName, base);
          return found && found.self || null;
        }
        /**
         * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).
         * More than one BuilderFunction can be registered for a given property.
         *
         * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.
         *
         * @param property The name of the State property being registered for.
         * @param builderFunction The BuilderFunction which will be used to build the State property
         * @returns a function which deregisters the BuilderFunction
         */
        decorator(property, builderFunction) {
          return this.builder.builder(property, builderFunction);
        }
      }
      const getLocals = (ctx) => {
        const tokens = ctx.getTokens().filter(isString);
        const tuples = tokens.map((key) => {
          const resolvable = ctx.getResolvable(key);
          const waitPolicy = ctx.getPolicy(resolvable).async;
          return [
            key,
            waitPolicy === "NOWAIT" ? resolvable.promise : resolvable.data
          ];
        });
        return tuples.reduce(applyPairs, {});
      };
      function parseStateRef(ref) {
        const paramsOnly = ref.match(/^\s*({[^}]*})\s*$/);
        if (paramsOnly) ref = "(" + paramsOnly[1] + ")";
        const parsed = ref.replace(/\n/g, " ").match(/^\s*([^(]*?)\s*(\((.*)\))?\s*$/);
        if (!parsed || parsed.length !== 4)
          throw new Error("Invalid state ref '" + ref + "'");
        return { state: parsed[1] || null, paramExpr: parsed[3] || null };
      }
      function stateContext(el) {
        const $ngView = getInheritedData(el, "$ngView");
        const path = parse("$cfg.path")($ngView);
        return path ? tail(path).state.name : void 0;
      }
      function processedDef($state, $element, def) {
        const ngState = def.ngState || $state.current.name;
        const ngStateOpts = Object.assign(
          defaultOpts($element, $state),
          def.ngStateOpts || {}
        );
        const href = $state.href(ngState, def.ngStateParams, ngStateOpts);
        return { ngState, ngStateParams: def.ngStateParams, ngStateOpts, href };
      }
      function getTypeInfo(el) {
        const isSvg = Object.prototype.toString.call(el.getAttribute("href")) === "[object SVGAnimatedString]";
        const isForm = el.nodeName === "FORM";
        return {
          attr: isForm ? "action" : isSvg ? "xlink:href" : "href",
          isAnchor: el.nodeName === "A",
          clickable: !isForm
        };
      }
      function clickHook(el, $state, type, getDef, scope) {
        return function(e) {
          const button = e.which || e.button, target = getDef();
          let res = button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || e.altKey || el.getAttribute("target");
          if (!res) {
            const transition = setTimeout(function() {
              if (!el.getAttribute("disabled")) {
                const res2 = $state.go(
                  target.ngState,
                  target.ngStateParams,
                  target.ngStateOpts
                );
                res2.then(() => {
                  scope.$emit("$updateBrowser");
                });
              }
            });
            e.preventDefault();
            let ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;
            e.preventDefault = function() {
              if (ignorePreventDefaultCount-- <= 0) clearTimeout(transition);
            };
          } else {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        };
      }
      function defaultOpts(el, $state) {
        return {
          relative: stateContext(el) || $state.$current,
          inherit: true,
          source: "sref"
        };
      }
      function bindEvents(element, scope, hookFn, ngStateOpts) {
        let events;
        if (ngStateOpts) {
          events = ngStateOpts.events;
        }
        if (!Array.isArray(events)) {
          events = ["click"];
        }
        for (const event of events) {
          element.addEventListener(event, hookFn);
        }
        scope.$on("$destroy", function() {
          for (const event of events) {
            element.removeEventListener(event, hookFn);
          }
        });
      }
      $StateRefDirective.$inject = ["$state", "$stateRegistry", "$transitions"];
      function $StateRefDirective($stateService, $stateRegistry, $transitions) {
        const $state = $stateService;
        return {
          restrict: "A",
          require: ["?^ngSrefActive", "?^ngSrefActiveEq"],
          link: (scope, element, attrs, ngSrefActive) => {
            const type = getTypeInfo(element);
            const active = ngSrefActive[1] || ngSrefActive[0];
            let unlinkInfoFn = null;
            const rawDef = {};
            const getDef = () => processedDef($state, element, rawDef);
            const ref = parseStateRef(attrs.ngSref);
            rawDef.ngState = ref.state;
            rawDef.ngStateOpts = attrs.ngSrefOpts ? scope.$eval(attrs.ngSrefOpts) : {};
            function update() {
              rawDef.ngStateParams = Object.assign({}, scope.$eval(ref.paramExpr));
              const def = getDef();
              if (unlinkInfoFn) {
                unlinkInfoFn();
              }
              if (active) {
                unlinkInfoFn = active.$$addStateInfo(def.ngState, def.ngStateParams);
              }
              if (def.href != null) {
                attrs.$set(type.attr, def.href);
              }
            }
            if (ref.paramExpr) {
              scope.$watch(
                ref.paramExpr,
                function(val2) {
                  rawDef.ngStateParams = Object.assign({}, val2);
                  update();
                },
                true
              );
              rawDef.ngStateParams = Object.assign({}, scope.$eval(ref.paramExpr));
            }
            update();
            scope.$on("$destroy", $stateRegistry.onStatesChanged(update));
            scope.$on("$destroy", $transitions.onSuccess({}, update));
            if (!type.clickable) {
              return;
            }
            bindEvents(
              element,
              scope,
              clickHook(element, $state, type, getDef, scope),
              rawDef.ngStateOpts
            );
          }
        };
      }
      $StateRefDynamicDirective.$inject = [
        "$state",
        "$stateRegistry",
        "$transitions"
      ];
      function $StateRefDynamicDirective($state, $stateRegistry, $transitions) {
        return {
          restrict: "A",
          require: ["?^ngSrefActive", "?^ngSrefActiveEq"],
          link: function(scope, element, attrs, ngSrefActive) {
            const type = getTypeInfo(element);
            const active = ngSrefActive[1] || ngSrefActive[0];
            let unlinkInfoFn = null;
            let hookFn;
            const rawDef = {};
            const getDef = () => processedDef($state, element, rawDef);
            const inputAttrs = ["ngState", "ngStateParams", "ngStateOpts"];
            const watchDeregFns = inputAttrs.reduce(
              (acc, attr) => (acc[attr] = () => {
              }, acc),
              {}
            );
            function update() {
              const def = getDef();
              if (unlinkInfoFn) {
                unlinkInfoFn();
              }
              if (active) {
                unlinkInfoFn = active.$$addStateInfo(def.ngState, def.ngStateParams);
              }
              if (def.href != null) {
                attrs.$set(type.attr, def.href);
              }
            }
            inputAttrs.forEach((field) => {
              rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;
              attrs.$observe(field, (expr) => {
                watchDeregFns[field]();
                watchDeregFns[field] = scope.$watch(expr, (newval) => {
                  rawDef[field] = newval;
                  update();
                });
              });
            });
            update();
            scope.$on("$destroy", $stateRegistry.onStatesChanged(update));
            scope.$on("$destroy", $transitions.onSuccess({}, update));
            if (!type.clickable) return;
            hookFn = clickHook(element, $state, type, getDef, scope);
            bindEvents(element, scope, hookFn, rawDef.ngStateOpts);
          }
        };
      }
      $StateRefActiveDirective.$inject = [
        "$state",
        "$router",
        "$interpolate",
        "$stateRegistry",
        "$transitions"
      ];
      function $StateRefActiveDirective($state, $router, $interpolate, $stateRegistry, $transitions) {
        return {
          restrict: "A",
          controller: function($scope, $element, $attrs) {
            let states = [];
            let activeEqClass;
            let ngSrefActive;
            activeEqClass = $interpolate($attrs.ngSrefActiveEq || "", false)($scope);
            try {
              ngSrefActive = $scope.$eval($attrs.ngSrefActive);
            } catch {
            }
            ngSrefActive = ngSrefActive || $interpolate($attrs.ngSrefActive || "", false)($scope);
            setStatesFromDefinitionObject(ngSrefActive);
            this.$$addStateInfo = function(newState, newParams) {
              if (isObject(ngSrefActive) && states.length > 0) {
                return;
              }
              const deregister = addState(newState, newParams, ngSrefActive);
              update();
              return deregister;
            };
            function updateAfterTransition(trans) {
              trans.promise.then(update, () => {
              });
            }
            $scope.$on("$destroy", setupEventListeners());
            if ($router.transition) {
              updateAfterTransition($router.transition);
            }
            function setupEventListeners() {
              const deregisterStatesChangedListener = $stateRegistry.onStatesChanged(handleStatesChanged);
              const deregisterOnStartListener = $transitions.onStart(
                {},
                updateAfterTransition
              );
              const deregisterStateChangeSuccessListener = $scope.$on(
                "$stateChangeSuccess",
                update
              );
              return function cleanUp() {
                deregisterStatesChangedListener();
                deregisterOnStartListener();
                deregisterStateChangeSuccessListener();
              };
            }
            function handleStatesChanged() {
              setStatesFromDefinitionObject(ngSrefActive);
            }
            function setStatesFromDefinitionObject(statesDefinition) {
              if (isObject(statesDefinition)) {
                states = [];
                Object.entries(statesDefinition).forEach(
                  ([activeClass, stateOrName]) => {
                    const addStateForClass = function(stateOrName2, activeClass2) {
                      const ref = parseStateRef(stateOrName2);
                      addState(ref.state, $scope.$eval(ref.paramExpr), activeClass2);
                    };
                    if (isString(stateOrName)) {
                      addStateForClass(stateOrName, activeClass);
                    } else if (Array.isArray(stateOrName)) {
                      stateOrName.forEach((stateOrName2) => {
                        addStateForClass(stateOrName2, activeClass);
                      });
                    }
                  }
                );
              }
            }
            function addState(stateName, stateParams, activeClass) {
              const state = $state.get(stateName, stateContext($element));
              const stateInfo = {
                state: state || { name: stateName },
                params: stateParams,
                activeClass
              };
              states.push(stateInfo);
              return function removeState() {
                removeFrom(states)(stateInfo);
              };
            }
            function update() {
              const splitClasses = (str) => str.split(/\s/).filter(Boolean);
              const getClasses = (stateList) => stateList.map((x) => x.activeClass).map(splitClasses).reduce(unnestR, []);
              const allClasses = getClasses(states).concat(splitClasses(activeEqClass)).reduce(uniqR, []);
              const fuzzyClasses = getClasses(
                states.filter((x) => $state.includes(x.state.name, x.params))
              );
              const exactlyMatchesAny = !!states.filter(
                (x) => $state.is(x.state.name, x.params)
              ).length;
              const exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [];
              const addClasses = fuzzyClasses.concat(exactClasses).reduce(uniqR, []);
              const removeClasses = allClasses.filter(
                (cls) => !addClasses.includes(cls)
              );
              addClasses.forEach((className) => $element.classList.add(className));
              removeClasses.forEach(
                (className) => $element.classList.remove(className)
              );
            }
            update();
          }
        };
      }
      let ngView = [
        "$view",
        "$animate",
        "$viewScroll",
        "$interpolate",
        /**
         * @param {*} $view
         * @param {*} $animate
         * @param {*} $viewScroll
         * @param {*} $interpolate
         * @returns {import("../../interface.js").Directive}
         */
        function $ViewDirective($view, $animate, $viewScroll, $interpolate) {
          function getRenderer() {
            return {
              enter: function(element, target, cb) {
                if (hasAnimate(element)) {
                  $animate.enter(element, null, target).then(cb);
                } else {
                  target.after(element);
                  cb();
                }
              },
              leave: function(element, cb) {
                if (hasAnimate(element)) {
                  $animate.leave(element).then(cb);
                } else {
                  element.parentElement.removeChild(element);
                  cb();
                }
              }
            };
          }
          function configsEqual(config1, config2) {
            return config1 === config2;
          }
          const rootData = {
            $cfg: { viewDecl: { $context: $view.rootViewContext() } },
            $ngView: {}
          };
          const directive = {
            count: 0,
            terminal: true,
            priority: 400,
            transclude: "element",
            compile: function(_tElement, _tAttrs, $transclude) {
              return function(scope, $element, attrs) {
                const onloadExp = attrs["onload"] || "", autoScrollExp = attrs["autoscroll"], renderer = getRenderer(), inherited = getInheritedData($element, "$ngView") || rootData, name2 = $interpolate(attrs["ngView"] || attrs["name"] || "")(scope) || "$default";
                let previousEl, currentEl, currentScope, viewConfig;
                const activeUIView = {
                  id: directive.count++,
                  // Global sequential ID for ng-view tags added to DOM
                  name: name2,
                  // ng-view name (<div ng-view="name"></div>
                  fqn: inherited.$ngView.fqn ? inherited.$ngView.fqn + "." + name2 : name2,
                  // fully qualified name, describes location in DOM
                  config: null,
                  // The ViewConfig loaded (from a state.views definition)
                  configUpdated: configUpdatedCallback,
                  // Called when the matching ViewConfig changes
                  get creationContext() {
                    const fromParentTagConfig = parse("$cfg.viewDecl.$context")(
                      inherited
                    );
                    const fromParentTag = parse("$ngView.creationContext")(inherited);
                    return fromParentTagConfig || fromParentTag;
                  }
                };
                trace.traceUIViewEvent("Linking", activeUIView);
                function configUpdatedCallback(config) {
                  if (config && !(config instanceof ViewConfig)) return;
                  if (configsEqual(viewConfig, config)) return;
                  trace.traceUIViewConfigUpdated(
                    activeUIView,
                    config && config.viewDecl && config.viewDecl.$context
                  );
                  viewConfig = config;
                  updateView(config);
                }
                setCacheData($element, "$ngView", { $ngView: activeUIView });
                updateView();
                const unregister = $view.registerUIView(activeUIView);
                scope.$on("$destroy", function() {
                  trace.traceUIViewEvent("Destroying/Unregistering", activeUIView);
                  unregister();
                });
                function cleanupLastView() {
                  if (previousEl) {
                    trace.traceUIViewEvent(
                      "Removing (previous) el",
                      getCacheData(previousEl, "$ngView")
                    );
                    previousEl.remove();
                    previousEl = null;
                  }
                  if (currentScope) {
                    trace.traceUIViewEvent("Destroying scope", activeUIView);
                    currentScope.$destroy();
                    currentScope = null;
                  }
                  if (currentEl) {
                    const _viewData = getCacheData(currentEl, "$ngViewAnim");
                    trace.traceUIViewEvent("Animate out", _viewData);
                    renderer.leave(currentEl, function() {
                      _viewData.$$animLeave.resolve();
                      previousEl = null;
                    });
                    previousEl = currentEl;
                    currentEl = null;
                  }
                }
                function updateView(config) {
                  const newScope = scope.$new();
                  const animEnter = Promise.withResolvers();
                  const animLeave = Promise.withResolvers();
                  const $ngViewData = {
                    $cfg: config,
                    $ngView: activeUIView
                  };
                  const $ngViewAnim = {
                    $animEnter: animEnter.promise,
                    $animLeave: animLeave.promise,
                    $$animLeave: animLeave
                  };
                  newScope.$emit("$viewContentLoading", name2);
                  currentEl = $transclude(newScope, function(clone) {
                    setCacheData(clone, "$ngViewAnim", $ngViewAnim);
                    setCacheData(clone, "$ngView", $ngViewData);
                    renderer.enter(clone, $element, function() {
                      animEnter.resolve();
                      if (currentScope)
                        currentScope.$emit("$viewContentAnimationEnded");
                      if (isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                        $viewScroll(clone);
                      }
                    });
                    cleanupLastView();
                  });
                  currentScope = newScope;
                  currentScope.$emit("$viewContentLoaded", config || viewConfig);
                  currentScope.$eval(onloadExp);
                }
              };
            }
          };
          return directive;
        }
      ];
      $ViewDirectiveFill.$inject = ["$compile", "$controller", "$transitions"];
      function $ViewDirectiveFill($compile, $controller, $transitions) {
        const getControllerAs = parse("viewDecl.controllerAs");
        const getResolveAs = parse("viewDecl.resolveAs");
        return {
          priority: -400,
          compile: function(tElement) {
            const initial = tElement.innerHTML;
            dealoc(tElement, true);
            return function(scope, $element) {
              const data = getCacheData($element, "$ngView");
              if (!data) {
                $element.innerHTML = initial;
                $compile($element.contentDocument || $element.childNodes)(scope);
                return;
              }
              const cfg = data.$cfg || { viewDecl: {}, getTemplate: () => {
              } };
              const resolveCtx = cfg.path && new ResolveContext(cfg.path);
              $element.innerHTML = cfg.getTemplate($element, resolveCtx) || initial;
              trace.traceUIViewFill(data.$ngView, $element.innerHTML);
              const link = $compile($element.contentDocument || $element.childNodes);
              const controller = cfg.controller;
              const controllerAs = getControllerAs(cfg);
              const resolveAs = getResolveAs(cfg);
              const locals = resolveCtx && getLocals(resolveCtx);
              if (resolveAs) {
                scope.$target[resolveAs] = locals;
              }
              if (controller) {
                const controllerInstance = $controller(
                  controller,
                  Object.assign({}, locals, { $scope: scope, $element })
                );
                if (controllerAs) {
                  scope.$target[controllerAs] = controllerInstance;
                  scope.$target[controllerAs][resolveAs] = locals;
                }
                setCacheData($element, "$ngControllerController", controllerInstance);
                Array.from($element.children).forEach((e) => {
                  setCacheData(e, "$ngControllerController", controllerInstance);
                });
                registerControllerCallbacks(
                  $transitions,
                  controllerInstance,
                  scope,
                  cfg
                );
              }
              link(scope);
            };
          }
        };
      }
      let _uiCanExitId = 0;
      function registerControllerCallbacks($transitions, controllerInstance, $scope, cfg) {
        if (isFunction(controllerInstance.$onInit) && !(cfg.viewDecl.component || cfg.viewDecl.componentProvider)) {
          controllerInstance.$onInit();
        }
        const viewState = tail(cfg.path).state.self;
        const hookOptions = { bind: controllerInstance };
        if (isFunction(controllerInstance.uiOnParamsChanged)) {
          const resolveContext = new ResolveContext(cfg.path);
          const viewCreationTrans = resolveContext.getResolvable("$transition$").data;
          const paramsUpdated = ($transition$) => {
            if ($transition$ === viewCreationTrans || $transition$.exiting().indexOf(viewState) !== -1)
              return;
            const toParams = $transition$.params("to");
            const fromParams = $transition$.params("from");
            const getNodeSchema = (node) => node.paramSchema;
            const toSchema = $transition$.treeChanges("to").map(getNodeSchema).reduce(unnestR, []);
            const fromSchema = $transition$.treeChanges("from").map(getNodeSchema).reduce(unnestR, []);
            const changedToParams = toSchema.filter((param) => {
              const idx = fromSchema.indexOf(param);
              return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);
            });
            if (changedToParams.length) {
              const changedKeys = changedToParams.map((x) => x.id);
              const newValues = filter(
                toParams,
                (val2, key) => changedKeys.indexOf(key) !== -1
              );
              controllerInstance.uiOnParamsChanged(newValues, $transition$);
            }
          };
          $scope.$on(
            "$destroy",
            $transitions.onSuccess({}, paramsUpdated, hookOptions)
          );
        }
        if (isFunction(controllerInstance.uiCanExit)) {
          const id2 = _uiCanExitId++;
          const cacheProp = "_uiCanExitIds";
          const prevTruthyAnswer = (trans) => !!trans && (trans[cacheProp] && trans[cacheProp][id2] === true || prevTruthyAnswer(trans.redirectedFrom()));
          const wrappedHook = (trans) => {
            let promise;
            const ids = trans[cacheProp] = trans[cacheProp] || {};
            if (!prevTruthyAnswer(trans)) {
              promise = Promise.resolve(controllerInstance.uiCanExit(trans));
              promise.then((val2) => ids[id2] = val2 !== false);
            }
            return promise;
          };
          const criteria = { exiting: viewState.name };
          $scope.$on(
            "$destroy",
            $transitions.onBefore(criteria, wrappedHook, hookOptions)
          );
        }
      }
      ngChannelDirective.$inject = [$injectTokens.$eventBus];
      function ngChannelDirective($eventBus) {
        return {
          link: (scope, element, attrs) => {
            const channel = attrs["ngChannel"];
            const hasTemplateContent = element.childNodes.length > 0;
            const key = $eventBus.subscribe(channel, (value) => {
              if (hasTemplateContent) {
                if (isObject(value)) {
                  scope.$merge(value);
                }
              } else {
                element.innerHTML = value;
              }
            });
            scope.$on("$destroy", () => {
              $eventBus.unsubscribeByKey(key);
            });
          }
        };
      }
      ngSetterDirective.$inject = [$injectTokens.$parse, $injectTokens.$log];
      function ngSetterDirective($parse2, $log) {
        return {
          restrict: "A",
          link(scope, element, attrs) {
            const modelExpression = attrs["ngSetter"];
            if (!modelExpression) {
              $log.warn("ng-setter: expression null");
              return;
            }
            const assignModel = $parse2(modelExpression).assign;
            if (!assignModel) {
              $log.warn("ng-setter: expression invalid");
              return;
            }
            const updateModel = (value) => {
              assignModel(scope, value.trim());
            };
            const observer = new MutationObserver((mutationsList) => {
              let contentChanged = false;
              for (const mutation of mutationsList) {
                if (mutation.type === "childList" || mutation.type === "characterData") {
                  contentChanged = true;
                  break;
                }
              }
              if (contentChanged) {
                updateModel(element.innerHTML);
              }
            });
            observer.observe(element, {
              childList: true,
              subtree: true,
              characterData: true
            });
            scope.$on("$destroy", () => observer.disconnect());
            updateModel(element.innerHTML);
          }
        };
      }
      function defineDirective(method) {
        const attrName = "ng" + method.charAt(0).toUpperCase() + method.slice(1);
        const directive = createHttpDirective(method, attrName);
        directive["$inject"] = [$injectTokens.$http, $injectTokens.$compile, $injectTokens.$log, $injectTokens.$parse, $injectTokens.$state];
        return directive;
      }
      const ngGetDirective = defineDirective("get");
      const ngDeleteDirective = defineDirective("delete");
      const ngPostDirective = defineDirective("post");
      const ngPutDirective = defineDirective("put");
      function getEventNameForElement(element) {
        const tag = element.tagName.toLowerCase();
        if (["input", "textarea", "select"].includes(tag)) {
          return "change";
        } else if (tag === "form") {
          return "submit";
        }
        return "click";
      }
      function handleSwapResponse(html, swap, target, scope, $compile) {
        let nodes = [];
        if (!["textcontent", "delete", "none"].includes(swap)) {
          if (!html) {
            return;
          }
          if (isObject(html)) {
            scope.$merge(html);
            return;
          }
          const compiled = $compile(html)(scope);
          nodes = compiled instanceof DocumentFragment ? Array.from(compiled.childNodes) : [compiled];
        }
        switch (swap) {
          case "innerHTML":
            target.replaceChildren(...nodes);
            break;
          case "outerHTML": {
            const parent = target.parentNode;
            if (!parent) return;
            const frag = document.createDocumentFragment();
            nodes.forEach((n) => frag.appendChild(n));
            parent.replaceChild(frag, target);
            break;
          }
          case "textContent":
            target.textContent = html;
            break;
          case "beforebegin":
            nodes.forEach((node) => target.parentNode.insertBefore(node, target));
            break;
          case "afterbegin":
            nodes.slice().reverse().forEach((node) => target.insertBefore(node, target.firstChild));
            break;
          case "beforeend":
            nodes.forEach((node) => target.appendChild(node));
            break;
          case "afterend":
            nodes.slice().reverse().forEach(
              (node) => target.parentNode.insertBefore(node, target.nextSibling)
            );
            break;
          case "delete":
            target.remove();
            break;
          case "none":
            break;
          default:
            target.replaceChildren(...nodes);
            break;
        }
      }
      function createHttpDirective(method, attrName) {
        return function($http, $compile, $log, $parse2, $state) {
          function collectFormData(element) {
            let form = null;
            const tag = element.tagName.toLowerCase();
            if (tag === "form") {
              form = /** @type {HTMLFormElement} */
              element;
            } else if ("form" in element && element.form) {
              form = /** @type {HTMLFormElement} */
              element.form;
            } else if (element.hasAttribute("form")) {
              const formId = element.getAttribute("form");
              if (formId) {
                const maybeForm = document.getElementById(formId);
                if (maybeForm && maybeForm.tagName.toLowerCase() === "form") {
                  form = /** @type {HTMLFormElement} */
                  maybeForm;
                }
              }
            }
            if (!form) {
              if ("name" in element && typeof element.name === "string" && element.name.length > 0) {
                if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement) {
                  const key = element.name;
                  const value = element.value;
                  return { [key]: value };
                }
              }
              return {};
            }
            const formData = new FormData(form);
            const data = {};
            formData.forEach((value, key) => {
              data[key] = value;
            });
            return data;
          }
          return {
            restrict: "A",
            link(scope, element, attrs) {
              const eventName = attrs["trigger"] || /** @type {EventType} */
              getEventNameForElement(element);
              const tag = element.tagName.toLowerCase();
              if (isDefined(attrs["latch"])) {
                attrs.$observe(
                  "latch",
                  callBackAfterFirst(
                    () => element.dispatchEvent(new Event(eventName))
                  )
                );
              }
              let throttled = false;
              let intervalId;
              if (isDefined(attrs["interval"])) {
                element.dispatchEvent(new Event(eventName));
                intervalId = setInterval(
                  () => element.dispatchEvent(new Event(eventName)),
                  parseInt(attrs["interval"]) || 1e3
                );
              }
              element.addEventListener(eventName, async (event) => {
                if (
                  /** @type {HTMLButtonElement} */
                  element.disabled
                ) return;
                if (tag === "form") event.preventDefault();
                const swap = attrs["swap"] || "innerHTML";
                const targetSelector = attrs["target"];
                const target = targetSelector ? document.querySelector(targetSelector) : element;
                if (!target) {
                  $log.warn(`${attrName}: target "${targetSelector}" not found`);
                  return;
                }
                const url = attrs[attrName];
                if (!url) {
                  $log.warn(`${attrName}: no URL specified`);
                  return;
                }
                const handler = (res) => {
                  if (isDefined(attrs["loading"])) {
                    attrs.$set("loading", false);
                  }
                  if (isDefined(attrs["loadingClass"])) {
                    attrs.$removeClass(attrs["loadingClass"]);
                  }
                  const html = res.data;
                  if (200 <= res.status && res.status <= 299) {
                    if (isDefined(attrs["success"])) {
                      $parse2(attrs["success"])(scope, { $res: html });
                    }
                    if (isDefined(attrs["stateSuccess"])) {
                      $state.go(attrs["stateSuccess"]);
                    }
                  } else if (400 <= res.status && res.status <= 599) {
                    if (isDefined(attrs["error"])) {
                      $parse2(attrs["error"])(scope, { $res: html });
                    }
                    if (isDefined(attrs["stateError"])) {
                      $state.go(attrs["stateError"]);
                    }
                  }
                  handleSwapResponse(
                    html,
                    /** @type {import("../../interface.ts").SwapModeType} */
                    swap,
                    target,
                    scope,
                    $compile
                  );
                };
                if (isDefined(attrs["delay"])) {
                  await wait(parseInt(attrs["delay"]) | 0);
                }
                if (throttled) {
                  return;
                }
                if (isDefined(attrs["throttle"])) {
                  throttled = true;
                  attrs.$set("throttled", true);
                  setTimeout(() => {
                    attrs.$set("throttled", false);
                    throttled = false;
                  }, parseInt(attrs["throttle"]));
                }
                if (isDefined(attrs["loading"])) {
                  attrs.$set("loading", true);
                }
                if (isDefined(attrs["loadingClass"])) {
                  attrs.$addClass(attrs["loadingClass"]);
                }
                if (method === "post" || method === "put") {
                  let data;
                  const config = {};
                  if (attrs["enctype"]) {
                    config.headers = {
                      "Content-Type": attrs["enctype"]
                    };
                    data = toKeyValue(collectFormData(element));
                  } else {
                    data = collectFormData(element);
                  }
                  $http[method](url, data, config).then(handler).catch(handler);
                } else {
                  $http[method](url).then(handler).catch(handler);
                }
              });
              scope.$on("$destroy", () => clearInterval(intervalId));
            }
          };
        };
      }
      function registerNgModule(angular2) {
        return angular2.module(
          "ng",
          [],
          [
            $injectTokens.$provide,
            /** @param {import("./interface.js").Provider} $provide */
            ($provide) => {
              $provide.provider({
                $$sanitizeUri: SanitizeUriProvider
              });
              $provide.provider($injectTokens.$compile, CompileProvider).directive({
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngDelete: ngDeleteDirective,
                ngDisabled: ngDisabledAriaDirective,
                ngForm: ngFormDirective,
                ngGet: ngGetDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngMessages: ngMessagesDirective,
                ngMessage: ngMessageDirective,
                ngMessageExp: ngMessageExpDirective,
                ngMessagesInclude: ngMessagesIncludeDirective,
                ngMessageDefault: ngMessageDefaultDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPost: ngPostDirective,
                ngPut: ngPutDirective,
                ngRef: ngRefDirective,
                ngRepeat: ngRepeatDirective,
                ngSetter: ngSetterDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                ngMinlength: minlengthDirective,
                minlength: minlengthDirective,
                ngMaxlength: maxlengthDirective,
                maxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
              }).directive({
                input: hiddenInputBrowserCacheDirective,
                ngAnimateSwap: ngAnimateSwapDirective,
                ngAnimateChildren: $$AnimateChildrenDirective,
                ngChecked: ngCheckedAriaDirective,
                ngClick: ngClickAriaDirective,
                ngDblclick: ngDblclickAriaDirective,
                ngInclude: ngIncludeFillContentDirective,
                ngHide: ngHideAriaDirective,
                ngShow: ngShowAriaDirective,
                ngMessages: ngMessagesAriaDirective,
                ngModel: ngModelAriaDirective,
                ngReadonly: ngReadonlyAriaDirective,
                ngRequired: ngRequiredAriaDirective,
                ngValue: ngValueAriaDirective,
                ngSref: $StateRefDirective,
                ngSrefActive: $StateRefActiveDirective,
                ngSrefActiveEq: $StateRefActiveDirective,
                ngState: $StateRefDynamicDirective,
                ngView,
                ngChannel: ngChannelDirective
              }).directive({
                ngView: $ViewDirectiveFill
              }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
              $provide.provider({
                $aria: AriaProvider,
                $anchorScroll: AnchorScrollProvider,
                $animate: AnimateProvider,
                $$animation: AnimationProvider,
                $animateCss: AnimateCssProvider,
                $$animateCssDriver: AnimateCssDriverProvider,
                $$animateJs: AnimateJsProvider,
                $$animateJsDriver: AnimateJsDriverProvider,
                $$animateCache: AnimateCacheProvider,
                $$animateQueue: AnimateQueueProvider,
                $$AnimateRunner: AnimateRunnerFactoryProvider,
                $$animateAsyncRun: AnimateAsyncRunFactoryProvider,
                $controller: ControllerProvider,
                $exceptionHandler: ExceptionHandlerProvider,
                $filter: FilterProvider,
                $interpolate: InterpolateProvider,
                $http: HttpProvider,
                $httpParamSerializer: HttpParamSerializerProvider,
                $httpBackend: HttpBackendProvider,
                $location: LocationProvider,
                $log: LogProvider,
                $parse: ParseProvider,
                $$rAFScheduler: RafSchedulerProvider,
                $rootScope: RootScopeProvider,
                $router: Router,
                $sce: SceProvider,
                $sceDelegate: SceDelegateProvider,
                $templateCache: TemplateCacheProvider,
                $templateRequest: TemplateRequestProvider,
                $urlConfig: UrlConfigProvider,
                $view: ViewService,
                $transitions: TransitionProvider,
                $state: StateProvider,
                $viewScroll: ViewScrollProvider,
                $templateFactory: TemplateFactoryProvider,
                $url: UrlService,
                $stateRegistry: StateRegistryProvider,
                $eventBus: PubSubProvider
              });
            }
          ]
        ).factory("$stateParams", [
          $injectTokens.$router,
          /**
           * @param {import('./router/router.js').Router} globals
           * @returns {import('./router/params/state-params.js').StateParams }
           */
          (globals) => globals.params
        ]).value("$trace", trace);
      }
      const ngMinErr = minErr("ng");
      const $injectorMinErr = minErr("$injector");
      const modules = {};
      class Angular {
        constructor() {
          this.$cache = Cache;
          this.$eventBus = EventBus;
          this.version = "0.9.3";
          this.bootsrappedModules = [];
          this.getController = getController;
          this.getInjector = getInjector;
          this.getScope = getScope;
          this.errorHandlingConfig = errorHandlingConfig;
          this.$t = $injectTokens;
          window["angular"] = this;
          registerNgModule(this);
        }
        /**
         * Use this function to manually start up AngularTS application.
         *
         * AngularTS will detect if it has been loaded into the browser more than once and only allow the
         * first loaded script to be bootstrapped and will report a warning to the browser console for
         * each of the subsequent scripts. This prevents strange results in applications, where otherwise
         * multiple instances of AngularTS try to work on the DOM.
         *   *
         * <div class="alert alert-warning">
         * **Note:** Do not bootstrap the app on an element with a directive that uses {@link ng.$compile#transclusion transclusion},
         * such as {@link ng.ngIf `ngIf`}, {@link ng.ngInclude `ngInclude`} and {@link ngRoute.ngView `ngView`}.
         * Doing this misplaces the app {@link ng.$rootElement `$rootElement`} and the app's {@link auto.$injector injector},
         * causing animations to stop working and making the injector inaccessible from outside the app.
         * </div>
         *
         * ```html
         * <!doctype html>
         * <html>
         * <body>
         * <div ng-controller="WelcomeController">
         *   {{greeting}}
         * </div>
         *
         * <script src="angular.js"><\/script>
         * <script>
         *   let app = angular.module('demo', [])
         *   .controller('WelcomeController', function($scope) {
         *       $scope.greeting = 'Welcome!';
         *   });
         *   angular.bootstrap(document, ['demo']);
         * <\/script>
         * </body>
         * </html>
         * ```
         *
         * @param {string | Element | Document} element DOM element which is the root of AngularTS application.
         * @param {Array<String|any>} [modules] an array of modules to load into the application.
         *     Each item in the array should be the name of a predefined module or a (DI annotated)
         *     function that will be invoked by the injector as a `config` block.
         *     See: {@link angular.module modules}
         * @param {AngularBootstrapConfig} [config]
         * @returns {import('./core/di/internal-injector.js').InjectorService} The created injector instance for this application.
         */
        bootstrap(element, modules2, config) {
          config = config || {
            strictDi: false
          };
          if ((element instanceof Element || element instanceof Document) && getInjector(
            /** @type {Element} */
            element
          )) {
            throw ngMinErr("btstrpd", "App already bootstrapped");
          }
          if (Array.isArray(modules2)) {
            this.bootsrappedModules = modules2;
          }
          this.bootsrappedModules.unshift([
            "$provide",
            /**
             * @param {import('./interface.ts').Provider} $provide
             */
            ($provide) => {
              $provide.value("$rootElement", element);
            }
          ]);
          this.bootsrappedModules.unshift("ng");
          const injector = createInjector(this.bootsrappedModules, config.strictDi);
          injector.invoke([
            $injectTokens.$rootScope,
            $injectTokens.$rootElement,
            $injectTokens.$compile,
            $injectTokens.$injector,
            /**
             * @param {import('./core/scope/scope.js').Scope} scope
             * @param {Element} el
             * @param {import("./core/compile/compile.js").CompileFn} compile
             * @param {import("./core/di/internal-injector.js").InjectorService} $injector
             */
            (scope, el, compile, $injector) => {
              this.$injector = $injector;
              setCacheData(el, "$injector", $injector);
              const compileFn = compile(el);
              compileFn(scope);
              if (!hasOwn($injector, "strictDi")) {
                try {
                  $injector.invoke(() => {
                  });
                } catch (error) {
                  $injector.strictDi = !!/strict mode/.exec(
                    error && error.toString()
                  );
                }
              }
              $injector.get($injectTokens.$stateRegistry).get().map((x) => x.$$state().resolvables).reduce(unnestR, []).filter((x) => x.deps === "deferred").forEach(
                (resolvable) => resolvable.deps = annotate(
                  resolvable.resolveFn,
                  $injector.strictDi
                )
              );
            }
          ]);
          return injector;
        }
        /**
         * @param {any[]} modules
         * @param {boolean?} strictDi
         * @returns {import("./core/di/internal-injector.js").InjectorService}
         */
        injector(modules2, strictDi) {
          return createInjector(modules2, strictDi);
        }
        /**
         * @param {Element|Document} element
         */
        init(element) {
          let appElement;
          let module2;
          const config = {};
          ngAttrPrefixes.forEach((prefix) => {
            const name2 = `${prefix}app`;
            if (
              /** @type {Element} */
              element.hasAttribute && /** @type {Element} */
              element.hasAttribute(name2)
            ) {
              appElement = element;
              module2 = /** @type {Element} */
              element.getAttribute(name2);
            }
          });
          ngAttrPrefixes.forEach((prefix) => {
            const name2 = `${prefix}app`;
            let candidate;
            if (!appElement && (candidate = element.querySelector(`[${name2.replace(":", "\\:")}]`))) {
              appElement = candidate;
              module2 = candidate.getAttribute(name2);
            }
          });
          if (appElement) {
            config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
            this.bootstrap(appElement, module2 ? [module2] : [], config);
          }
        }
        /**
         *
         * The `angular.module` is a global place for creating, registering and retrieving AngularTS
         * modules.
         * All modules (AngularTS core or 3rd party) that should be available to an application must be
         * registered using this mechanism.
         *
         * Passing one argument retrieves an existing {@link import('./interface.ts').Module},
         * whereas passing more than one argument creates a new {@link import('./interface.ts').Module}
         *
         *
         * # Module
         *
         * A module is a collection of services, directives, controllers, filters, and configuration information.
         * `angular.module` is used to configure the {@link auto.$injector $injector}.
         *
         * ```js
         * // Create a new module
         * let myModule = angular.module('myModule', []);
         *
         * // register a new service
         * myModule.value('appName', 'MyCoolApp');
         *
         * // configure existing services inside initialization blocks.
         * myModule.config(['$locationProvider', function($locationProvider) {
         *   // Configure existing providers
         *   $locationProvider.hashPrefix('!');
         * }]);
         * ```
         *
         * Then you can create an injector and load your modules like this:
         *
         * ```js
         * let injector = angular.injector(['ng', 'myModule'])
         * ```
         *
         * However it's more likely that you'll just use
         * {@link ng.directive:ngApp ngApp} or
         * {@link angular.bootstrap} to simplify this process for you.
         *
         * @param {string} name The name of the module to create or retrieve.
         * @param {Array.<string>} [requires] If specified then new module is being created. If
         *        unspecified then the module is being retrieved for further configuration.
         * @param {import("./interface.js").Injectable} [configFn] Optional configuration function for the module that gets
         *        passed to {@link NgModule.config NgModule.config()}.
         * @returns {NgModule} A newly registered module.
         */
        module(name2, requires, configFn) {
          assertNotHasOwnProperty(name2, "module");
          if (requires && hasOwn(modules, name2)) {
            modules[name2] = null;
          }
          return ensure(modules, name2, () => {
            if (!requires) {
              throw $injectorMinErr(
                "nomod",
                "Module '{0}' is not available. Possibly misspelled or not loaded",
                name2
              );
            }
            return new NgModule(name2, requires, configFn);
          });
        }
      }
      function ensure(obj, name2, factory) {
        return obj[name2] || (obj[name2] = factory());
      }
      const angular = new Angular();
      document.addEventListener("DOMContentLoaded", () => angular.init(document), {
        once: true
      });
      exports2.angular = angular;
    }));
  }
});
export default require_angular_ts_umd();
//# sourceMappingURL=@angular-wave_angular__ts.js.map
